---
title: 程序设计训练2021-作业训练二
date: 2021-07-12 12:27:53
tags: [ 'CCF', 'C++' ]
---

# 导航

###### [一、字符串反转2](#字符串反转2)
###### [二、487-3279](#487-3279)
# 字符串反转2

> 类型：字符串
>
> 难度：1

## 【问题描述】

&emsp;&emsp;给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： “hello xiao mi”-> “mi xiao hello”

## 【输入形式】

&emsp;&emsp;输入数据有多组，每组占一行，包含一个句子(句子长度小于1000个字符)

## 【输出形式】

&emsp;&emsp;对于每个测试示例，要求输出句子中单词反转后形成的句子

## 【样例输入】

    hello xiao mi
    I am a student

## 【样例输出】

    mi xiao hello
    student a am I

## 【思路】

&emsp;&emsp;利用栈的先入后出特性，将每个单词作为一个元素推入栈中，再依次出栈。

## 【代码（C++）】
```
#include <iostream>
#include <stack>
#include <sstream>

using namespace std;

int main() {
    stack<string> s;
    string str;
    stringstream sstream; // 利用字符串流得到每行的每个单词
    ios::sync_with_stdio(false); // 清除IO流缓存，使其效率接近scanf与printf
    cout.tie(nullptr); // 解除cout绑定 注意不要与printf混用
    while (getline(cin, str)) { // 以行读入
        sstream << str; //输入到字符串流
        string word;
        while (sstream >> word) { // 从字符串流流输出单词
            s.push(word); // 单词入栈
        }
        while (!s.empty()) {
            cout << s.top() << " ";
            s.pop(); // 将已输出单词出栈
        }
        cout << "\n";
        sstream.clear(); // 清空字符串流，避免未知错误
    }
}
```

# 487-3279

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;每个人都喜欢有令人难忘的电话号码。要想让电话号码变得令人难忘的一种方法是拼出一个令人难忘的单词或短语。例如，你可以拨打滑铁卢大学的电话，拨打令人难忘的电话号码TUT-GLOP。

&emsp;&emsp;有时只有一部分号码被用来拼写一个单词，例如，你可以拨打310-gino从Gino's订购披萨。

&emsp;&emsp;要使电话号码令人难忘的另一种方法是以一种令人难忘的方式对数字进行分组。你可以从比萨饼小屋中订购比萨饼，方法是拨打他们的“3个10”，即号码3-10-10-10。

&emsp;&emsp;电话号码的标准格式是七位的十进制数字，第三和第四位之间包含连字符（例如888-1200）。电话的键盘提供字母到数字的映射，如下所示：

&emsp;&emsp;A, B, C映射到2

&emsp;&emsp;D, E, F映射到3

&emsp;&emsp;G, H, I映射到4

&emsp;&emsp;J, K, L映射到5

&emsp;&emsp;M, N, O映射到6

&emsp;&emsp;P, R, S映射到7

&emsp;&emsp;T, U, V映射到8

&emsp;&emsp;W, X, Y映射到9

&emsp;&emsp;Q和Z没有映射。连接符不拨号，必要时可加上或去除。TUT-GLOP的标准格式是888-4567，310-GINO的标准格式是310-4466，3-10-10-10的标准格式是310-1010。

&emsp;&emsp;当两个电话号码有相同的标准格式时是等价的（拨同样的号码）。

&emsp;&emsp;你的公司正在编制本地企业的电话号码目录，作为质量控制的一部分，你需要检查没有两个（或多个）企业具有相同的电话号码。

## 【输入形式】

&emsp;&emsp;输入包括一个案例。输入的第一行为一个正整数，指定目录中电话号码的数目(最多100，000)。其余的各行列出目录中的电话号码，每个号码单独占一行。每个电话号码都是一个由十进制数字、大写字母(不包括Q和z)和连字符组成的字符串。字符串中的七个字符或是数字或是字母。

## 【输出形式】

&emsp;&emsp;对于出现超过一次的每个号码，按照标准格式及字典序每个输出一行，然后是空格，接着输出出现的次数。只出现1次的电话号码不输出。

## 【样例输入】

    12
    4873279
    ITS-EASY
    888-4567
    3-10-10-10
    888-GLOP
    TUT-GLOP
    967-11-11
    310-GINO
    F101010
    888-1200
    -4-8-7-3-2-7-9-
    487-3279

## 【样例输出】

    310-1010 2
    487-3279 4
    888-4567 3

## 【思路】

&emsp;&emsp;先将输入的号码标准格式化，按照字典序排序后，再计数判断并输出

## 【代码（C++）】
```
#include <iostream>
#include <sstream>
#include <algorithm>

using namespace std;

int main() {
    int n;
    cin >> n;
    string str[n]; // 定义最终字符串数组
    for (int i = 0; i < n; ++i) {
        string tmpNum; // 定义临时变量用于接收待处理号码
        stringstream sstream; // 定义字符串流用于处理号码中的每个字符
        stringstream sstreamOut; // 定义字符串流用于构造标准格式号码
        cin >> tmpNum;
        sstream << tmpNum; // 入流
        char a; // 定义单个字符用于接收
        int count = 0; // 处理的字符个数，用于判断是否到第三个数字以构造 '-'
        while (sstream >> a) {
            if (a != '-') {
                sstreamOut << a;
                count++;
                if (count == 3)
                    sstreamOut << '-'; // 构造 xxx-xxxx 中的 -
            }
        }
        string formatNum; // 定义标准格式号码
        sstreamOut >> formatNum; // 从字符串流输出到formatNum
        for (int j = 0; j < 8; ++j) { // 将号码中的字母转为数字
            if (formatNum[j] >= 'A' && formatNum[j] <= 'C')
                formatNum[j] = '2';
            else if (formatNum[j] >= 'D' && formatNum[j] <= 'F')
                formatNum[j] = '3';
            else if (formatNum[j] >= 'G' && formatNum[j] <= 'I')
                formatNum[j] = '4';
            else if (formatNum[j] >= 'J' && formatNum[j] <= 'L')
                formatNum[j] = '5';
            else if (formatNum[j] >= 'M' && formatNum[j] <= 'O')
                formatNum[j] = '6';
            else if (formatNum[j] >= 'P' && formatNum[j] <= 'S')
                formatNum[j] = '7';
            else if (formatNum[j] >= 'T' && formatNum[j] <= 'V')
                formatNum[j] = '8';
            else if (formatNum[j] >= 'W' && formatNum[j] <= 'Y')
                formatNum[j] = '9';
        }
        str[i] = formatNum; // 将构造好的标准格式号码赋值给最终的判断数组
    }
    sort(str, str + n); // 按照字典序排序
    int numCount = 1; // 定义号码出现次数，用于判断
    for (int i = 0; i < n - 1; ++i) {
//        cout << str[i] << endl;
        if (str[i] == str[i + 1]) { // 如果当前号码和下个号码一样，则计数+1
            numCount++;
        } else { // 如果不一样，当计数＞1时，按照格式输出，并且重新计数
            if (numCount > 1)
                cout << str[i] << " " << numCount << endl;
            numCount = 1;
        }
    }
}
```