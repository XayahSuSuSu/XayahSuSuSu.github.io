[{"title":"AARCH64交叉编译笔记","url":"/2021/07/07/AARCH64%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%AC%94%E8%AE%B0/","content":"Github地址\nAndroid NDK 版本：r22b (22.1.7171670)\n目标平台：AArch64\n\n环境准备\n下载 Android NDK\n\n解压\n\n\nCMake 交叉编译 (以 Brotli 为例)\n更新Cmake版本 (最低 3.19 )\n以 cmake-3.21.0-rc1 为例：\nwget https://cmake.org/files/v3.21/cmake-3.21.0-rc1.tar.gztar -xvf cmake-3.21.0-rc1.tar.gzcd cmake-3.21.0-rc1./configuresudo makesudo make installcmake --version         # 检查版本\n克隆 Brotli\ngit clone https://github.com/google/brotli\n交叉编译\ncd brotlimkdir out &amp;&amp; cd outexport NDK=/home/xayah/Compile/NDK             # NDK根目录绝对路径export ABI=arm64-v8a                           # ABI配置(arm64-v8a 即为 AArch64)export MINSDKVERSION=24                        # 最小目标SDK版本配置(24 即为 Android 7.0)cmake \\   -DCMAKE_TOOLCHAIN_FILE=$NDK/build/cmake/android.toolchain.cmake \\   -DANDROID_ABI=$ABI \\   -DANDROID_NATIVE_API_LEVEL=$MINSDKVERSION \\   -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./installed ..cmake --build . --config Release\n编译产物生成于 out 文件夹中\n\n\nAutoconf Makefile 交叉编译 (以 Make-4.3 为例)\n下载 make-4.3.tar.gz 并解压\n\n交叉编译\ncd make-4.3export NDK=/home/xayah/Compile/NDK                              # NDK根目录绝对路径export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64     # 交叉编译链路径export TARGET=aarch64-linux-android                             # 交叉编译目标export API=24                                                   # 最小目标SDK版本配置(24 即为 Android 7.0)export AR=$TOOLCHAIN/bin/llvm-arexport CC=$TOOLCHAIN/bin/$TARGET$API-clangexport AS=$CCexport CXX=$TOOLCHAIN/bin/$TARGET$API-clang++export LD=$TOOLCHAIN/bin/ldexport RANLIB=$TOOLCHAIN/bin/llvm-ranlibexport STRIP=$TOOLCHAIN/bin/llvm-strip./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib --host $TARGETmake\n\n注：其中的 AR 、 CC 、 AS 、 CXX 、 LD 、 RANLIB 、 STRIP 等决定于Makefile，我这里图方便就直接复制了 NDK文档 中的变量，恰好已经覆盖完全，不会报错。当交叉编译报错时，请自行添加相应变量。\n\n编译产物生成于当前文件夹中\n\n\n非 Autoconf Makefile 交叉编译 (以 Dtc 为例)\n克隆 dtc\ngit clone https://github.com/dgibson/dtc\n交叉编译\ncd dtcexport NDK=/home/xayah/Compile/NDK                              # NDK根目录绝对路径export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64     # 交叉编译链路径export TARGET=aarch64-linux-android                             # 交叉编译目标export API=24                                                   # 最小目标SDK版本配置(24 即为 Android 7.0)export AR=$TOOLCHAIN/bin/llvm-arexport CC=$TOOLCHAIN/bin/$TARGET$API-clangexport AS=$CCexport CXX=$TOOLCHAIN/bin/$TARGET$API-clang++export LD=$TOOLCHAIN/bin/ldexport RANLIB=$TOOLCHAIN/bin/llvm-ranlibexport STRIP=$TOOLCHAIN/bin/llvm-stripmake \\   AR=$AR \\   CC=$CC \\   AS=$AS \\   CXX=$CXX \\   LD=$LD \\   RANLIB=$RANLIB \\   STRIP=$STRIP \\   dtc\n\n注：其中的 AR 、 CC 、 AS 、 CXX 、 LD 、 RANLIB 、 STRIP 等决定于Makefile，我这里图方便就直接复制了 NDK文档 中的变量，恰好已经覆盖完全，不会报错。当交叉编译报错时，请自行添加相应变量。\n\n编译产物生成于当前文件夹中\n\n\nPython 交叉编译 (以 Imgextractor.py 为例)\n利用 Soong 编译系统 将 Python 交叉编译为目标平台二进制ELF文件\n以 LineageOS源码 中的 Soong 编译系统 为例\n需要有一定 Android源码 编译基础\n目标平台：AArch64\n\n\n下载 imgextractor.py\n\n处理第三方模块\n注意到 imgextractor.py 中：\nimport ext4\n这是一个自定义模块，位于其同目录下 ext4.py\n我查阅了 Soong 编译系统文档，暂时没有发现编译时处理第三方模块的解决方案，若同时交叉编译imgextractor.py、ext4.py并放置在同一目录下，仍会报错找不到模块 ext4\n因此，我们将 ext4.py 合并到 imgextractor.py 中：\n\n复制 ext4.py 中所有代码到 imgextractor.py 的文件首\n\n移除 ext4：\n将\nimport ext4, string, struct\n改为\nimport string, struct\n处理类：\n搜索所有 ext4. 并删除：\n即将\nroot = ext4.Volume(file).root\n改为\nroot = Volume(file).root\n保存\n\n\n\n编写 Android.bp\n// Copyright (C) 2017 The Android Open Source Project//// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);// you may not use this file except in compliance with the License.// You may obtain a copy of the License at////      http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.//##################################################python_test &#123;   name: &quot;imgextractor&quot;,   main: &quot;imgextractor.py&quot;,   srcs: [      &quot;imgextractor.py&quot;,   ],   version: &#123;      py3: &#123;            embedded_launcher: true,            enabled: true,      &#125;,   &#125;,&#125;\n注：如果 待编译Python脚本 是 Python2 版本，则：\n// Copyright (C) 2017 The Android Open Source Project//// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);// you may not use this file except in compliance with the License.// You may obtain a copy of the License at////      http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.//##################################################python_test &#123;   name: &quot;xxx&quot;,   main: &quot;xxx.py&quot;,   srcs: [      &quot;xxx.py&quot;,   ],   version: &#123;      py2: &#123;            embedded_launcher: true,            enabled: true,      &#125;,   &#125;,&#125;\n将 imgextractor.py 、Android.bp 放置在LineageOS源码任意位置(需包含在文件夹中)：\n以 /home/xayah/LineageOS/system/imgextractor 为例\n假设你现在位于LineageOS源码根目录，打开终端：\n. build/envsetup.shlunch lineage_cas-userdebugmmma system/imgextractor\n\n注意： cas(Mi 10 Ultra) 可使用其他AArch64平台的手机的设备树\n\n编译产物生成于 out/target/product/cas/testcases/imgextractor/arm64/imgextractor\n\n\n","tags":["Cross Compile","Cmake","Python"]},{"title":"Android 6.0+ 动态权限获取(包含对Android 10+Android11+的支持)","url":"/2021/07/08/Android-6-0-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E8%8E%B7%E5%8F%96-%E5%8C%85%E5%90%AB%E5%AF%B9Android-10-Android11-%E7%9A%84%E6%94%AF%E6%8C%81/","content":"原CSDN博客地址从 Android6.0 开始，权限获取不再是简单地在 AndroidManifest.xml 添加几行代码了， Google 引入了 动态权限 的概念，需要在代码中添加。\n添加步骤（以读取和写入权限为例）：\nAndroidManifest.xml 中添加权限\n &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;\n从 Android10 开始，还需要添加：\n &lt;application    android:requestLegacyExternalStorage=&quot;true&quot;    ...&lt;/application&gt;\n在 Activity 相应位置调用：\n if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == -1) &#123;        // 没有Write权限，动态获取        ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;                Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);        Log.d(&quot;TAG&quot;, &quot;onCreate: 申请获得Write权限！&quot;);    &#125; else &#123;        Log.d(&quot;TAG&quot;, &quot;onCreate: 已获得Write权限！&quot;);    &#125;&#125;\n 然而在 Android11 开始，** WRITE_EXTERNAL_STORAGE** 等特殊权限的获取又发生了变化…\n \n\n 当仍沿用 Android10- 的权限获取方式时，会在调用权限时 抛出异常 \n 因为在 Andorid11+ 中， Google 添加了一个新的权限： MANAGE_EXTERNAL_STORAGE\n 当 APP 动态请求权限时，会引导用户进入一个 权限设置界面\n \n\n 所以，在Android11+中：\n AndroidManifest.xml中添加权限：\n &lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; /&gt;\n\n \n\n 该权限仅支持 Android11+ \n\n在Activity相应位置调用：\n if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;    // new一个intent转到系统设置界面    Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);    intent.setData(Uri.parse(&quot;package:&quot; + mContext.getPackageName()));    // 1024为REQUEST_CODE    startActivityForResult(intent, 1024);&#125;\n所以合并起来的代码是：\n public void getWriteRight() &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;        // new一个intent转到系统设置界面        Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);        intent.setData(Uri.parse(&quot;package:&quot; + mContext.getPackageName()));        // 1024为REQUEST_CODE        startActivityForResult(intent, 1024);    &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == -1) &#123;            // 没有Write权限，动态获取            ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;                    Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);            Log.d(&quot;TAG&quot;, &quot;onCreate: 申请获得Write权限！&quot;);        &#125; else &#123;            Log.d(&quot;TAG&quot;, &quot;onCreate: 已获得Write权限！&quot;);        &#125;    &#125;&#125;\n\n","tags":["Android","权限"]},{"title":"Eclipse/Idea(Android Studio) 最舒服的字体配置","url":"/2021/07/08/Eclipse-Idea-Android-Studio-%E6%9C%80%E8%88%92%E6%9C%8D%E7%9A%84%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE/","content":"原CSDN博客地址\n2021-7-8 更新： 新版Jetbrains系列IDE已不需要再将字体复制到其安装目录中~\n\n前言:舒服的字体是快乐编程的首要条件~\n我推荐的是 Mac OS 的 Monaco 字体~\n\n\n这个字体是我从官方 Mac OS 提取出来然后转换成 TTF 格式的。\n以下是 Jetbrains系列IDE 的配置教程（以Clion为例）：\n步骤:\n下载好 Monaco 字体。\n\n双击打开字体，然后点击安装。\n\n打开 Clion ,依次点击 左上角 File -  Settings - Editor - Font\n如图配置即可\n\n\n","tags":["IDE","Jetbrains","美化"]},{"title":"BlogOS：ARM v8之旅","url":"/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/","content":"前言BlogOS是Philipp Oppermann用Rust语言编写的面向x86架构的简单操作系统。\n《ARM v8之旅》将作为 湖南大学2022年操作系统课程实验 个人参考笔记。更详细的解析请参考 rust写个操作系统：课程实验blogos移至armV8深度解析 。\n参考文章\nlibncursesw.so.5 is installed but a program that needs it says “No such file or directory”\nlibpython2.7.so.1.0: cannot open shared object file: No such file or directory\n\n一、环境配置\n参考代码：下载\n\n本文以Windows Subsystem for Linux 2为环境，可参考 Windows Subsystem for Linux 2 的艺术 搭建。\n1. 安装Rust输入以下命令\ncurl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n若网络正常，则会出现以下输出，键入1，执行默认安装。\n\n安装完成后，激活Rust环境\nsource $HOME/.cargo/env\n查看版本\nrustc -V\n\n根据文档，实验需要用到Nightly版本\nrustup default nightly\n\n安装GCC\nsudo apt-get install gcc\n\n安装相关工具\ncargo install cargo-binutils rustfilt\n\n若安装GCC后仍无法正常cargo install cargo-binutils rustfilt，请尝试将软件源更换为阿里源（参见 Windows Subsystem for Linux 2 的艺术 ），再重新安装一次GCC。\n\n2. 添加ARM v8支持键入以下命令\nrustup target add aarch64-unknown-none-softfloat\n\n3. 安装QEMU模拟器键入以下命令\nsudo apt-get install qemu qemu-system-arm\n\n4. 下载交叉编译工具链 (AArch64)安装必要环境\nsudo apt-get install libncursesw5 libpython2.7 axel\n创建交叉编译工具链目录\nmkdir ToolChain &amp;&amp; cd ToolChain\n使用axel多线程下载工具链 AArch64 ELF bare-metal target (aarch64-none-elf)\naxel -n 32 -a https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf.tar.xz\n解压\ntar -xf gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf.tar.xz\n\n5. 创建裸机(Bare Metal)程序\n由于我们的目标是编写一个操作系统，所以我们需要创建一个独立于操作系统的可执行程序，又称独立式可执行程序（Freestanding Executable）或裸机程序（Bare-metal Executable）。\n这意味着所有依赖于操作系统的库我们都不能使用。比如std中的大部分内容（io, thread, file system, etc…）都需要操作系统的支持，所以这部分内容我们不能使用。\n但是，不依赖于操作系统的Rust的语言特性我们还是可以继续使用的，比如：迭代器、模式匹配、字符串格式化、所有权系统等。这使得Rust依旧可以作为一个功能强大的高级语言，帮助我们编写操作系统。\n\n新建项目回到Home目录\ncd ~\n新建名为rui_armv8_os的项目\ncargo new rui_armv8_os --bin --edition 2021\n进入rui_armv8_os目录\ncd rui_armv8_os\n创建实验所需文件\ntouch src/panic.rs src/panic.rs src/start.s aarch64-qemu.ld aarch64-unknown-none-softfloat.json\n创建.cargo文件夹\nmkdir .cargo\n创建.cargo/config.toml\ntouch .cargo/config.toml\n使用VSCode打开\ncode .\nVSCode安装Rust、Rust-Analyzer插件\n\n\n\n编辑src/main.rs\n#![no_std] // 不使用标准库#![no_main] // 不使用预定义入口点use core::&#123;arch::global_asm, ptr&#125;; // 导入需要的Modulemod panic;global_asm!(include_str!(&quot;start.s&quot;));#[no_mangle] // 不修改函数名pub extern &quot;C&quot; fn not_main() &#123;    const UART0: *mut u8 = 0x0900_0000 as *mut u8;    let out_str = b&quot;AArch64 Bare Metal&quot;;    for byte in out_str &#123;        unsafe &#123;            ptr::write_volatile(UART0, *byte);        &#125;    &#125;&#125;\n编辑src/panic.rs\nuse core::panic::PanicInfo;#[panic_handler]fn on_panic(_info: &amp;PanicInfo) -&gt; ! &#123;    loop &#123;&#125;&#125;\n编辑src/start.s\n.globl _start.extern LD_STACK_PTR.section &quot;.text.boot&quot;_start:        ldr     x30, =LD_STACK_PTR        mov     sp, x30        bl      not_main.equ PSCI_SYSTEM_OFF, 0x84000002.globl system_offsystem_off:        ldr     x0, =PSCI_SYSTEM_OFF        hvc     #0\n编辑aarch64-qemu.ld\nENTRY(_start)SECTIONS&#123;    . = 0x40080000;    .text.boot : &#123; *(.text.boot) &#125;    .text : &#123; *(.text) &#125;    .data : &#123; *(.data) &#125;    .rodata : &#123; *(.rodata) &#125;    .bss : &#123; *(.bss) &#125;    . = ALIGN(8);    . = . + 0x4000;    LD_STACK_PTR = .;&#125;\n编辑aarch64-unknown-none-softfloat.json\n&#123;    &quot;abi-blacklist&quot;: [      &quot;stdcall&quot;,      &quot;fastcall&quot;,      &quot;vectorcall&quot;,      &quot;thiscall&quot;,      &quot;win64&quot;,      &quot;sysv64&quot;    ],    &quot;arch&quot;: &quot;aarch64&quot;,    &quot;data-layout&quot;: &quot;e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128&quot;,    &quot;disable-redzone&quot;: true,    &quot;env&quot;: &quot;&quot;,    &quot;executables&quot;: true,    &quot;features&quot;: &quot;+strict-align,+neon,+fp-armv8&quot;,    &quot;is-builtin&quot;: false,    &quot;linker&quot;: &quot;rust-lld&quot;,    &quot;linker-flavor&quot;: &quot;ld.lld&quot;,    &quot;linker-is-gnu&quot;: true,    &quot;pre-link-args&quot;: &#123;      &quot;ld.lld&quot;: [&quot;-Taarch64-qemu.ld&quot;]    &#125;,    &quot;llvm-target&quot;: &quot;aarch64-unknown-none&quot;,    &quot;max-atomic-width&quot;: 128,    &quot;os&quot;: &quot;none&quot;,    &quot;panic-strategy&quot;: &quot;abort&quot;,    &quot;relocation-model&quot;: &quot;static&quot;,    &quot;target-c-int-width&quot;: &quot;32&quot;,    &quot;target-endian&quot;: &quot;little&quot;,    &quot;target-pointer-width&quot;: &quot;64&quot;,    &quot;vendor&quot;: &quot;&quot;&#125;\n编辑.cargo/config.toml\n[unstable]build-std = [&quot;core&quot;, &quot;compiler_builtins&quot;] [build]target = &quot;aarch64-unknown-none-softfloat.json&quot;\n编辑Cargo.toml\n[package]name = &quot;rui_armv8_os&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;authors = [&quot;Rui Li &lt;rui@hnu.edu.cn&gt;&quot;]# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]# eh_personality语言项标记的函数，将被用于实现栈展开（stack unwinding）。# 在使用标准库的情况下，当panic发生时，Rust将使用栈展开，来运行在栈上活跃的# 所有变量的析构函数（destructor）——这确保了所有使用的内存都被释放。# 如果不禁用会出现错误：language item required, but not found: `eh_personality`# 通过下面的配置禁用栈展开# dev时禁用panic时栈展开[profile.dev]panic = &quot;abort&quot;# release时禁用panic时栈展开[profile.release]panic = &quot;abort&quot;\n\n编译与运行在项目根目录下执行\ncargo build\n\n运行\nqemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n\n\n调试\nQEMU进入调试，启动调试服务器，默认端口1234\n\n关闭之前运行的终端，打开一个新的终端，进入rui_armv8_os目录\ncd rui_armv8_os\n启动调试\nqemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -S -s\n\n\n重新打开一个终端，进入工具链bin目录\ncd ~/ToolChain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin\n导出工具链路径临时变量\nexport ToolChainPath=`pwd`\n进入rui_armv8_os目录\ncd ~/rui_armv8_os\n配置临时工具链环境（这里的$ToolChainPath即是刚刚导出的临时变量）\nexport PATH=$ToolChainPath:$PATH\n启用GDB调试客户端\naarch64-none-elf-gdb target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n设置调试参数，开始调试\n\n连接调试客户端\ntarget remote localhost:1234\n查看汇编码\ndisassemble\n单步运行\nn\n\n\n二、Hello World\n参考代码：下载\n\n\nprint函数是学习几乎任何一种软件开发语言时最先学习使用的函数，同时该函数也是最基本和原始的程序调试手段，但该函数的实现却并不简单。本实验的目的在于理解操作系统与硬件的接口方法，并实现一个可打印字符的宏（非系统调用），用于后续的调试和开发。\n\n1. 了解virt机器\n操作系统介于硬件和应用程序之间，向下管理硬件资源，向上提供应用编程接口。设计并实现操作系统需要熟悉底层硬件的组成及其操作方法。\n本系列实验都会在QEMU模拟器上完成，首先来了解一下模拟的机器信息。可以通过下列两种方法：\n\n1) 文档或源码方式\n查看QEMU关于virt的描述， 或者查看QEMU的源码，如GitHub上的virt.h和virt.c。virt.c中可见如下有关内存映射的内容。\n\n/* Addresses and sizes of our components. * 0..128MB is space for a flash device so we can run bootrom code such as UEFI. * 128MB..256MB is used for miscellaneous device I/O. * 256MB..1GB is reserved for possible future PCI support (ie where the * PCI memory window will go if we add a PCI host controller). * 1GB and up is RAM (which may happily spill over into the * high memory region beyond 4GB). * This represents a compromise between how much RAM can be given to * a 32 bit VM and leaving space for expansion and in particular for PCI. * Note that devices should generally be placed at multiples of 0x10000, * to accommodate guests using 64K pages. */static const MemMapEntry base_memmap[] = &#123;    /* Space up to 0x8000000 is reserved for a boot ROM */    [VIRT_FLASH] =              &#123;          0, 0x08000000 &#125;,    [VIRT_CPUPERIPHS] =         &#123; 0x08000000, 0x00020000 &#125;,    /* GIC distributor and CPU interfaces sit inside the CPU peripheral space */    [VIRT_GIC_DIST] =           &#123; 0x08000000, 0x00010000 &#125;,    [VIRT_GIC_CPU] =            &#123; 0x08010000, 0x00010000 &#125;,    [VIRT_GIC_V2M] =            &#123; 0x08020000, 0x00001000 &#125;,    [VIRT_GIC_HYP] =            &#123; 0x08030000, 0x00010000 &#125;,    [VIRT_GIC_VCPU] =           &#123; 0x08040000, 0x00010000 &#125;,    /* The space in between here is reserved for GICv3 CPU/vCPU/HYP */    [VIRT_GIC_ITS] =            &#123; 0x08080000, 0x00020000 &#125;,    /* This redistributor space allows up to 2*64kB*123 CPUs */    [VIRT_GIC_REDIST] =         &#123; 0x080A0000, 0x00F60000 &#125;,    [VIRT_UART] =               &#123; 0x09000000, 0x00001000 &#125;,    [VIRT_RTC] =                &#123; 0x09010000, 0x00001000 &#125;,    [VIRT_FW_CFG] =             &#123; 0x09020000, 0x00000018 &#125;,    [VIRT_GPIO] =               &#123; 0x09030000, 0x00001000 &#125;,    [VIRT_SECURE_UART] =        &#123; 0x09040000, 0x00001000 &#125;,    [VIRT_SMMU] =               &#123; 0x09050000, 0x00020000 &#125;,    [VIRT_PCDIMM_ACPI] =        &#123; 0x09070000, MEMORY_HOTPLUG_IO_LEN &#125;,    [VIRT_ACPI_GED] =           &#123; 0x09080000, ACPI_GED_EVT_SEL_LEN &#125;,    [VIRT_NVDIMM_ACPI] =        &#123; 0x09090000, NVDIMM_ACPI_IO_LEN&#125;,    [VIRT_PVTIME] =             &#123; 0x090a0000, 0x00010000 &#125;,    [VIRT_SECURE_GPIO] =        &#123; 0x090b0000, 0x00001000 &#125;,    [VIRT_MMIO] =               &#123; 0x0a000000, 0x00000200 &#125;,    /* ...repeating for a total of NUM_VIRTIO_TRANSPORTS, each of that size */    [VIRT_PLATFORM_BUS] =       &#123; 0x0c000000, 0x02000000 &#125;,    [VIRT_SECURE_MEM] =         &#123; 0x0e000000, 0x01000000 &#125;,    [VIRT_PCIE_MMIO] =          &#123; 0x10000000, 0x2eff0000 &#125;,    [VIRT_PCIE_PIO] =           &#123; 0x3eff0000, 0x00010000 &#125;,    [VIRT_PCIE_ECAM] =          &#123; 0x3f000000, 0x01000000 &#125;,    /* Actual RAM size depends on initial RAM and device memory settings */    [VIRT_MEM] =                &#123; GiB, LEGACY_RAMLIMIT_BYTES &#125;,&#125;;\n\n2) 设备树（Device Tree）方式首先安装DTC\nsudo apt-get install device-tree-compiler\n新建一个设备树目录并进入\nmkdir ~/device &amp;&amp; cd ~/device\n导出DT\nqemu-system-aarch64 -machine virt,dumpdtb=virt.dtb -cpu cortex-a53 -nographic\n\n-machine virt指明机器类型为virt，这是QEMU仿真的虚拟机器。\n\n用DTC将导出的Device Tree Blob转换为Device Tree Source\ndtc -I dtb -O dts -o virt.dts virt.dtb\n用文本编辑器打开virt.dts，可以发现如下内容\npl011@9000000 &#123;\tclock-names = &quot;uartclk\\0apb_pclk&quot;;\tclocks = &lt;0x8000 0x8000&gt;;\tinterrupts = &lt;0x00 0x01 0x04&gt;;\treg = &lt;0x00 0x9000000 0x00 0x1000&gt;;\tcompatible = &quot;arm,pl011\\0arm,primecell&quot;;&#125;;/* ······ */chosen &#123;\tstdout-path = &quot;/pl011@9000000&quot;;&#125;;\n\n由上可以看出，virt机器包含有pl011的设备，该设备的寄存器在0x9000000开始处。pl011实际上是一个UART设备，即串口。可以看到virt选择使用pl011作为标准输出，这是因为与PC不同，大部分嵌入式系统默认情况下并不包含VGA设备。\n\n2. 实现println!宏\n我们参照Writing an OS in Rust - VGA Text Mode （使用Rust编写操作系统（三）：VGA字符模式）来实现println!宏，但与之不同的是，我们使用串口来输出，而不是通过操作VGA的Frame Buffer。\n\n1) 用串口实现println!宏进入rui_armv8_os目录\ncd ~/rui_armv8_os\n新建src/uart_console.rs\ntouch src/uart_console.rs\n编辑src/uart_console.rs，定义一个Writer结构，实现字节写入和字符串写入。\n//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构pub struct Writer;//往串口寄存器写入字节和字符串进行输出impl Writer &#123;    pub fn write_byte(&amp;mut self, byte: u8) &#123;        const UART0: *mut u8 = 0x0900_0000 as *mut u8;        unsafe &#123;            ptr::write_volatile(UART0, byte);        &#125;    &#125;    pub fn write_string(&amp;mut self, s: &amp;str) &#123;        for byte in s.chars() &#123;            self.write_byte(byte as u8)        &#125;    &#125;&#125;\n\n如何操作硬件通常需要阅读硬件制造商提供的技术手册。如pl011串口设备（PrimeCell UART）是arm设计的，其技术参考手册可以通过其官网查看。\n依据之前virt.dts中的描述，pl011的寄存器在virt机器中被映射到了0x9000000的内存位置。通过访问pl011的技术参考手册中Chapter 3. Programmers Model中的Summary of registers一节可知：第0号寄存器是pl011串口的数据寄存器，用于数据的收发。其详细描述参见 这里。\n注意到我们只是向UART0写入，而没从UART0读出（如果读出会读出其他设备通过串口发送过来的数据，而不是刚才写入的数据，这与读写内存时是不一样的，详情参见pl011的技术手册），编译器在优化时可能对这部分代码进行错误的优化，如把这些操作都忽略掉。\n使用ptr::write_volatile库的目的是告诉编译器，这些写入有特定目的，不应将其优化（也就是告诉编译器不要瞎优化，这些写入和读出都有特定用途。\n比如连续两次读，编译器可能认为第二次读就是前次的值，所以优化掉第二次读，但对外设寄存器的连续读可能返回不同的值。\n比如写，编译器可能认为写后没有读所以写没有作用，或者连续的写会覆盖前面的写，但对这些寄存器的写入对外设都有特定作用）。\n\n在src/uart_console.rs中为Write结构实现core::fmt::Writetrait，该trait会自动实现write_fmt方法，支持格式化。\n//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构pub struct Writer;//往串口寄存器写入字节和字符串进行输出impl Writer &#123;    // ······&#125;impl core::fmt::Write for Writer &#123;    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result &#123;        self.write_string(s);        Ok(())    &#125;&#125;\n\n基于Rust的core::fmt实现格式化控制，可以使我们方便地打印不同类型的变量。实现core::fmt::Write后，我们就可以使用Rust内置的格式化宏write!和writeln!，这使你瞬间具有其他语言运行时所提供的格式化控制能力。\n\n2) 测试在main.rs末尾加入以下代码\n#![no_std] // 不使用标准库#![no_main] // 不使用预定义入口点// ······#[no_mangle] // 不修改函数名pub extern &quot;C&quot; fn not_main() &#123;    // ······&#125;include!(&quot;uart_console.rs&quot;);use core::fmt;pub fn print_something() &#123;    // 一定要引用core::fmt::Write;否则报错：no method named `write_fmt` found for struct `Writer` in the current scope。    pub use core::fmt::Write;    let mut writer = Writer &#123;&#125;;    let display: fmt::Arguments = format_args!(&quot;hello arguments!\\n&quot;);    writer.write_string(&quot;\\n-----My writer-----\\n&quot;);    writer.write_byte(b&#x27;H&#x27;);    writer.write_string(&quot;ello &quot;);    writer.write_string(&quot;World!\\n&quot;);    writer.write_string(&quot;[0] Hello from Rust!\\n&quot;);    // 通过实现core::fmt::Write自动实现的方法    writer.write_fmt(display).unwrap();    // 使用write!宏    write!(writer, &quot;The numbers are &#123;&#125; and &#123;&#125; \\n&quot;, &quot;42&quot;, &quot;1.0&quot;).unwrap();    writer.write_string(&quot;-----My writer-----&quot;);&#125;\n编辑main.rs中not_main函数：\npub extern &quot;C&quot; fn not_main() &#123;    // ······    print_something(); // 调用测试函数&#125;\n编译并运行\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n\n\n按住CTRL + A，然后松手按C，输入quit即可退出QEMU模拟器。\n3) 全局实现\n现在我们已经可以采用print_something函数通过串口输出字符了。但若要实现输出，我们需要两个步骤：（1）创建Writer类型的实例。（2）调用实例的write_byte或write_string等函数。\n为了方便在其他模块中调用，我们希望可以直接执行步骤（2）而不是先执行步骤（1）再执行步骤（2）。\n一般情况下可以通过将步骤（1）中的实例定义为static类型来实现，但Rust暂不支持Writer这样类型的静态（编译时）初始化，需要使用lazy_static来解决。此外，为了保证访问安全还引入了自旋锁（spin）。\n\n编辑Cargo.toml：\n# ······# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]spin = &quot;0.9.2&quot;[dependencies.lazy_static]version = &quot;1.0&quot;features = [&quot;spin_no_std&quot;]# eh_personality语言项标记的函数，将被用于实现栈展开（stack unwinding）。# ······\n编辑src/uart_console.rs，实现print!和println!宏。\nimpl core::fmt::Write for Writer &#123;    // ······&#125;use core::&#123;fmt, ptr&#125;;use lazy_static::lazy_static;use spin::Mutex;lazy_static! &#123;    /// A global `Writer` instance that can be used for printing to the VGA text buffer.    ///    /// Used by the `print!` and `println!` macros.    pub static ref WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer &#123; &#125;);&#125;/// Like the `print!` macro in the standard library, but prints to the VGA text buffer.#[macro_export]macro_rules! print &#123;    ($($arg:tt)*) =&gt; ($crate::uart_console::_print(format_args!($($arg)*)));&#125;/// Like the `println!` macro in the standard library, but prints to the VGA text buffer.#[macro_export]macro_rules! println &#123;    () =&gt; ($crate::print!(&quot;\\n&quot;));    ($($arg:tt)*) =&gt; ($crate::print!(&quot;&#123;&#125;\\n&quot;, format_args!($($arg)*)));&#125;/// Prints the given formatted string to the VGA text buffer through the global `WRITER` instance.#[doc(hidden)]pub fn _print(args: fmt::Arguments) &#123;    use core::fmt::Write;    WRITER.lock().write_fmt(args).unwrap();&#125;\n在main.rs中注释或删除之前的print_something()函数及其调用，测试println!宏\n// ······mod uart_console;// ······pub extern &quot;C&quot; fn not_main() &#123;    // ······    println!(&quot;\\n[0] Hello from Rust!&quot;);&#125;\n编译并运行\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n\n\n三、设备树（可选）\n参考湖南大学2022年操作系统课程实验 - 实验三 设备树（可选）\n\n四、中断\n参考代码：下载\n中断、异常和陷阱指令是操作系统的基石，现代操作系统就是由中断驱动的。本实验的目的在于深刻理解中断的原理和机制，掌握CPU访问设备控制器的方法，掌握ARM体系结构的中断机制和规范，实现时钟中断服务和部分异常处理等。\n\n1. 概念1) 陷入操作系统\n如下图所示，操作系统是一个多入口的程序，执行陷阱（Trap）指令，出现异常、发生中断时都会陷入到操作系统。\n\n\n2) ARM的中断系统\n中断是一种硬件机制。借助于中断，CPU可以不必再采用轮询这种低效的方式访问外部设备。将所有的外部设备与CPU直接相连是不现实的，外部设备的中断请求一般经由中断控制器，由中断控制器仲裁后再转发给CPU。如下图所示ARM的中断系统。\n\n\n其中nIRQ是普通中断，nFIQ是快速中断。ARM采用的中断控制器叫做GIC，即General Interrupt Controller。GIC包括多个版本，如GICv1（已弃用），GICv2，GICv3，GICv4。简单起见，我们实验将选用GICv2版本。\n为了配置好GICv2中断控制器，与pl011串口一样，我们需要阅读其技术参考手册。\n访问ARM官网下载ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification。\n\n\n从上图（来源于ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification中的Chapter 2 GIC Partitioning）可以看出：\n\nGICv2最多支持8核的中断管理。\nGIC包括两大主要部分（由图中蓝色虚竖线分隔，Distributor和CPU Interface由蓝色虚矩形框标示），分别是：\nDistributor，其通过GICD_开头的寄存器进行控制（蓝色实矩形框标示）\nCPU Interface，其通过GICC_开头的寄存器进行控制（蓝色实矩形框标示）\n\n\n中断类型分为以下几类（由图中红色虚线椭圆标示）：\nSPI：（Shared Peripheral Interrupt），共享外设中断。该中断来源于外设，通过Distributor分发给特定的Core，其中断编号为32-1019。从图中可以看到所有核共享SPI。\nPPI：（Private Peripheral Interrupt），私有外设中断。该中断来源于外设，但只对指定的Core有效，中断信号只会发送给指定的Core，其中断编号为16-31。从图中可以看到每个Core都有自己的PPI。\nSGI：（Software-Generated Interrupt），软中断。软件产生的中断，用于给其他的Core发送中断信号，其中断编号为0-15。\nVirtual Interrupt，虚拟中断，用于支持虚拟机。图中也可以看到，因为我们暂时不关心，所以没有标注。\n此外可以看到（FIQ，IRQ）可通过b进行旁路，我们也不关心。如感兴趣可以查看技术手册了解细节。\n\n\n\n此外，由ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification(Section 1.4.2)可知，外设中断可由两种方式触发：\n\nEdge-Triggered：边沿触发，当检测到中断信号上升沿时中断有效。\nLevel-Sensitive：电平触发，当中断源为指定电平时中断有效。因为SOC中中断有很多，为了方便对中断的管理，对每个中断附加了中断优先级。在中断仲裁时，高优先级的中断，会优于低优先级的中断，发送给CPU处理。当CPU在响应低优先级中断时，如果此时来了高优先级中断，那么高优先级中断会抢占低优先级中断，而被处理器响应。由ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification(Section 3.3)可知，GICv2最多支持256个中断优先级。GICv2中规定，所支持的中断优先级别数与GIC的具体实现有关，如果支持的中断优先级数比256少（最少为16），则8位优先级的低位为0，且遵循RAZ/WI（Read-As-Zero, Writes Ignored）原则。\n\n\n3) GICv2初始化/* ······ */intc@8000000 &#123;    phandle = &lt;0x8001&gt;;    reg = &lt;0x00 0x8000000 0x00 0x10000 0x00 0x8010000 0x00 0x10000&gt;;    compatible = &quot;arm,cortex-a15-gic&quot;;    ranges;    #size-cells = &lt;0x02&gt;;    #address-cells = &lt;0x02&gt;;    interrupt-controller;    #interrupt-cells = &lt;0x03&gt;;    v2m@8020000 &#123;        phandle = &lt;0x8002&gt;;        reg = &lt;0x00 0x8020000 0x00 0x1000&gt;;        msi-controller;        compatible = &quot;arm,gic-v2m-frame&quot;;    &#125;;&#125;;/* ······ */timer &#123;    interrupts = &lt;0x01 0x0d 0x104 0x01 0x0e 0x104 0x01 0x0b 0x104 0x01 0x0a 0x104&gt;;    always-on;    compatible = &quot;arm,armv8-timer\\0arm,armv7-timer&quot;;&#125;;\n\n由virt.dts中intc和timer的部分并结合kernel.org中关于ARM Generic Interrupt Controller和ARM architected timer的DeviceTree的说明可知：\n\nintc中的reg指明GICD寄存器映射到内存的位置为0x8000000，长度为0x10000，GICC寄存器映射到内存的位置为0x8010000，长度为0x10000。\nintc中的#interrupt-cells指明interrupts包括3个cells。第一个文档指明：第一个cell为中断类型，0表示SPI，1表示PPI；第二个cell为中断号，SPI范围为**[0-987]，PPI为[0-15]；第三个cell为flags，其中[3:0]位表示触发类型，[4]表示高电平触发，[15:8]为PPI的CPU中断掩码，每1位对应一个CPU，为1表示该中断会连接到对应的CPU**。\n以timer设备为例，其中包括4个中断。以第2个中断的参数0x01 0x0e 0x104为例，其指明该中断为PPI类型的中断，中断号14， 路由到第一个CPU，且高电平触发。但注意到PPI的起始中断号为16，所以实际上该中断在GICv2中的中断号应为16 + 14 = 30。阅读ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification，在Chapter 4 Programmers’ Model部分有关于GICD和GICC寄存器的描述，以及如何使能Distributor和CPU Interfaces**的方法。\n\n\n4) ARMv8的中断与异常处理\n访问ARM官网下载并阅读ARM Cortex-A Series Programmer’s Guide for ARMv8-A和AArch64 Exception and Interrupt Handling等技术参考手册。ARMv8架构定义了两种执行状态(Execution States)：AArch64和AArch32。分别对应使用64位宽通用寄存器或32位宽通用寄存器的执行。\n\n上图所示为AArch64中的异常级别(Exception levels)的组织。可见AArch64中共有4个异常级别，分别为EL0，EL1，EL2和EL3。在AArch64中，Interrupt是Exception的子类型，称为异常。AArch64中有四种类型的异常：\n\nSync（Synchronous exceptions，同步异常）。在执行时触发的异常，例如在尝试访问不存在的内存地址时。\nIRQ （Interrupt requests，中断请求）。由外部设备产生的中断。\nFIQ （Fast Interrupt Requests，快速中断请求）。类似于IRQ，但具有更高的优先级，因此FIQ中断服务程序不能被其他IRQ或FIQ中断。\nSError （System Error，系统错误）。用于外部数据中止的异步中断。当异常发生时，处理器将执行与该异常对应的异常处理代码。在ARM架构中，这些异常处理代码将会被保存在内存的异常向量表中。每一个异常级别（EL0，EL1，EL2和EL3）都有其对应的异常向量表。需要注意的是，与x86等架构不同，该表包含的是要执行的指令，而不是函数地址。\n\n异常向量表的基地址由VBAR_ELn给出，然后每个表项都有一个从该基地址定义的偏移量。 每个表有16个表项，每个表项的大小为128（0x80）字节（32条指令）。 该表实际上有4组，每组4个表项。 分别是：\n\n发生于当前异常级别的异常且SPSel寄存器选择SP0，Sync、IRQ、FIQ、SError对应的4个异常处理。\n发生于当前异常级别的异常且SPSel寄存器选择SPx，Sync、IRQ、FIQ、SError对应的4个异常处理。\n发生于较低异常级别的异常且执行状态为AArch64，Sync、IRQ、FIQ、SError对应的4个异常处理。\n发生于较低异常级别的异常且执行状态为AArch32，Sync、IRQ、FIQ、SError对应的4个异常处理。\n\n\n2. 实现1) 编写代码新建src/interrupts.rs，src/exceptions.s\ntouch src/interrupts.rs src/exceptions.s\n编辑src/interrupts.rs，定义各种常量，如寄存器地址和寄存器值等，然后定义init_gicv2函数对GICD和GICC进行初始化，最后定义若干辅助函数用于中断配置。\nuse core::ptr;// GICD和GICC寄存器内存映射后的起始地址const GICD_BASE: u64 = 0x08000000;const GICC_BASE: u64 = 0x08010000;// Distributorconst GICD_CTLR: *mut u32 = (GICD_BASE + 0x0) as *mut u32;const GICD_ISENABLER: *mut u32 = (GICD_BASE + 0x0100) as *mut u32;const GICD_ICENABLER: *mut u32 = (GICD_BASE + 0x0180) as *mut u32;const GICD_ICPENDR: *mut u32 = (GICD_BASE + 0x0280) as *mut u32;const GICD_IPRIORITYR: *mut u32 = (GICD_BASE + 0x0400) as *mut u32;const GICD_ICFGR: *mut u32 = (GICD_BASE + 0x0c00) as *mut u32;const GICD_CTLR_ENABLE: u32 = 1;  /* Enable GICD */const GICD_CTLR_DISABLE: u32 = 0;     /* Disable GICD */const GICD_ISENABLER_SIZE: u32 = 32;const GICD_ICENABLER_SIZE: u32 = 32;const GICD_ICPENDR_SIZE: u32 = 32;const GICD_IPRIORITY_SIZE: u32 = 4;const GICD_IPRIORITY_BITS: u32 = 8;const GICD_ICFGR_SIZE: u32 = 16;const GICD_ICFGR_BITS: u32 = 2;// CPU Interfaceconst GICC_CTLR: *mut u32 = (GICC_BASE + 0x0) as *mut u32;const GICC_PMR: *mut u32 = (GICC_BASE + 0x0004) as *mut u32;const GICC_BPR: *mut u32 = (GICC_BASE + 0x0008) as *mut u32;const GICC_CTLR_ENABLE: u32 = 1;const GICC_CTLR_DISABLE: u32 = 0;// Priority Mask Register. interrupt priority filter, Higher priority corresponds to a lower Priority field value.const GICC_PMR_PRIO_LOW: u32 = 0xff;// The register defines the point at which the priority value fields split into two parts,// the group priority field and the subpriority field. The group priority field is used to// determine interrupt preemption. NO GROUP.const GICC_BPR_NO_GROUP: u32 = 0x00;pub fn init_gicv2() &#123;    // 初始化Gicv2的distributor和cpu interface    // 禁用distributor和cpu interface后进行相应配置    unsafe &#123;        ptr::write_volatile(GICD_CTLR, GICD_CTLR_DISABLE);        ptr::write_volatile(GICC_CTLR, GICC_CTLR_DISABLE);        ptr::write_volatile(GICC_PMR, GICC_PMR_PRIO_LOW);        ptr::write_volatile(GICC_BPR, GICC_BPR_NO_GROUP);    &#125;    // 启用distributor和cpu interface    unsafe &#123;        ptr::write_volatile(GICD_CTLR, GICD_CTLR_ENABLE);        ptr::write_volatile(GICC_CTLR, GICC_CTLR_ENABLE);    &#125;&#125;// 使能中断号为interrupt的中断pub fn enable(interrupt: u32) &#123;    unsafe &#123;        ptr::write_volatile(            GICD_ISENABLER.add((interrupt / GICD_ISENABLER_SIZE) as usize),            1 &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)        );    &#125;&#125;// 禁用中断号为interrupt的中断pub fn disable(interrupt: u32) &#123;    unsafe &#123;        ptr::write_volatile(            GICD_ICENABLER.add((interrupt / GICD_ICENABLER_SIZE) as usize),            1 &lt;&lt; (interrupt % GICD_ICENABLER_SIZE)        );    &#125;&#125;// 清除中断号为interrupt的中断pub fn clear(interrupt: u32) &#123;    unsafe &#123;        ptr::write_volatile(            GICD_ICPENDR.add((interrupt / GICD_ICPENDR_SIZE) as usize),            1 &lt;&lt; (interrupt % GICD_ICPENDR_SIZE)        );    &#125;&#125;// 设置中断号为interrupt的中断的优先级为prioritypub fn set_priority(interrupt: u32, priority: u32) &#123;    let shift = (interrupt % GICD_IPRIORITY_SIZE) * GICD_IPRIORITY_BITS;    unsafe &#123;        let addr: *mut u32 = GICD_IPRIORITYR.add((interrupt / GICD_IPRIORITY_SIZE) as usize);        let mut value: u32 = ptr::read_volatile(addr);        value &amp;= !(0xff &lt;&lt; shift);        value |= priority &lt;&lt; shift;        ptr::write_volatile(addr, value);    &#125;&#125;// 设置中断号为interrupt的中断的属性为configpub fn set_config(interrupt: u32, config: u32) &#123;    let shift = (interrupt % GICD_ICFGR_SIZE) * GICD_ICFGR_BITS;    unsafe &#123;        let addr: *mut u32 = GICD_ICFGR.add((interrupt / GICD_ICFGR_SIZE) as usize);        let mut value: u32 = ptr::read_volatile(addr);        value &amp;= !(0x03 &lt;&lt; shift);        value |= config &lt;&lt; shift;        ptr::write_volatile(addr, value);    &#125;&#125;\n编辑src/exceptions.s，参照AArch64 exception table定义异常向量表。\n// SPDX-License-Identifier: MIT OR Apache-2.0//// Copyright (c) 2018-2021 Andre Richter &lt;andre.o.richter@gmail.com&gt;.extern el1_sp0_sync.extern el1_sp0_irq.extern el1_sp0_fiq.extern el1_sp0_error.extern el1_sync.extern el1_irq.extern el1_fiq.extern el1_error.extern el0_sync.extern el0_irq.extern el0_fiq.extern el0_error.extern el0_32_sync.extern el0_32_irq.extern el0_32_fiq.extern el0_32_error//--------------------------------------------------------------------------------------------------// Definitions//--------------------------------------------------------------------------------------------------/// Call the function provided by parameter `\\handler` after saving the exception context. Provide/// the context as the first parameter to &#x27;\\handler&#x27;..equ CONTEXT_SIZE, 264.section .text.exceptions.macro EXCEPTION_VECTOR handler    sub sp, sp, #CONTEXT_SIZE// store general purpose registers    stp x0, x1, [sp, #16 * 0]    stp x2, x3, [sp, #16 * 1]    stp x4, x5, [sp, #16 * 2]    stp x6, x7, [sp, #16 * 3]    stp x8, x9, [sp, #16 * 4]    stp x10, x11, [sp, #16 * 5]    stp x12, x13, [sp, #16 * 6]    stp x14, x15, [sp, #16 * 7]    stp x16, x17, [sp, #16 * 8]    stp x18, x19, [sp, #16 * 9]    stp x20, x21, [sp, #16 * 10]    stp x22, x23, [sp, #16 * 11]    stp x24, x25, [sp, #16 * 12]    stp x26, x27, [sp, #16 * 13]    stp x28, x29, [sp, #16 * 14]// store exception link register and saved processor state register    mrs x0, elr_el1    mrs x1, spsr_el1    stp x0, x1, [sp, #16 * 15]// store link register which is x30    str x30, [sp, #16 * 16]    mov x0, sp// call exception handler    bl \\handler// exit exception    b .exit_exception.endm//--------------------------------------------------------------------------------------------------// Private Code//--------------------------------------------------------------------------------------------------//------------------------------------------------------------------------------// The exception vector table.//------------------------------------------------------------------------------/** When an exception occurs, the processor must execute handler code that corresponds to the exception.The location in memory where the handler is stored is called the exception vector. In the ARM architecture,exception vectors are stored in a table, called the exception vector table.Each Exception level has its own vector table, that is, there is one for each of EL3, EL2, and EL1. The table containsinstructions to be executed, rather than a set of addresses. These would normally be branch instructions that direct thecore to the full exception handler.The exception vector table for EL1, for example, holds instructions for handling all types of exception that can occur at EL1,Vectors for individual exceptions are at fixed offsets from the beginning of the table. The virtual address of each table baseis set by the Vector Based Address Registers: VBAR_EL3, VBAR_EL2 and VBAR_EL1.Each entry in the vector table is 16 instructions long (in ARMv7-A and AArch32, each entry is only 4 bytes). This means that inAArch64 the top-level handler can be written directly in the vector table.The base address is given by VBAR_ELn and each entry has a defined offset from this base address. Each table has 16 entries,with each entry being 128 bytes (32 instructions) in size. The table effectively consists of 4 sets of 4 entries. Which entryis used depends on several factors:The type of exception (SError, FIQ, IRQ, or Synchronous)If the exception is being taken at the same Exception level, the stack pointer to be used (SP0 or SPn)If the exception is being taken at a lower Exception level, the Execution state of the next lower level (AArch64 or AArch32).*/.section .text.exceptions_vector_table// Export a symbol for the Rust code to use..globl exception_vector_tableexception_vector_table:.org 0x0000    EXCEPTION_VECTOR el1_sp0_sync.org 0x0080    EXCEPTION_VECTOR el1_sp0_irq.org 0x0100    EXCEPTION_VECTOR el1_sp0_fiq.org 0x0180    EXCEPTION_VECTOR el1_sp0_error.org 0x0200    EXCEPTION_VECTOR el1_sync.org 0x0280    EXCEPTION_VECTOR el1_irq.org 0x0300    EXCEPTION_VECTOR el1_fiq.org 0x0380    EXCEPTION_VECTOR el1_error.org 0x0400    EXCEPTION_VECTOR el0_sync.org 0x0480    EXCEPTION_VECTOR el0_irq.org 0x0500    EXCEPTION_VECTOR el0_fiq.org 0x0580    EXCEPTION_VECTOR el0_error.org 0x0600    EXCEPTION_VECTOR el0_32_sync.org 0x0680    EXCEPTION_VECTOR el0_32_irq.org 0x0700    EXCEPTION_VECTOR el0_32_fiq.org 0x0780    EXCEPTION_VECTOR el0_32_error.org 0x0800.exit_exception:// restore link register    ldr x30, [sp, #16 * 16]// restore exception link register and saved processor state register    ldp x0, x1, [sp, #16 * 15]    msr elr_el1, x0    msr spsr_el1, x1// restore general purpose registers    ldp x28, x29, [sp, #16 * 14]    ldp x26, x27, [sp, #16 * 13]    ldp x24, x25, [sp, #16 * 12]    ldp x22, x23, [sp, #16 * 11]    ldp x20, x21, [sp, #16 * 10]    ldp x18, x19, [sp, #16 * 9]    ldp x16, x17, [sp, #16 * 8]    ldp x14, x15, [sp, #16 * 7]    ldp x12, x13, [sp, #16 * 6]    ldp x10, x11, [sp, #16 * 5]    ldp x8, x9, [sp, #16 * 4]    ldp x6, x7, [sp, #16 * 3]    ldp x4, x5, [sp, #16 * 2]    ldp x2, x3, [sp, #16 * 1]    ldp x0, x1, [sp, #16 * 0]// restore stack pointer    add sp, sp, #CONTEXT_SIZE    eret\n\n编辑src/interrupts.rs，文末引入exceptions.s，同时定义结构ExceptionCtx，与src/exceptions.s中EXCEPTION_VECTOR宏保存的寄存器数据对应。\n// ······// 注意：这里的······代表承接并省略上文代码use core::arch::global_asm;global_asm!(include_str!(&quot;exceptions.s&quot;));#[repr(C)]pub struct ExceptionCtx &#123;    regs: [u64; 30],    elr_el1: u64,    spsr_el1: u64,    lr: u64,&#125;\n继续编辑src/interrupts.rs，在EXCEPTION_VECTOR宏中，每一类中断都对应一个处理函数。\n// ······const EL1_SP0_SYNC: &amp;&#x27;static str = &quot;EL1_SP0_SYNC&quot;;const EL1_SP0_IRQ: &amp;&#x27;static str = &quot;EL1_SP0_IRQ&quot;;const EL1_SP0_FIQ: &amp;&#x27;static str = &quot;EL1_SP0_FIQ&quot;;const EL1_SP0_ERROR: &amp;&#x27;static str = &quot;EL1_SP0_ERROR&quot;;const EL1_SYNC: &amp;&#x27;static str = &quot;EL1_SYNC&quot;;const EL1_IRQ: &amp;&#x27;static str = &quot;EL1_IRQ&quot;;const EL1_FIQ: &amp;&#x27;static str = &quot;EL1_FIQ&quot;;const EL1_ERROR: &amp;&#x27;static str = &quot;EL1_ERROR&quot;;const EL0_SYNC: &amp;&#x27;static str = &quot;EL0_SYNC&quot;;const EL0_IRQ: &amp;&#x27;static str = &quot;EL0_IRQ&quot;;const EL0_FIQ: &amp;&#x27;static str = &quot;EL0_FIQ&quot;;const EL0_ERROR: &amp;&#x27;static str = &quot;EL0_ERROR&quot;;const EL0_32_SYNC: &amp;&#x27;static str = &quot;EL0_32_SYNC&quot;;const EL0_32_IRQ: &amp;&#x27;static str = &quot;EL0_32_IRQ&quot;;const EL0_32_FIQ: &amp;&#x27;static str = &quot;EL0_32_FIQ&quot;;const EL0_32_ERROR: &amp;&#x27;static str = &quot;EL0_32_ERROR&quot;;// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息fn catch(ctx: &amp;mut ExceptionCtx, name: &amp;str) &#123;    crate::print!(        &quot;\\n  \\        &#123;&#125; @ 0x&#123;:016x&#125;\\n\\n &quot;,        name,        ctx.elr_el1,    );&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_sp0_sync(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_SP0_SYNC);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_sp0_irq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_SP0_IRQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_sp0_fiq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_SP0_FIQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_sp0_error(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_SP0_ERROR);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_sync(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_SYNC);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_irq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_IRQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_fiq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_FIQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el1_error(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL1_ERROR);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_sync(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_SYNC);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_irq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_IRQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_fiq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_FIQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_error(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_ERROR);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_32_sync(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_32_SYNC);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_32_irq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_32_IRQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_32_fiq(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_32_FIQ);&#125;#[no_mangle]unsafe extern &quot;C&quot; fn el0_32_error(ctx: &amp;mut ExceptionCtx) &#123;    catch(ctx, EL0_32_ERROR);&#125;\n\n编辑src/start.s，载入异常向量表exception_vector_table\n// ······        mov     sp, x30        // Initialize exceptions        ldr     x0, =exception_vector_table        msr     vbar_el1, x0        isb        bl      not_main// ······\n\n\n编辑aarch64-qemu.ld，处理链接脚本，为exceptions.s中定义的exceptions_vector_table选择位置，同时满足4K对齐。\n// ······    .text.boot : &#123; *(.text.boot) &#125;    .text :    &#123;        KEEP(*(.text.boot))        *(.text.exceptions)        . = ALIGN(4096); /* align for exceptions_vector_table*/        *(.text.exceptions_vector_table)        *(.text)    &#125;    .data : &#123; *(.data) &#125;// ······\n\n\n编辑src/main.rs，引入interrupts.rs模块，并在not_main()函数中注释掉之前的输出代码，调用init_gicv2()函数\n// ······mod panic;mod uart_console;mod interrupts;global_asm!(include_str!(&quot;start.s&quot;));// ······#[no_mangle] // 不修改函数名pub extern &quot;C&quot; fn not_main() &#123;    // const UART0: *mut u8 = 0x0900_0000 as *mut u8;    // let out_str = b&quot;AArch64 Bare Metal&quot;;    // for byte in out_str &#123;    //     unsafe &#123;    //         ptr::write_volatile(UART0, *byte);    //     &#125;    // &#125;    // // print_something(); // 调用测试函数    // println!(&quot;\\n[0] Hello from Rust!&quot;);    interrupts::init_gicv2();&#125;// ······\n\n至此，我们已经在EL1级别定义了完整的中断处理框架，可以开始处理实际的中断了。\n2) 使能时钟中断编辑src/interrupts.rs，在init_gicv2函数中添加使能时钟中断，同时配置时钟每秒产生一次中断。\n// ······use core::arch::asm;pub fn init_gicv2() &#123;    // ······    // 启用distributor和cpu interface    unsafe &#123;        ptr::write_volatile(GICD_CTLR, GICD_CTLR_ENABLE);        ptr::write_volatile(GICC_CTLR, GICC_CTLR_ENABLE);    &#125;        // 电平触发    const ICFGR_LEVEL: u32 = 0;    // 时钟中断号30    const TIMER_IRQ: u32 = 30;    set_config(TIMER_IRQ, ICFGR_LEVEL); // 电平触发    set_priority(TIMER_IRQ, 0); // 优先级设定    clear(TIMER_IRQ); // 清除中断请求    enable(TIMER_IRQ); // 使能中断        //配置timer    unsafe &#123;        asm!(&quot;mrs x1, CNTFRQ_EL0&quot;); // 读取系统频率        asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);  // 设置定时寄存器        asm!(&quot;mov x0, 1&quot;);        asm!(&quot;msr CNTP_CTL_EL0, x0&quot;); // enable=1, imask=0, istatus= 0,        asm!(&quot;msr daifclr, #2&quot;);    &#125;&#125;// ······\n\n\n3) 调试编译并以调试模式运行\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -S -s\n保持此终端会话，新开一个终端，配置GDB环境\ncd ~/ToolChain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/binexport ToolChainPath=`pwd`cd ~/rui_armv8_osexport PATH=$ToolChainPath:$PATH\n启动GDB调试客户端\naarch64-none-elf-gdb target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n连接远程客户端\ntarget remote localhost:1234\n在not_main()函数处设置断点\nb not_main\n运行到interrupts::init_gicv2();语句之前。\nn\n\n我们之前在init_gicv2()函数中加入了以下代码\n// 电平触发const ICFGR_LEVEL: u32 = 0;// 时钟中断号30const TIMER_IRQ: u32 = 30;set_config(TIMER_IRQ, ICFGR_LEVEL); //电平触发set_priority(TIMER_IRQ, 0); //优先级设定clear(TIMER_IRQ); //清除中断请求enable(TIMER_IRQ); //使能中断\n因此，当我们运行init_gicv2()函数后，其中的enable(TIMER_IRQ);会产生使能中断。我们查看enable()函数的代码\n// 使能中断号为interrupt的中断pub fn enable(interrupt: u32) &#123;    unsafe &#123;        ptr::write_volatile(            GICD_ISENABLER.add((interrupt / GICD_ISENABLER_SIZE) as usize),            1 &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)        );    &#125;&#125;\n由此可知，该函数对GICD_ISENABLER + interrupt / GICD_ISENABLER_SIZE对应的地址易失性写入1 &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)。\n我们之前在src/interrupts.rs中定义GICD寄存器内存映射GICD_BASE的起始地址为0x08000000，而GICD_ISENABLER的地址为GICD_BASE + 0x0100 = 0x08000100，GICD_ISENABLER_SIZE为32，TIMER_IRQ为30。\nconst GICD_BASE: u64 = 0x08000000;const GICD_ISENABLER: *mut u32 = (GICD_BASE + 0x0100) as *mut u32;const GICD_ISENABLER_SIZE: u32 = 32;const TIMER_IRQ: u32 = 30;\n\n因此，对于enable(TIMER_IRQ);，我们可以理解为在0x08000100中易失性写入1左移30位后的二进制数。\n查看0x08000100地址中的值\nx/t 0x08000100\n我们得到了0000000000000000111111111111111，继续运行，执行interrupts::init_gicv2();，再次查看0x08000100地址中的值，此时变为了0100000000000000111111111111111\n\n由此证明中断产生了。实际上这里并没有产生中断！我们只是初始化了GICV2并且写入TIMER_IRQ中断号，如果时钟中断生效了，那么理论上来说每隔一秒都会调用一次el1_irq()回调函数并且打印相应的中断信息，哪里出问题了呢？\n四*、实现真正的时钟中断1. 整理代码\n参考代码：下载\n\n在实现真正的时钟中断之前，我们的代码已经有亿点乱了，并且还会有很多恼人的unused warnings，因此我们先整理一下代码。首先打开src/main.rs：\n\n注意到这里的core::ptr并没有被使用。\n\n因此我们将其移除。\n\nnot_main()函数中移除不需要的代码\n\n只保留一个println!宏以及中断初始化函数init_gicv2()即可。print_something()函数我们亦不再用到，移除其相关代码。\n\n现在看起来就清爽多了~接下来在src/interrupts.rs中有很多没有用到的常量和函数，通常称为dead_code，但是为了保证完整性我们不选择删除它们，而是忽略掉。在src/main.rs中加入\n#![allow(dead_code)] // 忽略dead_code\n\n最后一个warning在aarch64-unknown-none-softfloat.json中\n&quot;abi-blacklist&quot;: [      &quot;stdcall&quot;,      &quot;fastcall&quot;,      &quot;vectorcall&quot;,      &quot;thiscall&quot;,      &quot;win64&quot;,      &quot;sysv64&quot;    ],\n这个abi-blacklist推测是屏蔽一些接口，我们并没有调用这些接口，所以直接移除。\n\n至此我们的warnings已经 全部处理(忽略) 完了。\n\n\n\n\n2. 实现\n参考代码：下载\n\n在查阅大量的资料后，我找到了本次实验的原型(?)LeOS以及其对应的时钟中断部分的博客。仔细阅读可以发现他实现时钟中断的Commit。在与noionion的合作及其帮助下，我们发现了LeOS关于时钟中断的实现与实验四 中断中有一些不一样的地方：\n在初始化中断时，LeOS还多了以下代码:\n\n因此我们在src/interrupts.rs下的init_gicv2()函数尾部添加以下代码：\nloop &#123;    unsafe &#123;        asm!(&quot;mrs x0, CNTPCT_EL0&quot;); // 系统计数器        asm!(&quot;mrs x0, CNTP_CTL_EL0&quot;); // 控制计数器        asm!(&quot;mrs x0, CNTP_TVAL_EL0&quot;); // 定时计数器        asm!(&quot;mrs x0, CNTP_CVAL_EL0&quot;); // 比较计数器        asm!(&quot;wfi&quot;); // Wait for Interrupt 等待中断，下一次中断发生前都停止在此处    &#125;&#125;\n\n这里的五句 asm! 其实前四句是无效操作，可以仅执行最后一句。另外更严谨地说，该 loop {} 亦可放在 not_main() 函数中，调用 init_gicv2() 初始化后。\n\n\n编译并运行\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n\n在运行后，首先会输出\n[0] Hello from Rust!\n大约1s后会输出\nEL1_IRQ @ 0x\n说明这次我们成功调用了el1_irq()回调函数！但问题是，时钟中断的理想状态应是每隔1s就会调用一次el1_irq()回调函数，这里调用一次后却不再变化了。这里其实是因为catch()函数在调用第一个参数ctx时会发生阻塞，具体原因不详。\n\n若想修复这个问题，可以编辑.cargo/config.toml，清空然后改为以下内容\n[unstable]build-std = [&quot;core&quot;, &quot;compiler_builtins&quot;] [build]target = &quot;aarch64-unknown-none-softfloat&quot;rustflags = [&quot;-C&quot;,&quot;link-arg=-Taarch64-qemu.ld&quot;, &quot;-C&quot;, &quot;target-cpu=cortex-a53&quot;, &quot;-D&quot;, &quot;warnings&quot;]\n\n\n因此我们修改该函数，编辑interrupts.rs：\n// ······// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息fn catch(ctx: &amp;mut ExceptionCtx, name: &amp;str) &#123;    crate::print!(&quot;&#123;&#125;\\n&quot;, name);&#125;// ······\n\n然后编译运行\n\n可以发现现在确实能够一直触发中断并且输出回调函数名了。但这每次输出间隔的时间太短了吧！这里我们需要了解一些概念：\n\n在ARM体系结构中，处理器内部有通用计时器，通用计时器包含一组比较器，用来与系统计数器(CNTPCT_EL0)进行比较，一旦通用计时器的值小于等于系统计数器时便会产生时钟中断。\n比较寄存器(CNTP_CVAL_EL0) 有64位，如果设置了之后，当系统计数器达到或超过了这个值之后，就会触发定时器中断。\n定时寄存器(CNTP_TVAL_EL0) 有32位，如果设置了之后，会将比较寄存器设置成当前系统计数器加上设置的定时寄存器的值。\n\n详见此处\n\n\n\n\n因此我们若想要有延时效果，需要在调用el1_irq()回调函数时再次写入定时寄存器。\nasm!(&quot;mrs x1, CNTFRQ_EL0&quot;);asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);\n\n此时再编译运行，我们就已经成功做到每1s处理一次时钟中断了！\n\n\n五、输入\n参考代码：下载\nQEMU的virt机器默认没有键盘作为输入设备，但当我们执行QEMU使用-nographic参数（Disable graphical output and redirect serial I/Os to console）时QEMU会将串口重定向到控制台，因此我们可以使用UART作为输入设备。\n\n1. 安装tock-registers库\n在实验四中，针对GICD，GICC，TIMER等硬件我们定义了大量的常量和寄存器值，这在使用时过于繁琐也容易出错。因此我们决定采用tock-registers库。\n\n在Cargo.toml中的[dependencies]处中加入依赖：\ntock-registers = &quot;0.7.0&quot;\n\n\n2. 重构\n为了不至于使src/uart_console.rs文件过长，我们选择重构uart_console.rs。\n\n首先进入项目根目录，创建src/uart_console目录\nmkdir src/uart_console\n将原uart_console.rs更名为mod.rs，且置于src/uart_console目录下\nmv src/uart_console.rs src/uart_console/mod.rs\n最后新建src/uart_console/pl011.rs\ntouch src/uart_console/pl011.rs\n依据tock_registers库的要求对pl011所涉及到的寄存器进行描述。编辑src/uart_console/pl011.rs\nuse tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;pub const PL011REGS: *mut PL011Regs = (0x0900_0000) as *mut PL011Regs;register_bitfields![    u32,    pub UARTDR [        DATA OFFSET(0) NUMBITS(8) []    ],    /// Flag Register    pub UARTFR [        /// Transmit FIFO full. The meaning of this bit depends on the        /// state of the FEN bit in the UARTLCR_ LCRH Register. If the        /// FIFO is disabled, this bit is set when the transmit        /// holding register is full. If the FIFO is enabled, the TXFF        /// bit is set when the transmit FIFO is full.        TXFF OFFSET(6) NUMBITS(1) [],        /// Receive FIFO empty. The meaning of this bit depends on the        /// state of the FEN bit in the UARTLCR_H Register. If the        /// FIFO is disabled, this bit is set when the receive holding        /// register is empty. If the FIFO is enabled, the RXFE bit is        /// set when the receive FIFO is empty.        RXFE OFFSET(4) NUMBITS(1) []    ],    /// Integer Baud rate divisor    pub UARTIBRD [        /// Integer Baud rate divisor        IBRD OFFSET(0) NUMBITS(16) []    ],    /// Fractional Baud rate divisor    pub UARTFBRD [        /// Fractional Baud rate divisor        FBRD OFFSET(0) NUMBITS(6) []    ],    /// Line Control register    pub UARTLCR_H [        /// Parity enable. If this bit is set to 1, parity checking and generation        /// is enabled, else parity is disabled and no parity bit added to the data frame.        PEN OFFSET(1) NUMBITS(1) [            Disabled = 0,            Enabled = 1        ],        /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted        /// at the end of the frame.        STP2 OFFSET(3) NUMBITS(1) [            Stop1 = 0,            Stop2 = 1        ],        /// Enable FIFOs.        FEN OFFSET(4) NUMBITS(1) [            Disabled = 0,            Enabled = 1        ],        /// Word length. These bits indicate the number of data bits        /// transmitted or received in a frame.        WLEN OFFSET(5) NUMBITS(2) [            FiveBit = 0b00,            SixBit = 0b01,            SevenBit = 0b10,            EightBit = 0b11        ]    ],    /// Control Register    pub UARTCR [        /// Receive enable. If this bit is set to 1, the receive        /// section of the UART is enabled. Data reception occurs for        /// UART signals. When the UART is disabled in the middle of        /// reception, it completes the current character before        /// stopping.        RXE    OFFSET(9) NUMBITS(1) [            Disabled = 0,            Enabled = 1        ],        /// Transmit enable. If this bit is set to 1, the transmit        /// section of the UART is enabled. Data transmission occurs        /// for UART signals. When the UART is disabled in the middle        /// of transmission, it completes the current character before        /// stopping.        TXE    OFFSET(8) NUMBITS(1) [            Disabled = 0,            Enabled = 1        ],        /// UART enable        UARTEN OFFSET(0) NUMBITS(1) [            /// If the UART is disabled in the middle of transmission            /// or reception, it completes the current character            /// before stopping.            Disabled = 0,            Enabled = 1        ]    ],    pub UARTIMSC [        RXIM OFFSET(4) NUMBITS(1) [            Disabled = 0,            Enabled = 1        ]    ],    /// Interupt Clear Register    pub UARTICR [        /// Meta field for all pending interrupts        ALL OFFSET(0) NUMBITS(11) [            Clear = 0x7ff        ]    ]];register_structs! &#123;    pub PL011Regs &#123;        (0x00 =&gt; pub dr: ReadWrite&lt;u32, UARTDR::Register&gt;),                   // 0x00        (0x04 =&gt; __reserved_0),               // 0x04        (0x18 =&gt; pub fr: ReadOnly&lt;u32, UARTFR::Register&gt;),      // 0x18        (0x1c =&gt; __reserved_1),               // 0x1c        (0x24 =&gt; pub ibrd: WriteOnly&lt;u32, UARTIBRD::Register&gt;), // 0x24        (0x28 =&gt; pub fbrd: WriteOnly&lt;u32, UARTFBRD::Register&gt;), // 0x28        (0x2C =&gt; pub lcr_h: WriteOnly&lt;u32, UARTLCR_H::Register&gt;), // 0x2C        (0x30 =&gt; pub cr: WriteOnly&lt;u32, UARTCR::Register&gt;),     // 0x30        (0x34 =&gt; __reserved_2),               // 0x34        (0x38 =&gt; pub imsc: ReadWrite&lt;u32, UARTIMSC::Register&gt;), // 0x38        (0x44 =&gt; pub icr: WriteOnly&lt;u32, UARTICR::Register&gt;),   // 0x44        (0x48 =&gt; @END),    &#125;&#125;\n\nregister_bitfields!宏按照寄存器的位结构进行描述，注意最后要加分号”;”，只要注册自己想处理的位即可。\nregister_structs!宏最后需加上 (0x** =&gt; @END) ，表示结束。\n\n3. 数据接收中断编辑src/uart_console/mod.rs，修改Writer的初始化方式\n// ······use core::&#123;fmt, ptr&#125;;use lazy_static::lazy_static;use spin::Mutex;use tock_registers::interfaces::Writeable;pub mod pl011;use pl011::*;lazy_static! &#123;    /// A global `Writer` instance that can be used for printing to the VGA text buffer.    ///    /// Used by the `print!` and `println!` macros.    pub static ref WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer::new());&#125;/// Like the `print!` macro in the standard library, but prints to the VGA text buffer.// ······\n\n\n编辑src/uart_console/mod.rs，为Writer结构实现构造函数\n//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构pub struct Writer;//往串口寄存器写入字节和字符串进行输出impl Writer &#123;    pub fn write_byte(&amp;mut self, byte: u8) &#123;        // ······    &#125;    pub fn write_string(&amp;mut self, s: &amp;str) &#123;        // ······    &#125;    pub fn new() -&gt; Writer&#123;        unsafe &#123;            // pl011 device registers            let pl011r: &amp;PL011Regs = &amp;*PL011REGS;                // 禁用pl011            pl011r.cr.write(UARTCR::TXE::Disabled + UARTCR::RXE::Disabled + UARTCR::UARTEN::Disabled);            // 清空中断状态            pl011r.icr.write(UARTICR::ALL::Clear);            // 设定中断mask，需要使能的中断            pl011r.imsc.write(UARTIMSC::RXIM::Enabled);            // IBRD = UART_CLK / (16 * BAUD_RATE)            // FBRD = ROUND((64 * MOD(UART_CLK,(16 * BAUD_RATE))) / (16 * BAUD_RATE))            // UART_CLK = 24M            // BAUD_RATE = 115200            pl011r.ibrd.write(UARTIBRD::IBRD.val(13));            pl011r.fbrd.write(UARTFBRD::FBRD.val(1));            // 8N1 FIFO enable            pl011r.lcr_h.write(UARTLCR_H::WLEN::EightBit + UARTLCR_H::PEN::Disabled + UARTLCR_H::STP2::Stop1                + UARTLCR_H::FEN::Enabled);            // enable pl011            pl011r.cr.write(UARTCR::UARTEN::Enabled + UARTCR::RXE::Enabled + UARTCR::TXE::Enabled);        &#125;            Writer    &#125;&#125;impl core::fmt::Write for Writer &#123;// ······\n\n\n继续编辑src/uart_console/mod.rs，修改write_byte()函数，使用我们通过宏描述的寄存器\n//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构pub struct Writer;//往串口寄存器写入字节和字符串进行输出impl Writer &#123;    pub fn write_byte(&amp;mut self, byte: u8) &#123;        // const UART0: *mut u8 = 0x0900_0000 as *mut u8;        unsafe &#123;            // pl011 device registers            let pl011r: &amp;PL011Regs = &amp;*PL011REGS;                // ptr::write_volatile(UART0, byte);            pl011r.dr.write(UARTDR::DATA.val(byte as u32));        &#125;    &#125;    pub fn write_string(&amp;mut self, s: &amp;str) &#123;    // ······\n\n\n编辑src/interrupts.rs，修改init_gicv2()函数，对UART的数据接收中断进行初始化：\n// ······    //配置timer    unsafe &#123;        // ······    &#125;    // 初始化UART0 中断    // interrupts = &lt;0x00 0x01 0x04&gt;; SPI, 0x01, level    set_config(UART0_IRQ, ICFGR_LEVEL); //电平触发    set_priority(UART0_IRQ, 0); //优先级设定    // set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核    clear(UART0_IRQ); //清除中断请求    enable(UART0_IRQ); //使能中断    loop &#123;        // ······    &#125;// ······\n\n编辑src/interrupts.rs，接下来我们定义UART0_IRQ全局常量，同时把TIMER_IRQ也修改为全局常量\n// 时钟中断号const TIMER_IRQ: u32 = 30;// 设备中断号const UART0_IRQ: u32 = 33;\n\n\n继续编辑src/interrupts.rs，对UART的数据接收中断进行处理，并修改timer中断的处理方法，使之每隔2秒输出一个点。在文末添加以下三个函数。\nuse tock_registers::interfaces::Readable;fn handle_irq_lines(ctx: &amp;mut ExceptionCtx, _core_num: u32, irq_num: u32) &#123;    if irq_num == TIMER_IRQ &#123;        handle_timer_irq(ctx);    &#125;else if irq_num == UART0_IRQ &#123;        handle_uart0_rx_irq(ctx);    &#125;    else&#123;        catch(ctx, EL1_IRQ);    &#125;&#125;fn handle_timer_irq(_ctx: &amp;mut ExceptionCtx)&#123;    crate::print!(&quot;.&quot;);    // 每2秒产生一次中断    unsafe &#123;        asm!(&quot;mrs x1, CNTFRQ_EL0&quot;);        asm!(&quot;add x1, x1, x1&quot;);        asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);    &#125;&#125;fn handle_uart0_rx_irq(_ctx: &amp;mut ExceptionCtx)&#123;    use crate::uart_console::pl011::*;    crate::print!(&quot;\\nInput interrupt: &quot;);    unsafe&#123;        // pl011 device registers        let pl011r: &amp;PL011Regs = &amp;*PL011REGS;        let mut flag = pl011r.fr.read(UARTFR::RXFE);        while flag != 1 &#123;            let value = pl011r.dr.read(UARTDR::DATA);            crate::print!(&quot;&#123;&#125;&quot;, value as u8 as char);            flag = pl011r.fr.read(UARTFR::RXFE);        &#125;    &#125;&#125;\n\n继续编辑src/interrupts.rs，修改el1_irq()函数\n#[no_mangle]unsafe extern &quot;C&quot; fn el1_irq(ctx: &amp;mut ExceptionCtx) &#123;    // reads this register to obtain the interrupt ID of the signaled interrupt.    // This read acts as an acknowledge for the interrupt.    // 中断确认    const GICC_IAR: *mut u32 = (GICC_BASE + 0x0c) as *mut u32;    const GICC_EOIR: *mut u32 = (GICC_BASE + 0x10) as *mut u32;    let value: u32 = ptr::read_volatile(GICC_IAR);    let irq_num: u32 = value &amp; 0x1ff;    let core_num: u32 = value &amp; 0xe00;    // 实际处理中断    handle_irq_lines(ctx, core_num, irq_num);    // catch(ctx, EL1_IRQ);    // A processor writes to this register to inform the CPU interface either:    // • that it has completed the processing of the specified interrupt    // • in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set to 1, to indicate that the interface should perform priority drop for the specified interrupt.    // 标记中断完成，清除相应中断位    ptr::write_volatile(GICC_EOIR, core_num | irq_num);    clear(irq_num);&#125;\n\n\n之前我们修改了catch()函数，没有调用ctx参数，所以会有一个warning，这里我们选择再次将其忽略编辑src/main.rs\n#![allow(dead_code, unused_variables)] // 忽略dead_code\n\n\n并且在src/uart_console/mod.rs中，有一个未使用的core::ptr引用，将其移除\n\n\n接下来编译并运行\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os\n\n可以看到每过2s就会打一个点。如果我们按顺序输入a、b、c，则会触发输入中断\n\n\n六、GPIO关机\n参考代码：下载\n\n1. 原理查看virt.dts，可以发现：\ngpio-keys &#123;\t#address-cells = &lt;0x01&gt;;\t#size-cells = &lt;0x00&gt;;\tcompatible = &quot;gpio-keys&quot;;\tpoweroff &#123;\t\tgpios = &lt;0x8003 0x03 0x00&gt;;\t\tlinux,code = &lt;0x74&gt;;\t\tlabel = &quot;GPIO Key Poweroff&quot;;\t&#125;;&#125;;pl061@9030000 &#123;\tphandle = &lt;0x8003&gt;;\tclock-names = &quot;apb_pclk&quot;;\tclocks = &lt;0x8000&gt;;\tinterrupts = &lt;0x00 0x07 0x04&gt;;\tgpio-controller;\t#gpio-cells = &lt;0x02&gt;;\tcompatible = &quot;arm,pl061\\0arm,primecell&quot;;\treg = &lt;0x00 0x9030000 0x00 0x1000&gt;;&#125;;\n\n其中gpio-keys中定义了一个poweroff键， gpios = &lt;0x8003 0x03 0x00&gt; 中的第一项0x8003表示它的phandle是0x8003， 即pl061@9030000，也即gpio-keys是设备pl061的组成部分，第二项0x03表示该键是pl061的第三根GPIO线，第三项是flag，且pl061的寄存器映射到了内存0x9030000开始的位置。如下图所示。\n\n\n2. 实现新建src/pl061.rs\ntouch src/pl061.rs\n编辑src/pl061.rs，通过tock-registers描述寄存器\nuse tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;pub const PL061REGS: *mut PL061Regs = (0x0903_0000) as *mut PL061Regs;register_bitfields![    u32,    pub GPIOIE [        IO3 OFFSET(3) NUMBITS(1) [            Disabled = 0,            Enabled = 1        ]    ],];register_structs! &#123;    pub PL061Regs &#123;        (0x000 =&gt; __reserved_0),                                               // 0x000        (0x410 =&gt; pub ie: ReadWrite&lt;u32, GPIOIE::Register&gt;),                   // 0x410        (0x414 =&gt; __reserved_1),                                               // 0x414        (0x41C =&gt; pub ic: WriteOnly&lt;u32&gt;),                                     // 0x41C        (0x420 =&gt; @END),                                                       // 0x420    &#125;&#125;\n编辑src/main.rs，引入pl061模块。\n// ······use core::arch::global_asm; // 导入需要的Modulemod panic;mod uart_console;mod interrupts;mod pl061;global_asm!(include_str!(&quot;start.s&quot;));// ······\n\n编辑src/interrupts.rs，在init_gicv2函数中初始化pl061的GPIO中断\n// ······// 时钟中断号const TIMER_IRQ: u32 = 30;// 设备中断号const UART0_IRQ: u32 = 33;const GPIO_IRQ: u32 = 39; // virt.dts interrupts = &lt;0x00 0x07 0x04&gt;; 32 + 0x07 = 39pub fn init_gicv2() &#123;    // 初始化Gicv2的distributor和cpu interface    // 禁用distributor和cpu interface后进行相应配置    // ······    // 初始化GPIO中断    set_config(GPIO_IRQ, ICFGR_LEVEL); //电平触发    set_priority(GPIO_IRQ, 0); //优先级设定    // set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核    clear(GPIO_IRQ); //清除中断请求    enable(GPIO_IRQ); //使能中断    // 使能GPIO的poweroff key中断    use crate::pl061::*;    unsafe&#123;        let pl061r: &amp;PL061Regs = &amp;*PL061REGS;        // 启用pl061 gpio中的3号线中断        pl061r.ie.write(GPIOIE::IO3::Enabled);    &#125;    loop &#123;        // ······    &#125;&#125;// ······\n\n编辑src/interrupts.rs，引入tock_registers::interfaces::Writeable\n// ······use tock_registers::interfaces::Readable;use tock_registers::interfaces::Writeable;fn handle_irq_lines(ctx: &amp;mut ExceptionCtx, _core_num: u32, irq_num: u32) &#123;    // ······&#125;// ······\n\n编辑src/interrupts.rs，处理pl0613号GPIO线引发的中断\n// ······fn handle_irq_lines(ctx: &amp;mut ExceptionCtx, _core_num: u32, irq_num: u32) &#123;    if irq_num == TIMER_IRQ &#123;        handle_timer_irq(ctx);    &#125;else if irq_num == UART0_IRQ &#123;        handle_uart0_rx_irq(ctx);    &#125;else if irq_num == GPIO_IRQ &#123;        handle_gpio_irq(ctx);    &#125;    else&#123;        catch(ctx, EL1_IRQ);    &#125;&#125;fn handle_timer_irq(_ctx: &amp;mut ExceptionCtx)&#123;    // ······&#125;// ······fn handle_gpio_irq(_ctx: &amp;mut ExceptionCtx)&#123;    use crate::pl061::*;    crate::println!(&quot;Power off!\\n&quot;);    unsafe &#123;        let pl061r: &amp;PL061Regs = &amp;*PL061REGS;        // 清除中断信号        pl061r.ic.set(pl061r.ie.get());        // 关机        asm!(&quot;mov w0, #0x18&quot;);        asm!(&quot;hlt #0xF000&quot;);    &#125;&#125;\n\n\n\n在 handle_gpio_irq() 函数里通过内联汇编执行了指令hlt #0xF000，这里用到了ARM的Semihosting功能。\n\nSemihosting的作用：能够让bare-metal的ARM设备通过拦截指定的SVC指令，在连操作系统都没有的环境中实现POSIX中的许多标准函数，比如printf、scanf、open、read、write等等。这些IO操作将被Semihosting协议转发到Host主机上，然后由主机代为执行。\n\n\n编辑src/interrupts.rs，停止打点，方便后续测试观察\n// ······fn handle_timer_irq(_ctx: &amp;mut ExceptionCtx)&#123;    // crate::print!(&quot;.&quot;);    // 每2秒产生一次中断    unsafe &#123;        asm!(&quot;mrs x1, CNTFRQ_EL0&quot;);        asm!(&quot;add x1, x1, x1&quot;);        asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);    &#125;&#125;// ······\n\n\n3. 执行\n为了启用Semihosting功能，在QEMU执行时需要加入 -semihosting 参数\n\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n先按Ctrl + A，松手再按C，然后输入system_powerdown执行关机。\n\n\n七、死锁与简单处理\n参考代码：下载\n当多个任务访问同一个资源（数据）时就会引发竞争条件问题，这不仅在进程间会出现，在操作系统和进程间也会出现。由竞争条件引发的问题很难复现和调试，这也是其最困难的地方。本实验的目的在于了解竞争条件和死锁现象，并掌握处理这些问题的初步方法等。\n\n勘误\n在src/interrupts.rs的init_gicv2()函数中，我们之前使用了一个循环并使用内联汇编asm!(“wfi”)来等待中断，实际上在之前的实验中，这里所有的内联汇编都是没有必要的。当去掉这个循环，我们的OS会串行执行完成然后自动关机，从而导致后续的测试无效。因此我们需要且仅需要一个空循环来使OS持续运行，以便后续的中断测试。\n\n编辑src/interrupts.rs，在init_gicv2()函数中移除loop&#123;&#125;循环。\n\n\n编辑src/main.rs，在not_main()函数尾部添加loop&#123;&#125;空循环。\n// ······#[no_mangle] // 不修改函数名pub extern &quot;C&quot; fn not_main() &#123;    println!(&quot;\\n[0] Hello from Rust!\\n&quot;);    interrupts::init_gicv2();    loop &#123;&#125;&#125;\n\n\n死锁的复现首先编辑src/main.rs，在not_main()函数的空循环中调用print!宏\n// ······global_asm!(include_str!(&quot;start.s&quot;));#[no_mangle] // 不修改函数名pub extern &quot;C&quot; fn not_main() &#123;    println!(&quot;\\n[0] Hello from Rust!\\n&quot;);    interrupts::init_gicv2();    loop &#123;        print!(&quot;-&quot;);    &#125;&#125;\n\n\n这里有两种方式复现死锁现象。\n1. loop{}中print!宏与handle_uart0_rx_irq()中print!宏竞争检查src/interrupts.rs中的handle_uart0_rx_irq()函数，可以看到我们之前写了一个输入中断回调函数，在函数中调用了print!宏输出信息。\n\n\n直接编译并运行，预期在输入时触发死锁。\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n不停地乱序敲击键盘，此时有概率出现卡死，按键无法再次输入内容，即触发死锁现象。\n\n\n2. loop{}中print!宏与handle_timer_irq()中print!宏竞争检查src/interrupts.rs中的handle_timer_irq()函数，可以看到我们之前写了一个时间中断回调函数，在函数中调用了print!宏打点。\n但它之前被我们注释掉了，因此我们取消注释\n\n\n然后我们编译并运行，预期在打第一个点时会触发死锁。\ncargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n实验按预期触发了死锁。\n\n有时会在打第二个点时触发死锁。\n\n\n死锁的简单处理编辑src/uart_console/mod.rs，引入asm!宏\n// ······impl core::fmt::Write for Writer &#123;    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result &#123;        // ······    &#125;&#125;use core::&#123;fmt, arch::asm&#125;;use lazy_static::lazy_static;use spin::Mutex;use tock_registers::interfaces::Writeable;pub mod pl011;use pl011::*;// ······\n\n\n编辑src/uart_console/mod.rs中的_print()函数，在处理输入时先关闭中断，再打开。\n// ······/// Prints the given formatted string to the VGA text buffer through the global `WRITER` instance.#[doc(hidden)]pub fn _print(args: fmt::Arguments) &#123;    use core::fmt::Write;    unsafe &#123;        // 关闭d a i f类型的中断        asm!(&quot;msr daifset, #0xf&quot;);    &#125;    WRITER.lock().write_fmt(args).unwrap();    unsafe &#123;        // 仅打开i类型的中断，不支持嵌套，嵌套应该保存状态，然后再恢复之前的状态        asm!(&quot;msr daifclr, #2&quot;);    &#125;&#125;\n\n\n验证此时再用上述两种方式测试死锁，发现死锁现象消失了~\n八、内存管理\n分页内存管理是内存管理的基本方法之一。本实验的目的在于全面理解分页式内存管理的基本方法以及访问页表，完成地址转换等的方法。\n\nARM v8的地址转换\nARM Cortex-A Series Programmer’s Guide for ARMv8-A 中提到：\nFor EL0 and EL1, there are two translation tables. TTBR0_EL1 provides translations for the bottom of Virtual Address space, which is typically application space and TTBR1_EL1 covers the top of Virtual Address space, typically kernel space. This split means that the OS mappings do not have to be replicated in the translation tables of each task.\n即TTBR0指向虚拟空间下半部分通常用于应用程序的空间，TTBR1指向虚拟空间上半部分通常用于内核的空间。其中TTBR0除了在EL1中存在外，也在EL2和EL3中存在，但TTBR1只在EL1中存在。\nTTBR0_ELn和TTBR1_ELn是页表基地址寄存器，地址转换的过程如下所示 \n\n\n一、使用Identity Mapping映射\n参考代码：下载\n虚拟地址转换很容易出错也很难调试，所以我们从最简单的方式开始，即采用Identity Mapping，将虚拟地址映射到相同的物理地址。\n\n编辑src/start.s，初始化MMU、页表以及启用页表。\n.globl _start.extern LD_STACK_PTR.section &quot;.text.boot&quot;_start:        ldr     x30, =LD_STACK_PTR        mov     sp, x30        // Initialize exceptions        ldr     x0, =exception_vector_table        msr     vbar_el1, x0        isb_setup_mmu:        // 初始化TCR控制寄存器        ldr     x0, =TCR_EL1_VALUE        msr     tcr_el1, x0        ldr     x0, =MAIR_EL1_VALUE        msr     mair_el1, x0            // 内存属性间接寄存器，作用是预先定义好属性，然后通过索引来访问这些预定义的属性_setup_pagetable:        // 因为采用的36位地址空间，所以是一级页表        ldr     x1, =LD_TTBR0_BASE        msr     ttbr0_el1, x1           //页表基地址TTBR0        ldr     x2, =LD_TTBR1_BASE        msr     ttbr1_el1, x2           //页表基地址TTBR1        // 一级页表部分        // 虚拟地址空间的下半部分采用Identity Mapping        // 第一项 虚拟地址0 - 1G，根据virt的定义为flash和外设，参见virt.c        ldr     x3, =0x0        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =PERIPHERALS_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x1], #8        // 第二项 虚拟地址1G - 2G，_start部分        ldr     x3, =_start        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =IDENTITY_MAP_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x1], #8_enable_mmu:        // 启用MMU.        mrs     x0, sctlr_el1        orr     x0, x0, #0x1        msr     sctlr_el1, x0        dsb     sy                      // Programmer’s Guide for ARMv8-A chapter13.2 Barriers        isb_start_main:        bl      not_main.equ PSCI_SYSTEM_OFF, 0x84000002.globl system_offsystem_off:        ldr     x0, =PSCI_SYSTEM_OFF        hvc     #0.equ TCR_EL1_VALUE, 0x1B55C351C// ---------------------------------------------// IPS   | b001    &lt;&lt; 32 | 36bits address space - 64GB// TG1   | b10     &lt;&lt; 30 | 4KB granule size for TTBR1_EL1// SH1   | b11     &lt;&lt; 28 | 页表所在memory: Inner shareable// ORGN1 | b01     &lt;&lt; 26 | 页表所在memory: Normal, Outer Wr.Back Rd.alloc Wr.alloc Cacheble// IRGN1 | b01     &lt;&lt; 24 | 页表所在memory: Normal, Inner Wr.Back Rd.alloc Wr.alloc Cacheble// EPD   | b0      &lt;&lt; 23 | Perform translation table walk using TTBR1_EL1// A1    | b1      &lt;&lt; 22 | TTBR1_EL1.ASID defined the ASID// T1SZ  | b011100 &lt;&lt; 16 | Memory region 2^(64-28) -&gt; 0xffffffexxxxxxxxx// TG0   | b00     &lt;&lt; 14 | 4KB granule size// SH0   | b11     &lt;&lt; 12 | 页表所在memory: Inner Sharebale// ORGN0 | b01     &lt;&lt; 10 | 页表所在memory: Normal, Outer Wr.Back Rd.alloc Wr.alloc Cacheble// IRGN0 | b01     &lt;&lt; 8  | 页表所在memory: Normal, Inner Wr.Back Rd.alloc Wr.alloc Cacheble// EPD0  | b0      &lt;&lt; 7  | Perform translation table walk using TTBR0_EL1// 0     | b0      &lt;&lt; 6  | Zero field (reserve)// T0SZ  | b011100 &lt;&lt; 0  | Memory region 2^(64-28).equ MAIR_EL1_VALUE, 0xFF440C0400// ---------------------------------------------//                   INDX         MAIR// DEVICE_nGnRnE    b000(0)     b00000000// DEVICE_nGnRE         b001(1)         b00000100// DEVICE_GRE               b010(2)     b00001100// NORMAL_NC                b011(3)     b01000100// NORMAL               b100(4)         b11111111.equ PERIPHERALS_ATTR, 0x60000000000601// -------------------------------------// UXN   | b1      &lt;&lt; 54 | Unprivileged eXecute Never// PXN   | b1      &lt;&lt; 53 | Privileged eXecute Never// AF    | b1      &lt;&lt; 10 | Access Flag// SH    | b10     &lt;&lt; 8  | Outer shareable// AP    | b01     &lt;&lt; 6  | R/W, EL0 access denied// NS    | b0      &lt;&lt; 5  | Security bit (EL3 and Secure EL1 only)// INDX  | b000    &lt;&lt; 2  | Attribute index in MAIR_ELn，参见MAIR_EL1_VALUE// ENTRY | b01     &lt;&lt; 0  | Block entry.equ IDENTITY_MAP_ATTR, 0x40000000000711// ------------------------------------// UXN   | b1      &lt;&lt; 54 | Unprivileged eXecute Never// PXN   | b0      &lt;&lt; 53 | Privileged eXecute Never// AF    | b1      &lt;&lt; 10 | Access Flag// SH    | b11     &lt;&lt; 8  | Inner shareable// AP    | b00     &lt;&lt; 6  | R/W, EL0 access denied// NS    | b0      &lt;&lt; 5  | Security bit (EL3 and Secure EL1 only)// INDX  | b100    &lt;&lt; 2  | Attribute index in MAIR_ELn，参见MAIR_EL1_VALUE// ENTRY | b01     &lt;&lt; 0  | Block entry\n\n(如果预览不清晰，可以在新标签页中打开图片，或者下载图片，然后放大)\n编辑aarch64-qemu.ld，定义前文中用到的LD_TTBR0_BASE和LD_TTBR1_BASE符号\nENTRY(_start)SECTIONS&#123;    . = 0x40080000;    .text.boot : &#123; *(.text.boot) &#125;    .text :    &#123;        KEEP(*(.text.boot))        *(.text.exceptions)        . = ALIGN(4096); /* align for exceptions_vector_table*/        *(.text.exceptions_vector_table)        *(.text)    &#125;    .data : &#123; *(.data) &#125;    .rodata : &#123; *(.rodata) &#125;    .bss : &#123; *(.bss) &#125;    . = ALIGN(8);    . = . + 0x4000;    LD_STACK_PTR = .;    . = ALIGN(4096);    /*页表基地址TTBR0*/    LD_TTBR0_BASE = .;    . = . + 0x1000;    /*页表基地址TTBR1*/    LD_TTBR1_BASE = .;    . = . + 0x1000;&#125;\n\n\n编译并运行，测试能否正常工作。\ncargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n正常运行！\n二、使用Identity Mapping映射 - 偏移映射与页面共享\n参考代码：下载\n修改代码，将虚拟地址2G - 3G处映射到物理地址0 - 1G，从而对0x89000000地址的写入将通过pl011串口输出，因为此时0x89000000映射到了物理地址pl011@9000000。\n\n编辑src/start.s，空白映射虚拟地址0 - 1G，将虚拟地址2G - 3G处映射到物理地址0 - 1G。\n// ······_setup_pagetable:        // 因为采用的36位地址空间，所以是一级页表        ldr     x1, =LD_TTBR0_BASE        msr     ttbr0_el1, x1           //页表基地址TTBR0        ldr     x2, =LD_TTBR1_BASE        msr     ttbr1_el1, x2           //页表基地址TTBR1        // 一级页表部分        // 虚拟地址空间的下半部分采用Identity Mapping        // 第一项 虚拟地址0 - 1G        ldr     x5, =0x0        str     x5, [x1], #8        // 第二项 虚拟地址1G - 2G，_start部分        ldr     x3, =_start        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =IDENTITY_MAP_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x1], #8        // 第三项 虚拟地址2 - 3G，根据virt的定义为flash和外设，参见virt.c        ldr     x3, =0x0        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =PERIPHERALS_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x1], #8// ······\n\n\n编辑src/interrupts.rs，修改其基址（2G+原基址）\nuse core::ptr;// GICD和GICC寄存器内存映射后的起始地址const GICD_BASE: u64 = 0x8000_0000 + 0x08000000;const GICC_BASE: u64 = 0x8000_0000 + 0x08010000;// Distributor// ······\n\n\n编辑src/pl061.rs，修改其基址（2G+原基址）\nuse tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;pub const PL061REGS: *mut PL061Regs = (0x8000_0000u32 + 0x0903_0000) as *mut PL061Regs;// ······\n\n\n编辑src/uart_console/pl011.rs，修改其基址（2G+原基址）\nuse tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;pub const PL011REGS: *mut PL011Regs = (0x8000_0000u32 +0x0900_0000) as *mut PL011Regs;// ······\n\n\n编译并运行，测试能否正常工作。\ncargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n正常运行！\n三、使用非Identity Mapping映射 - 块级映射\n参考代码：下载\n\n编辑src/start.s，处理虚拟地址空间的上半部分。\n// ······_setup_pagetable:        // 因为采用的36位地址空间，所以是一级页表        ldr     x1, =LD_TTBR0_BASE        msr     ttbr0_el1, x1           //页表基地址TTBR0        ldr     x2, =LD_TTBR1_BASE        msr     ttbr1_el1, x2           //页表基地址TTBR1        // 一级页表部分        // 虚拟地址空间的下半部分采用Identity Mapping        // 第一项 虚拟地址0 - 1G        ldr     x5, =0x0        str     x5, [x1], #8        // 第二项 虚拟地址1G - 2G，_start部分        ldr     x3, =0x40010000        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =IDENTITY_MAP_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x1], #8        // 虚拟地址空间的上半部分采用非Identity Mapping        // 第一项 虚拟地址0 - 1G，根据virt的定义为flash和外设，参见virt.c        ldr     x3, =0x0 //        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =PERIPHERALS_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x2], #8        // 第二项， 映射到内存（块级映射）        ldr     x3, =0x40010000        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =KERNEL_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x2], #8_enable_mmu:// ······.equ KERNEL_ATTR, 0x40000000000711// -------------------------------------// UXN   | b1      &lt;&lt; 54 | Unprivileged eXecute Never// PXN   | b0      &lt;&lt; 53 | Privileged eXecute Never// AF    | b1      &lt;&lt; 10 | Access Flag// SH    | b11     &lt;&lt; 8  | Inner shareable// AP    | b00     &lt;&lt; 6  | R/W, EL0 access denied// NS    | b0      &lt;&lt; 5  | Security bit (EL3 and Secure EL1 only)// INDX  | b100    &lt;&lt; 2  | Attribute index in MAIR_ELn，参见MAIR_EL1_VALUE// ENTRY | b01     &lt;&lt; 0  | Block entry\n\n\n重构aarch64-qemu.ld\n__KERN_VMA_BASE = 0xfffffff000000000;__PHY_DRAM_START_ADDR = 0x40000000;__PHY_START_LOAD_ADDR = 0x40010000;ENTRY(__PHY_START_LOAD_ADDR)SECTIONS&#123;    . = __KERN_VMA_BASE + __PHY_START_LOAD_ADDR;    .text.boot : AT(__PHY_START_LOAD_ADDR) &#123; KEEP(*(.text.boot)) &#125;    .text :    &#123;        *(.text*)    &#125;    . = ALIGN(0x1000);    LD_DATA_BASE = .;    .data : &#123; *(.data*) &#125;    . = ALIGN(0x1000);    LD_RODATA_BASE = .;    .rodata : &#123; *(.rodata*) &#125;    . = ALIGN(0x1000);    LD_BSS_BASE = .;    .bss :    &#123;         *(.bss*)        . = ALIGN(4096);        . += (4096 * 100); /* 栈的大小 */        stack_top = .;        LD_STACK_PTR = .;    &#125;    /* 页表 */    .pt :        &#123;        . = ALIGN(4096);        /* 页表基地址TTBR0 */        LD_TTBR0_BASE = . - __KERN_VMA_BASE;        . = . + 0x1000;        /* 页表基地址TTBR1 */        LD_TTBR1_BASE = . - __KERN_VMA_BASE;        . = . + 0x1000;        &#125;    . = . + 0x1000;    LD_KERNEL_END = . - __KERN_VMA_BASE;&#125;\n\n编辑src/interrupts.rs，修改其基址（0xfffffff000000000+原基址）\nuse core::ptr;// GICD和GICC寄存器内存映射后的起始地址const GICD_BASE: u64 = 0xfffffff000000000 + 0x08000000;const GICC_BASE: u64 = 0xfffffff000000000 + 0x08010000;// Distributor// ······\n\n\n编辑src/pl061.rs，修改其基址（0xfffffff000000000+原基址）\nuse tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;pub const PL061REGS: *mut PL061Regs = (0xfffffff000000000u64 + 0x0903_0000) as *mut PL061Regs;// ······\n\n\n编辑src/uart_console/pl011.rs，修改其基址（0xfffffff000000000+原基址）\nuse tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;pub const PL011REGS: *mut PL011Regs = (0xfffffff000000000u64 + 0x0900_0000) as *mut PL011Regs;// ······\n\n\n编译并运行，测试能否正常工作。\ncargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n正常运行！\n修复异常现象\n参考代码：下载\n\n乍一看能正常运行，但是运行一段时间后居然卡死了！这是为什么呢？\n第一时间想到的是互斥锁可能出问题了，但是仔细看互斥锁的代码发现和内存映射关系应该不大。\n仔细观察输出发现打点是正常的，而且在没有卡死之前如果触发输入中断则会立刻卡死，因此判断是输入中断出了问题， noionion 认为是链接脚本的问题，而事实也如他所说。\n编辑aarch64-qemu.ld，修改.text : &#123;&#125;部分：\n/* ······ */.text.boot : AT(__PHY_START_LOAD_ADDR) &#123; KEEP(*(.text.boot)) &#125;.text :&#123;    KEEP(*(.text.boot))    *(.text.exceptions)    . = ALIGN(4096); /* align for exceptions_vector_table*/    *(.text.exceptions_vector_table)    *(.text)&#125;. = ALIGN(0x1000);/* ······ */\n\n\n编译并运行，测试能否正常工作。\ncargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n正常运行！\n四、使用非Identity Mapping映射 - 页表映射\n参考代码：下载\n\n在成功实现块级映射后，我们就可以尝试实现二级页表映射了。编辑src/start.s，修改块级映射为二级页表映射。\n// ······_setup_pagetable:        // 因为采用的36位地址空间，所以是一级页表        ldr     x1, =LD_TTBR0_BASE        msr     ttbr0_el1, x1           //页表基地址TTBR0        ldr     x2, =LD_TTBR1_BASE        msr     ttbr1_el1, x2           //页表基地址TTBR1        // 一级页表部分        // 虚拟地址空间的下半部分采用Identity Mapping        // 第一项 虚拟地址0 - 1G        ldr     x5, =0x0        str     x5, [x1], #8        // 第二项 虚拟地址1G - 2G，_start部分        ldr     x3, =LD_TTBR1_L2TBL        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =IDENTITY_MAP_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x1], #8        // 虚拟地址空间的上半部分采用非Identity Mapping        // 第一项 虚拟地址0 - 1G，根据virt的定义为flash和外设，参见virt.c        ldr     x3, =0x0        lsr     x4, x3, #30             // 除以1G        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0        ldr     x6, =PERIPHERALS_ATTR        orr     x5, x5, x6              // 添加符号        str     x5, [x2], #8        // 第二项，映射到页表        ldr     x3, =LD_TTBR1_L2TBL        ldr     x4, =0xFFFFF000        and     x5, x3, x4             // NSTable=0 APTable=0 XNTable=0 PXNTable=0.        orr     x5, x5, 0x3            // Valid page table entry        str     x5, [x2], #8           //TTBR1        // 二级页表，内核总共16M，参见aarch64-qemu.ld文件        ldr     x3, =LD_TTBR1_L2TBL        mov     x4, #8                  // 8个二级页表项        ldr     x5, =KERNEL_ATTR        // 内核属性，可读写，可执行        ldr     x7, =0x1        add     x5, x5, x7, lsl #30     // 物理地址在1G开始的位置        ldr     x6, =0x00200000         // 每次增加2M_build_2nd_pgtbl:        str     x5, [x3], #8            // 填入内容到页表项        add     x5, x5, x6              // 下一项的地址增加2M        subs    x4, x4, #1              // 项数减少1        bne     _build_2nd_pgtbl_enable_mmu:// ······\n\n\n编辑aarch64-qemu.ld，定义LD_TTBR0_L2TBL以及LD_TTBR1_L2TBL符号\n/* ······ *//* 页表 */.pt :    &#123;    . = ALIGN(4096);    /* 页表基地址TTBR0 */    LD_TTBR0_BASE = . - __KERN_VMA_BASE;    . = . + 0x1000;    /* 页表基地址TTBR1 */    LD_TTBR1_BASE = . - __KERN_VMA_BASE;    . = . + 0x1000;    /*二级页表*/    LD_TTBR0_L2TBL = . - __KERN_VMA_BASE;    . = . + 0x1000;    LD_TTBR1_L2TBL = . - __KERN_VMA_BASE;    . = . + 0x1000;    &#125;/* ······ */\n\n\n编译并运行，测试能否正常工作。\ncargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting\n\n正常运行！\n后记前前后后花了三个月时间完成了这篇1.6W字的笔记，最大的感悟却是：自己的挖的坑只能含泪填完。\n","tags":["BlogOS","移植"]},{"title":"Git 笔记","url":"/2021/07/09/Git-%E7%AC%94%E8%AE%B0/","content":"Git-Notes（GitHub地址）\n删除Commit(删除当前分支最新的一条Commit):\n 1) 本地删除Commit记录git reset --hard HEAD^2) 向远程仓库提交强制申请git push origin HEAD -f\n从其他远程仓库导入项目\n 1) 首先将导入仓库克隆到本地git clone &lt;gitUrl(导入仓库)&gt;2) cd 到该项目根目录3) 将该项目强制导入到被导入项目git push --mirror &lt;gitUrl(被导入仓库)&gt;\n导入其他仓库的Commit记录\n 1) cd 到被导入项目根目录2) 将该库加为远程仓库git remote add target &lt;gitUrl(导入仓库)&gt;3) 将远程代码抓取到本地git fetch target4) 使用cherry-pick命令提交转移git cherry-pick &lt;commitHash&gt;\n修改最新的一条Commit记录信息\n 1) cd 到被导入项目根目录2) git commit --amend3) 输入i进入插入模式4) 修改Commit记录信息5) 按Esc退出6) 输入:wq保存7) git push -f\n导入其他仓库的分支\n 1) cd 到被导入项目根目录2) 将该库加为远程仓库git remote add target &lt;gitUrl(导入仓库)&gt;3) 将远程代码抓取到本地git fetch target4) 切换到远程仓库对应分支git checkout &lt;对应分支名称&gt;5) 基于该分支创建本地分支git checkout -b &lt;本地分支名称&gt;6) 推送当前分支并建立与远程上游的跟踪git push --set-upstream origin &lt;本地分支名称&gt;\n修改历史Commit记录\n 1) 列出历史Commit列表(n为项数)git rebase -i HEAD~n2) 输入i进入插入模式3) 将被修改Commit前面的 &quot;pick&quot; 修改为 &quot;edit&quot;4) 按Esc退出5) 输入:wq保存6) git commit --amend7) 输入i进入插入模式8) 修改Commit记录信息9) 按Esc退出10) 输入:wq保存11) git rebase --continue12) git push -f\n修改历史Commit提交时间\n 1) 列出历史Commit列表(n为项数)git rebase -i HEAD~n2) 输入i进入插入模式3) 将被修改Commit前面的 &quot;pick&quot; 修改为 &quot;edit&quot;4) 按Esc退出5) 输入:wq保存6) GIT_COMMITTER_DATE=&quot;2021-04-29T11:00:00&quot; git commit --amend --date=&quot;2021-04-29T11:00:00&quot;7) 输入:wq保存8) git rebase --continue9) git push -f\n撤回上次Commit并保留修改的文件(在Commit时恢复上次Commit信息):\n 1) 撤回上次Commitgit reset --soft HEAD^2) Commit并恢复上次Commit信息git commit -C HEAD@&#123;1&#125;3) 向远程仓库提交强制申请git push origin HEAD -f\n\n","tags":["Git","GitHub","笔记"]},{"title":"GitLab搭建Hexo博客笔记","url":"/2021/07/24/GitLab%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/","content":"源起GitHub Page国内访问实在是太慢了！早就有了换地的想法，正好 B1ue1nWh1te 提醒了我， GitLab 和 Gitee 在国内的访问速度都不错，但是我实在不喜欢 Gitee 的UI，索性就换 GitLab 吧！\n一、在GitLab创建一个仓库如果你没有自己的域名，那么可以创建一个名为$&#123;你的GitLab ID&#125;.gitlab.io的仓库，比如我的ID是 Xayah ：\n\n那么我可以新建一个名为xayah.gitlab.io的仓库\n\n\n二、上传Hexo项目到仓库创建好后，我们先把仓库 Clone 下来，然后把 Hexo项目 放进去。public 文件夹是 Hexo 构建 静态页面 生成的，我们在服务器上不需要它，所以请检查你的.gitignore中是否忽略了/public，如果没有，请将其加入 忽略名单 。配置好后，将本地仓库 Push 到 GitLab 。\n&emsp;&emsp;&emsp;&emsp;●此处需要Git基础和Hexo基础，如果不会可以学习一下\n三、使用CI构建静态页面接下来，我们要利用 GitLab 的 CI 为我们 构建静态网页 了。在 Hexo项目根目录 新建一个名为.gitlab-ci.yml的文件，然后编辑该文件，复制并粘贴以下构建代码：\nimage: node:14-alpine # use nodejs v14 LTScache:  paths:    - node_modules/before_script:  - npm install hexo-cli -g  - npm installpages:  script:    - hexo generate  artifacts:    paths:      - public  only:    - master\n保存 后 Push 到仓库，正常情况下 GitLab CI 已经开始为我们进行 第一次构建 了，你可以在 仓库左侧 - CI/CD - Pipelines 里看到构建情况稍等片刻，正常情况下即可构建成功。\n\n那么此时访问$&#123;你的GitLab ID&#125;.gitlab.io就可以看到 构建成功 后的 博客页面 。\n\n\n以后每次在本地创建文章、修改文章，Push到远程仓库后GitLab CI将会自动为你构建，几分钟后即可生效。\n四、绑定域名如果购买了 自己的域名 ，那么可以在 仓库左侧 - Settings - Pages 配置自己的 域名 。\n\n点击右侧 New Domain 添加 域名 ，再根据提示在 域名提供商处 配置 DNS ，稍等片刻，访问 域名 ，即可访问 博客页面 。\n","tags":["GitHub","Hexo","GitLab"]},{"title":"Git交叉编译到Android平台","url":"/2021/08/02/Git%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%88%B0Android%E5%B9%B3%E5%8F%B0/","content":"前言这是一个很久之前的想法了，但是之前一直编译不成功。\n这两天仔细研究了下，证明还是可行的。\n\nAndroid NDK 版本：r23b\n编译环境：Ubuntu 20.04\nNDK目录：~/NDK\n\n步骤一、下载交叉编译所需源码想要交叉编译Git，需要先交叉编译Curl和Zlib，新版本的NDK已经包含预编译Zlib，所以我们只需要交叉编译Curl即可。\n至于为什么要交叉编译Curl，是因为git clone命令在clone https等仓库时，需要依赖该库创建的git-remote-https等EFL文件。否则，在clone时会发生找不到remote-https等错误。\n而若Curl依赖OpenSSL，因此还得先交叉编译OpenSSL。\n下载 Git 、 Curl 和 OpenSSL 的源码并解压。\n二、交叉编译OpenSSL并安装到NDK在OpenSSL官方仓库中，可以找到编译到Android平台的 文档 。导出NDK临时变量\nexport ANDROID_NDK_ROOT=~/NDK\n导出PATH临时变量\nexport PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$ANDROID_NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin:$PATH\n配置Makefile\n./Configure android-arm64 -D__ANDROID_API__=26 --prefix=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/sysroot\n编译\nmake -j128\n安装到prefix目录\nmake install -j128\n\n三、交叉编译Curl并安装到NDK打开Curl的源码，我们可以发现它提供了两种编译方式，Autoconf Makefile 和 Cmake。\n使用Autoconf Makefile方式可以编译带OpenSSL的Curl，但是由于某种未知原因，在后面在编译Git时无法识别。\n因此我们选择Cmake方式。\n在INSTALL.cmake中我们可以得到一些编译的信息：\nCurrent flaws in the curl CMake build=====================================   Missing features in the cmake build:   - Builds libcurl without large file support   - Does not support all SSL libraries (only OpenSSL, Schannel,     Secure Transport, and mbed TLS, NSS, WolfSSL)   - Doesn&#x27;t allow different resolver backends (no c-ares build support)   - No RTMP support built   - Doesn&#x27;t allow build curl and libcurl debug enabled   - Doesn&#x27;t allow a custom CA bundle path   - Doesn&#x27;t allow you to disable specific protocols from the build   - Doesn&#x27;t find or use krb4 or GSS   - Rebuilds test files too eagerly, but still can&#x27;t run the tests   - Doesn&#x27;t detect the correct strerror_r flavor when cross-compiling (issue #1123)\n\n由此可知，利用Cmake编译出来的Curl不带SSL库，但这并不影响我们后续编译Git和相应的git-remote-https等二进制文件。\ncd到解压后的Curl根目录，输入：\nmkdir out &amp;&amp; cd outexport NDK=~/NDK                     # NDK根目录绝对路径export ABI=arm64-v8a                           # ABI配置(arm64-v8a 即为 AArch64)export MINSDKVERSION=26                        # 最小目标SDK版本配置(26 即为 Android 8.0)cmake \\   -DCMAKE_TOOLCHAIN_FILE=$NDK/build/cmake/android.toolchain.cmake \\   -DANDROID_ABI=$ABI \\   -DANDROID_NATIVE_API_LEVEL=$MINSDKVERSION \\   -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot ..cmake --build . --config Releasemake install\n\n四、交叉编译Git接下来是我们的重头戏了。\n进入Git源码解压后的根目录，可以发现Git有两种编译方式，一是非Autoconf Makefile，二是Autoconf Makefile，前者我尝试过多次，皆以失败告终。所以这次我们尝试后者。\n我们的宿主机因为无法测试Android平台上的二进制文件，所以我们把测试代码删掉。\n进入configure.ac，删除：\n## Define FREAD_READS_DIRECTORIES if your are on a system which succeeds# when attempting to read from an fopen&#x27;ed directory.AC_CACHE_CHECK([whether system succeeds to read fopen&#x27;ed directory], [ac_cv_fread_reads_directories],[AC_RUN_IFELSE(\t[AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT],\t\t[[\t\tFILE *f = fopen(&quot;.&quot;, &quot;r&quot;);\t\treturn f != NULL;]])],\t[ac_cv_fread_reads_directories=no],\t[ac_cv_fread_reads_directories=yes])])if test $ac_cv_fread_reads_directories = yes; then\tFREAD_READS_DIRECTORIES=UnfortunatelyYeselse\tFREAD_READS_DIRECTORIES=fiGIT_CONF_SUBST([FREAD_READS_DIRECTORIES])\n再删除：\n## Define SNPRINTF_RETURNS_BOGUS if your are on a system which snprintf()# or vsnprintf() return -1 instead of number of characters which would# have been written to the final string if enough space had been available.AC_CACHE_CHECK([whether snprintf() and/or vsnprintf() return bogus value], [ac_cv_snprintf_returns_bogus],[AC_RUN_IFELSE(\t[AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT\t\t#include &quot;stdarg.h&quot;\t\tint test_vsnprintf(char *str, size_t maxsize, const char *format, ...)\t\t&#123;\t\t  int ret;\t\t  va_list ap;\t\t  va_start(ap, format);\t\t  ret = vsnprintf(str, maxsize, format, ap);\t\t  va_end(ap);\t\t  return ret;\t\t&#125;],\t\t[[char buf[6];\t\t  if (test_vsnprintf(buf, 3, &quot;%s&quot;, &quot;12345&quot;) != 5\t\t      || strcmp(buf, &quot;12&quot;)) return 1;\t\t  if (snprintf(buf, 3, &quot;%s&quot;, &quot;12345&quot;) != 5\t\t      || strcmp(buf, &quot;12&quot;)) return 1]])],\t[ac_cv_snprintf_returns_bogus=no],\t[ac_cv_snprintf_returns_bogus=yes])])if test $ac_cv_snprintf_returns_bogus = yes; then\tSNPRINTF_RETURNS_BOGUS=UnfortunatelyYeselse\tSNPRINTF_RETURNS_BOGUS=fiGIT_CONF_SUBST([SNPRINTF_RETURNS_BOGUS])\n\n观察源码结构，可以发现并没有configure文件，但存在configure.ac，所以我们可以make一个configure。\ncd到源码根目录，输入：\nmake configure\n\n此时即可生成configure。\ngit编译时会默认编译pthread，而Android由于性能及安全原因，放弃了glibc在其平台上的支持，所以相应地交叉编译链也不含有这个库。\nAndroid有其替代方案，所以我们在make时将NEEDS_LIBRT赋值为空从而不编译它即可。\nifdef NEEDS_LIBRT\tEXTLIBS += -lrtendif\n\n而在configure.ac中可以发现：\nAC_ARG_ENABLE([pthreads], [AS_HELP_STRING([--enable-pthreads=FLAGS],  [FLAGS is the value to pass to the compiler to enable POSIX Threads.]  [The default if FLAGS is not specified is to try first -pthread]  [and then -lpthread.]  [--disable-pthreads will disable threading.])],[if test &quot;x$enableval&quot; = &quot;xyes&quot;; then   AC_MSG_NOTICE([Will try -pthread then -lpthread to enable POSIX Threads])elif test &quot;x$enableval&quot; != &quot;xno&quot;; then   PTHREAD_CFLAGS=$enableval   AC_MSG_NOTICE([Setting &#x27;$PTHREAD_CFLAGS&#x27; as the FLAGS to enable POSIX Threads])else   AC_MSG_NOTICE([POSIX Threads will be disabled.])   NO_PTHREADS=YesPlease   USER_NOPTHREAD=1fi],[   AC_MSG_NOTICE([Will try -pthread then -lpthread to enable POSIX Threads.])])\n\n所以我们可以使用 –disable-pthreads 参数来取消编译 phread 相关部分。\n于是接下来我们输入以下命令\nexport NDK=~/NDK                                      # NDK根目录绝对路径export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64     # 交叉编译链路径export TARGET=aarch64-linux-android                             # 交叉编译目标export API=26                                                   # 最小目标SDK版本配置(26 即为 Android 8.0)export AR=$TOOLCHAIN/bin/llvm-arexport CC=$TOOLCHAIN/bin/$TARGET$API-clangexport AS=$CCexport CXX=$TOOLCHAIN/bin/$TARGET$API-clang++export LD=$TOOLCHAIN/bin/ldexport RANLIB=$TOOLCHAIN/bin/llvm-ranlibexport READELF=$TOOLCHAIN/bin/readelfexport STRIP=$TOOLCHAIN/bin/llvm-strip./configure --host=$TARGET --prefix=/data/local/tmp --disable-pthreads\n\n注意这里的--prefix，需要定义为Android环境下git运行目录，否则会出现找不到templates等问题。\n然后编译：\nmake NEEDS_LIBRT= NO_TCLTK=1 -j128\n\n注意这里的NO_TCLTK，如果不定义它的话，会默认编译git-gui，这不是我们需要的，所以将其定义为1。\n五、推送并测试先安装到宿主机~/git/install\nmake install NEEDS_LIBRT= NO_TCLTK=1 DESTDIR=~/git/install -j128\n可得如下产物\nxayah@xayah-virtual-machine:~/git/install/data/local/tmp$ lsbin  libexec  share\n将~/git/install/data/local/tmp 打包并推送到Android /data/local/tmp目录由于一些魔法因素，打包为zip竟足足有200M+！可能是因为压缩算法不同，打包为tar.xz就会小很多，大概10M左右。\nPS C:\\Users\\Xayah\\Desktop&gt; adb push git.zip /data/local/tmpgit.zip: 1 file pushed, 0 skipped. 38.1 MB/s (648532238 bytes in 16.219s)PS C:\\Users\\Xayah\\Desktop&gt; adb shellcas:/ $ cd /data/local/tmpcas:/data/local/tmp $ unzip git.zip &gt;/dev/nullcas:/data/local/tmp $ cd bincas:/data/local/tmp/bin $ lsgit  git-cvsserver  git-receive-pack  git-shell  git-upload-archive  git-upload-pack  gitk\n让我们git clone试试\ncas:/data/local/tmp/bin $ ./git clone https://github.com/git/git mGitCloning into &#x27;mGit&#x27;...remote: Enumerating objects: 311108, done.remote: Counting objects: 100% (72/72), done.remote: Compressing objects: 100% (32/32), done.remote: Total 311108 (delta 41), reused 70 (delta 40), pack-reused 311036Receiving objects: 100% (311108/311108), 164.19 MiB | 10.32 MiB/s, done.Resolving deltas: 100% (232238/232238), done.Segmentation fault\n\nSegmentation fault！这可是个头疼的事。不过没有关系，我们可以使用 gdbserver 调试，看看到底是哪里出了问题。\n首先将NDK中相应的gdbserver推送到Android平台，我的手机是aarch64（现在大多数安卓手机都是这个平台），也就是arm64，所以推送该文件夹下的gdbserver即可。\nadb push gdbserver /data/local/tmp/bin\n\n接下来新建一个终端并forward一个自定义端口：\nadb forward tcp:12345 tcp:12345\n\n接下来在另一个终端中进入adb shell：\n./gdbserver 0.0.0.0:12345 ./git clone https://github.com/git/git mGit\n\n现在gdbserver已经启动了，我们转向另一个终端，启动gdb：\n\n\n现在gdb和gdbserver均已启动，我们指定目标端口：\n\n\n输入c继续运行\n\n段错误出现了！可以看出错误是出在copy_gecos()这个函数。在源码中搜索这个函数，可以在ident.c中找到。定位至相应位置\n\n这个函数看起来貌似和git config有一丝关系，难道是因为我们没有定义git用户信息？让我们试试\n./git config --global user.name &quot;Xayah&quot;\n\n\n果然报错了！看来是.gitconfig没有创建成功，在源码中搜索.gitconfig，可以发现git获取.gitconfig的路径是$HOME/.gitconfig\n那么我们试试把$HOME定义为当前目录\nexport HOME=/data/local/tmp/bin\n再配置用户信息\n./git config --global user.name &quot;Xayah&quot;./git config --global user.email zds1249475336@gmail.com\n这次没有报错了，并且当前目录也成功生成了.gitconfig\n\n\n这次我们再试试git clone\n./git clone https://github.com/git/git mGit\n\n\n成功！\n","tags":["Android","Git","交叉编译"]},{"title":"Golang+Gin+Gorm后端开发学习笔记","url":"/2021/08/18/Golang-Gin-Gorm%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前言早已久仰Golang大名，以其优异的高并发支持著称。那么让我们来一探究竟吧！\n安装及配置Golang的安装及环境配置在Golang官网下载并安装，目前较新的版本都能够自动配置环境变量。\n但我们还需要配置一下Goproxy代理，以解决当前国内网络环境所带来的问题。\n这里我推荐goproxy.io，那么我们就跟着它的文档配置吧。\n1. 右键 我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量2. 在 “[你的用户名]的用户变量” 中点击 ”新建“ 按钮3. 在 “变量名” 输入框并新增 “GOPROXY”4. 在对应的 “变量值” 输入框中新增 “https://goproxy.io,direct”5. 最后点击 “确定” 按钮保存设置\n\nGoLand的安装工欲善其事，必先利其器。优秀的IDE能让我们开发效率直线上升。JetBrains系列的IDE深受大众喜爱。这里我们选择GoLand作为开发工具\n下载GoLand并安装。\n运行第一个项目打开GoLand，新建一个工程，取名为HelloWorld，然后创建项目。\n\n\nGin依赖的安装既然我们使用Gin框架来开发后端，那么肯定要先安装它打开GoLand的终端（在项目根目录下打开系统终端也行），安装Gin-Gonic依赖\ngo get -u github.com/gin-gonic/gin\n稍等片刻即可安装成功。\n创建HelloWorld接下来我们创建一个Go文件，取名为HelloWorld.go。键入以下代码：\npackage HelloWorldimport (\t&quot;github.com/gin-gonic/gin&quot;\t&quot;net/http&quot;)func main() &#123;\tr := gin.Default()\tr.GET(&quot;/&quot;, func(context *gin.Context) &#123;\t\tcontext.String(http.StatusOK, &quot;Hello World!&quot;)\t&#125;)\tr.Run(&quot;:8080&quot;)&#125;\n配置编译器点击GoLand右上方Add Configuration…\n\n在弹出的窗口中点击左边的+号，选择Go Build，然后点击OK。\n\n接下来我们点击IDE右上角绿色的右三角按钮运行。\n\n报错了，查询一通资料后才发现，当我们只编译运行单文件时，包名必须为main，因此，我们修改代码：\npackage mainimport (\t&quot;github.com/gin-gonic/gin&quot;\t&quot;net/http&quot;)func main() &#123;\tr := gin.Default()\tr.GET(&quot;/&quot;, func(context *gin.Context) &#123;\t\tcontext.String(http.StatusOK, &quot;Hello World!&quot;)\t&#125;)\tr.Run(&quot;:8080&quot;)&#125;\n这下能够成功运行了。我们打开浏览器，输入http://localhost:8080/，即可看到项目正确运行。\n\n\nGorm(Sqlite3)笔记定义数据库结构体\ntype Doc struct &#123;\tgorm.Model\tType  string\tTitle string\tDate  string&#125;\n创建数据库并添加一条记录\nfunc main() &#123;\tdb, err := gorm.Open(sqlite.Open(&quot;doc.db&quot;), &amp;gorm.Config&#123;&#125;)\tif err != nil &#123;\t\tpanic(&quot;failed to connect database&quot;)\t&#125;\t// 迁移 schema\tdb.AutoMigrate(&amp;Doc&#123;&#125;)\t// 添加一条记录\tdb.Create(&amp;Doc&#123;\t\tType:  &quot;文件学习&quot;,\t\tTitle: &quot;打响疫情第二波湖南必胜&quot;,\t\tDate:  &quot;2021.08.18&quot;,\t&#125;)&#125;\n运行后，会在源码根目录创建doc.db，并且写入一条记录\n\n\n\n\nGin笔记定义标记常量const (\tJSON_SUCCESS int = 1\tJSON_ERROR   int = 0)\n定义数据库结构体和返回结构体type Doc struct &#123;\tgorm.Model\tType  string\tTitle string\tDate  string&#125;type rDoc struct &#123;\tType  string\tTitle string\tDate  string&#125;\n路由分组v1 := r.Group(&quot;/api/v1/docs&quot;)&#123;\tv1.POST(&quot;/add&quot;, add)\tv1.GET(&quot;/get&quot;, get)&#125;\n添加记录函数func add(c *gin.Context) &#123;\tdb, err := gorm.Open(sqlite.Open(&quot;doc.db&quot;), &amp;gorm.Config&#123;&#125;)\tif err != nil &#123;\t\tpanic(&quot;failed to connect database&quot;)\t&#125;\tdb.AutoMigrate(&amp;Doc&#123;&#125;)\tdb.Create(&amp;Doc&#123;\t\tType:  &quot;文件学习&quot;,\t\tTitle: &quot;打响疫情第二波湖南必胜&quot;,\t\tDate:  &quot;2021.08.18&quot;,\t&#125;)\tc.JSON(http.StatusOK, gin.H&#123;\t\t&quot;status&quot;:  JSON_SUCCESS,\t\t&quot;message&quot;: &quot;创建成功&quot;,\t&#125;)&#125;\n获取记录函数func get(c *gin.Context) &#123;\tdb, err := gorm.Open(sqlite.Open(&quot;doc.db&quot;), &amp;gorm.Config&#123;&#125;)\tif err != nil &#123;\t\tpanic(&quot;failed to connect database&quot;)\t&#125;\tvar docs []Doc\tvar rdocs []rDoc\tdb.Find(&amp;docs)\tfor _, i := range docs &#123;\t\trdocs = append(rdocs, rDoc&#123;\t\t\tType:  i.Type,\t\t\tTitle: i.Title,\t\t\tDate:  i.Date,\t\t&#125;)\t&#125;\tc.JSON(http.StatusOK, gin.H&#123;\t\t&quot;status&quot;:  JSON_SUCCESS,\t\t&quot;message&quot;: &amp;rdocs,\t&#125;)&#125;\n实现实例：package mainimport (\t&quot;github.com/gin-gonic/gin&quot;\t&quot;gorm.io/driver/sqlite&quot;\t&quot;gorm.io/gorm&quot;\t&quot;net/http&quot;)const (\tJSON_SUCCESS int = 1\tJSON_ERROR   int = 0)type Doc struct &#123;\tgorm.Model\tType  string\tTitle string\tDate  string&#125;type rDoc struct &#123;\tType  string\tTitle string\tDate  string&#125;func main() &#123;\tr := gin.Default()\tr.GET(&quot;/&quot;)\tv1 := r.Group(&quot;/api/v1/docs&quot;)\t&#123;\t\tv1.POST(&quot;/add&quot;, add)\t\tv1.GET(&quot;/get&quot;, get)\t&#125;\tr.Run()&#125;func add(c *gin.Context) &#123;\tdb, err := gorm.Open(sqlite.Open(&quot;doc.db&quot;), &amp;gorm.Config&#123;&#125;)\tif err != nil &#123;\t\tpanic(&quot;failed to connect database&quot;)\t&#125;\tdb.AutoMigrate(&amp;Doc&#123;&#125;)\tdb.Create(&amp;Doc&#123;\t\tType:  &quot;文件学习&quot;,\t\tTitle: &quot;打响疫情第二波湖南必胜&quot;,\t\tDate:  &quot;2021.08.18&quot;,\t&#125;)\tc.JSON(http.StatusOK, gin.H&#123;\t\t&quot;status&quot;:  JSON_SUCCESS,\t\t&quot;message&quot;: &quot;创建成功&quot;,\t&#125;)&#125;func get(c *gin.Context) &#123;\tdb, err := gorm.Open(sqlite.Open(&quot;doc.db&quot;), &amp;gorm.Config&#123;&#125;)\tif err != nil &#123;\t\tpanic(&quot;failed to connect database&quot;)\t&#125;\tvar docs []Doc\tvar rdocs []rDoc\tdb.Find(&amp;docs)\tfor _, i := range docs &#123;\t\trdocs = append(rdocs, rDoc&#123;\t\t\tType:  i.Type,\t\t\tTitle: i.Title,\t\t\tDate:  i.Date,\t\t&#125;)\t&#125;\tc.JSON(http.StatusOK, gin.H&#123;\t\t&quot;status&quot;:  JSON_SUCCESS,\t\t&quot;message&quot;: &amp;rdocs,\t&#125;)&#125;\n测试API","tags":["Golang","Gin","Gorm"]},{"title":"Hexo添加自定义静态页面","url":"/2021/07/08/Hexo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/","content":"具体步骤\n将静态页面源码 （以 unlock-music文件夹 为例） 放入 Hexo项目根目录 下的 source 文件夹\n修改 Hexo项目根目录 下的 _config.yml:skip_render: /unlock-music**\n重新部署：# 本地部署hexo ghexo s \n# 上行部署hexo g -d\n访问静态页面（以 AcmeZone 为例）：http://acmezone.top/unlock-music/\n\n","tags":["Hexo","HTML","CSS"]},{"title":"PyTorch + OpenVINO™ 深度学习笔记","url":"/2022/03/22/PyTorch-OpenVINO%E2%84%A2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"一、前言PyTorch是开源的深度学习框架，目的是加速从研究原型到产品开发的过程。其SDK主要基于Python。而其模型训练支持CPU与GPU、支持分布式训练、云部署，针对深度学习特定领域有不同的丰富的扩展库。\n深度学习项目的开发大致可以分为两个阶段：\n\n第一个阶段是训练阶段。这个阶段最重要的事情就是数据采集、模型设计、训练参数调试，找到合适的模型并努力训练到满足或者超过项目实际需要的精度。\n第二个阶段是部署阶段。这个阶段最重要的事情就是把模型移植部署到各种不同的计算设备上，尽可能地实现模型规模的小型化、推理预测过程的加速。\n\n相比于PyTorch、TensorFlow等为开发者所熟知的训练框架，推理部署的框架却显得有些默默无闻，但是它在深度学习模型落地过程中发挥着不可替代的作用。正是在这样的背景之下，英特尔在2018年发布了专门针对CPU、iGPU(集成显卡)、FPGA、ARM等硬件单元加速的模型部署与加速推理框架OpenVINO™。\nOpenVINO™是英特尔发布的一套支持快速开发视觉、语音识别、自然语言处理应用的框架，受益于人工智能技术的快速发展，框架采用了最新的人工智能神经网络包括卷积神经网络、循环神经网络、注意力机制网络等模型。实现视觉与非视觉任务的底层硬件加速、达到最佳性能，支持人工智能应用从云端到边缘的部署与推理全链路技术。\n二、PyTorch1. 安装建议使用 Conda 安装 PyTorch ，本篇笔记也将以Conda安装方式为例。笔者的环境是Windows11 + Anaconda + CUDA11.6，而Linux或Mac平台的环境配置大同小异，这里就不过多赘述。\n1) CUDA版本以CUDA11+为例，首先需要安装CUDA驱动安装完成后，检测安装版本\nnvidia-smi\n\n\n安装CUDA版本conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch\n\n2) CPU版本若没有NVIDIA系显卡或其不支持CUDA加速，则可选择安装仅CPU版本。\n\n安装仅CPU版本conda install pytorch torchvision torchaudio cpuonly -c pytorch\n\n2. 检验在终端进入Python3控制台（笔者python命令默认链接到Python3）\npython\n导入PyTorch\nimport torch\n测试torch.rand()函数\ntorch.rand(5, 3)\n若安装成功，则会出现类似于以下的输出\n\n测试是否支持CUDA\nimport torchtorch.cuda.is_available()\n\n\n3. 概念很多人学习深度学习框架面临的第一个问题就是其专业术语跟基本的编程概念与传统面向对象编程不同，这是初学者面临的第一个学习障碍。\n在主流的面向对象编程语言中，结构化代码最常见的关键字是if、else、while、for等关键字，而在深度学习框架中编程模式主要是基于计算图、张量数据、自动微分、优化器等组件构成。\n面向对象编程运行的结果是交互式可视化的，而深度学习通过训练模型生成模型文件，然后再使用模型预测、本质数据流图的方式工作。所以学习深度学习框架首先必须理清深度学习编程中计算图、张量数据、自动微分、优化器这些基本术语概念，下面分别解释如下：\n1) 张量张量(Tensor)是深度学习框架中需要理解的最重要的一个概念，张量的本质是数据，在深度学习框架中一切的数据都可以看成张量。\n深度学习中的计算图是以张量数据为输入，通过算子运算，实现对整个计算图参数的评估优化。但是到底什么是张量？可以看下面这张图：\n\n上图中标量、向量、数组、3D、4D、5D数据矩阵在深度学习框架中都被称为张量。可见在深度学习框架中所有的数据都是张量形式存在，张量是深度学习数据组织与存在一种数据类型。\n2) 算子/操作数深度学习主要是针对张量的数据操作。这些数据操作从简单到复杂，多数都是以矩阵计算的形式存在。最常见的矩阵操作就是加减乘除，此外卷积、池化、激活也是模型构建中非常有用的算子/操作数。Pytorch支持自定义算子操作，可以通过自定义算子实现复杂的网络结构，构建一些特殊的网络模型。张量跟算子/操作数一起构成了计算图，它们是也是计算图的基本组成要素。\n3) 计算图深度学习基于计算图完成模型构建，实现数据在各个计算图节点之间流动，最终输出。因此计算图又被称为数据流图。\n根据构建计算图的方式不同还可以分为静态图与动态图。Pytorch默认是基于动态图的方式构建计算图。\n动态图采用类似Python语法，可以随时运行，灵活修改调整。\n而静态图则是效率优先，但是在图构建完成之前无法直接运行。\n可以看出动态图更加趋向于开发者平时接触的面向对象的编程方式，也更容易被开发者理解与接受。\n下图是一个简单的计算图示例：\n\n图中最底层三个节点表示计算图的输入张量数据节点（a、b、c），剩下节点表示操作，带箭头的线段表示数据的流向。\n4) 自动微分使用Pytorch构建神经网络（计算图）模型之后，一般都是通过反向传播进行训练，反向传播算法使用损失函数功能对神经网络中每个参数根据梯度进行参数值的调整。\n为了计算这些梯度完成参数调整，深度学习框架中都会自带一个叫做自动微分的内置模块，来自动计算神经网络模型训练时的各个参数梯度值并完成参数值更新，这种技术就是深度学习框架中的自动微分。\n4. PyTorch基础操作1) 张量的定义与声明张量在PyTorch深度学习框架中表示数据，有几种不同的方式来创建与声明张量数据。\na. 常量声明import torcha = torch.tensor([[2., 3.], [4., 5.]])print(a, a.dtype)\n输出\ntensor([[2., 3.],        [4., 5.]]) torch.float32\n其中torch.tensor()默认的数据类型是flaot32，这点从a.dtype的打印结果上也得了印证。\nb. 转换声明torch.tensor函数支持从NumPy数组直接转换为张量数据。\nimport numpy as npimport torcha = torch.tensor(np.array([[1, 2], [3, 4], [5, 6], [7, 8]]))print(a, a.dtype)\n输出\ntensor([[1, 2],        [3, 4],        [5, 6],        [7, 8]], dtype=torch.int32) torch.int32\n函数返回的数据类型将会根据NumPy数组自动识别。\nc. 初始化声明PyTorch框架支持类似MATLAB的数组初始化方式，可以定义数组的维度，然后初始化为零。\nimport torcha = torch.zeros([2, 4], dtype=torch.float32)print(a, a.dtype)\n输出\ntensor([[0., 0., 0., 0.],        [0., 0., 0., 0.]]) torch.float32\n可使用torch.ones()函数初始化为1\nimport torcha = torch.ones([2, 4], dtype=torch.float32)print(a, a.dtype)\n输出\ntensor([[1., 1., 1., 1.],        [1., 1., 1., 1.]]) torch.float32\n\nd. 随机初始化声明在实际的开发中，经常需要随机初始化一些张量，可通过torch.rand()等函数实现\nimport torchv1 = torch.rand((2, 3))  # 数组大小: 2x3print(\"v1: \", v1)torch.initial_seed()  # 随机初始化种子v2 = torch.rand((2, 3))  # 数组大小: 2x3print(\"v2: \", v2)v3 = torch.randint(0, 255, (4, 4))  # 随机范围: 0~255, 数组大小: 4x4print(\"v3: \", v3)\n输出\nv1:  tensor([[0.6751, 0.0717, 0.4391],        [0.8088, 0.1570, 0.1111]])v2:  tensor([[0.4927, 0.1516, 0.3794],        [0.9748, 0.6124, 0.1192]])v3:  tensor([[ 60,  88,  33,  53],        [193, 155,  76, 148],        [ 86,  47, 177, 192],        [ 65, 247, 252, 145]])\n\n2) 张量的操作a. 计算图操作\n以上图为例，用代码将它实现出来：\nimport torcha = torch.tensor([[2., 3.], [4., 5.]])b = torch.tensor([[10, 20], [30, 40]])c = torch.tensor([[0.1], [0.2]])x = a + by = torch.matmul(x, c)print(\"y: \", y)\n输出\ny:  tensor([[ 5.8000],        [12.4000]])\n\nb. 数据类型转换可用如下代码进行常见的数据类型转换：\nimport torchm = torch.tensor([1., 2., 3., 4., 5., 6], dtype=torch.float32)print(m, m.dtype)  # 原类型为float32print(m.double(), m.double().dtype)  # 转换为float64print(m.int(), m.int().dtype)  # 转换为int32print(m.long(), m.long().dtype)  # 转换为int64\n输出\ntensor([1., 2., 3., 4., 5., 6.]) torch.float32tensor([1., 2., 3., 4., 5., 6.], dtype=torch.float64) torch.float64tensor([1, 2, 3, 4, 5, 6], dtype=torch.int32) torch.int32tensor([1, 2, 3, 4, 5, 6]) torch.int64\n\nc. 维度转换可用如下代码进行常见的维度转换：\nimport torcha = torch.arange(12.)  # 创建一个(0)~(12-1)区间顺序增长的一维张量print(\"a: \", a)b = torch.reshape(a, (3, 4))  # 转换为3x4print(\"b: \", b)c = torch.reshape(a, (-1, 6))  # 转换为?x6, ?从列数6推理得到print(\"c: \", c)d = torch.reshape(a, (-1,))  # 转换为1行print(\"d: \", d)e = torch.reshape(a, (1, 1, 3, 4))  # 转换为1x1x3x4print(\"e: \", e)\n输出\na:  tensor([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])b:  tensor([[ 0.,  1.,  2.,  3.],        [ 4.,  5.,  6.,  7.],        [ 8.,  9., 10., 11.]])c:  tensor([[ 0.,  1.,  2.,  3.,  4.,  5.],        [ 6.,  7.,  8.,  9., 10., 11.]])d:  tensor([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])e:  tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.]]]])\n除此之外，还可以使用基于tensor的维度转换函数tensor.view()\nimport torcha = torch.arange(12.)  # 创建一个(0)~(12-1)区间顺序增长的一维张量print(\"a: \", a)b = a.view(3, 4)  # 转换为3x4print(\"b: \", b)c = a.view(-1, 6)  # 转换为?x6, ?从列数6推理得到print(\"c: \", c)d = a.view(-1, )  # 转换为1行print(\"d: \", d)e = a.view(1, 1, 3, 4)  # 转换为1x1x3x4print(\"e: \", e)\n输出\na:  tensor([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])b:  tensor([[ 0.,  1.,  2.,  3.],        [ 4.,  5.,  6.,  7.],        [ 8.,  9., 10., 11.]])c:  tensor([[ 0.,  1.,  2.,  3.,  4.,  5.],        [ 6.,  7.,  8.,  9., 10., 11.]])d:  tensor([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])e:  tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.]]]])\n\nd. 通道交换通道交换是PyTorch中处理张量数据常用操作之一。\nimport torchx = torch.randn(3, 4, 5)  # 随机生成3x4x5的张量print(\"x: \", x)print(\"Size of x: \", x.size())y = x.transpose(0, 1)  # 对x的0维和1维进行交换(类似于转置)print(\"y: \", y)print(\"Size of y: \", y.size())\n输出\nx:  tensor([[[-0.9932, -2.1915, -0.8266, -1.8298,  0.5624],         [ 0.2394, -0.3014,  0.3355,  0.9116,  1.1046],         [-0.2292, -0.2218, -0.8415, -1.7220, -0.5911],         [-0.0927, -0.2388,  0.3639, -2.3732, -0.7759]],        [[ 0.0079, -0.1990, -0.9282,  1.2543, -0.7065],         [-0.5910,  0.5737, -1.9680,  0.8392,  0.4500],         [ 0.8449,  1.4641, -0.4619, -0.3084,  0.0082],         [ 0.2436,  0.1285, -0.1126,  1.7058,  0.5177]],        [[-1.4615, -1.5110,  0.3243,  0.5885,  0.2760],         [-0.4879, -1.6806, -0.3202, -2.1921,  1.8557],         [-1.3212, -0.0511, -0.8245,  1.1485, -0.6952],         [-0.0165, -0.2692,  0.3099, -0.1915, -0.3242]]])Size of x:  torch.Size([3, 4, 5])y:  tensor([[[-0.9932, -2.1915, -0.8266, -1.8298,  0.5624],         [ 0.0079, -0.1990, -0.9282,  1.2543, -0.7065],         [-1.4615, -1.5110,  0.3243,  0.5885,  0.2760]],        [[ 0.2394, -0.3014,  0.3355,  0.9116,  1.1046],         [-0.5910,  0.5737, -1.9680,  0.8392,  0.4500],         [-0.4879, -1.6806, -0.3202, -2.1921,  1.8557]],        [[-0.2292, -0.2218, -0.8415, -1.7220, -0.5911],         [ 0.8449,  1.4641, -0.4619, -0.3084,  0.0082],         [-1.3212, -0.0511, -0.8245,  1.1485, -0.6952]],        [[-0.0927, -0.2388,  0.3639, -2.3732, -0.7759],         [ 0.2436,  0.1285, -0.1126,  1.7058,  0.5177],         [-0.0165, -0.2692,  0.3099, -0.1915, -0.3242]]])Size of y:  torch.Size([4, 3, 5])\n\ne. 寻找最大值寻找最大值是PyTorch中处理张量数据常用操作之一。\nimport torchx = torch.tensor([2., 3., 4., 12., 3., 5., 8., 1.])print(\"x: \", x)print(\"Max of x: \", torch.argmax(x))  # 求x的最大值索引y = x.view(-1, 2)print(\"y: \", y)print(\"Max of y: \", torch.argmax(y))  # 求x的最大值索引(展开为1维)print(\"Max of y: \", torch.argmax(y, 0))  # 求x的0维最大值索引print(\"Max of y: \", torch.argmax(y, 1))  # 求x的1维最大值索引print(\"Max of y: \", y.argmax())  # 求x的最大值索引(展开为1维)print(\"Max of y: \", y.argmax(0))  # 求x的0维最大值索引print(\"Max of y: \", y.argmax(1))  # 求x的1维最大值索引\n输出\nx:  tensor([ 2.,  3.,  4., 12.,  3.,  5.,  8.,  1.])Max of x:  tensor(3)y:  tensor([[ 2.,  3.],        [ 4., 12.],        [ 3.,  5.],        [ 8.,  1.]])Max of y:  tensor(3)Max of y:  tensor([3, 1])Max of y:  tensor([1, 1, 1, 0])Max of y:  tensor(3)Max of y:  tensor([3, 1])Max of y:  tensor([1, 1, 1, 0])\n\nf. CPU与GPU运算支持PyTorch支持CPU与GPU计算，默认创建的tensor是CPU版本的，要想使用GPU版本，首先需要检测GPU支持，然后转换为GPU数据，或者直接创建为GPU版本数据\nimport torchgpu = torch.cuda.is_available()for i in range(torch.cuda.device_count()):    print(\"name: \", torch.cuda.get_device_name(i))    x = torch.randn(2, 3)    if gpu:        print(\"x: \", x)        print(\"x.device: \", x.device)        print(\"x.cuda(): \", x.cuda())        print(\"x.cuda().device: \", x.cuda().device)    y = torch.tensor([1, 2, 3, 4], device=\"cuda:0\")    print(\"y: \", y)\n输出\nname:  NVIDIA GeForce RTX 2060x:  tensor([[-0.1489, -1.4650,  0.3720],        [ 0.8687,  0.0330, -0.4909]])x.device:  cpux.cuda():  tensor([[-0.1489, -1.4650,  0.3720],        [ 0.8687,  0.0330, -0.4909]], device='cuda:0')x.cuda().device:  cuda:0y:  tensor([1, 2, 3, 4], device='cuda:0')\n\n5. 线性回归预测线性回归的本质就是根据给出二维数据集来拟合生成一条直线，如下图：\n\n左图是一组圆点表示的二维坐标点数据集，直线是根据线性回归算法生成的。右图则是根据坐标点数据集生成的一个非线性回归例子。现在我们已经可以很直观地了解什么是线性回归了，但线性回归是怎么找到这条直线的？我们可以通过PyTorch构建一个简单的计算图来不断学习，最终得到一个足够逼近真实直线的参数方程，这个过程被称为线性回归的学习/训练过程。\n1) 原理最常见的直线方程如下：\n假设有一组二维坐标点数据集：\n\n\n\n\n一\n二\n三\n四\n五\n六\n\n\n\nx\n1\n2\n0.5\n2.5\n2.6\n3.1\n\n\ny\n3.7\n4.6\n1.65\n5.68\n5.98\n6.95\n\n\n随机赋值初始k、b两个参数，根据直线方程，通过x可以得到对应的，它跟 真实值y 之间的差值称为损失，最常见的损失是均值平方损失（MSE），表示如下：假设当前参数为A(k, b)，新参数为B(k, b)，我们可以通过下面的公式来更新k、b两个参数：其中η称为学习率，grad(η)是对应的参数梯度，可根据深度学习框架的自动微分机制得到。这样就实现了线性回归模型的构建与训练过程，最终可根据输入的迭代次数运行并输出回归直线的两个参数，从而完成线性回归的求解。\n2) 实现PyTorch提供了丰富的函数，可以帮助我们快速搭建线性回归模型并完成训练预测。\na. 构建数据集import numpy as npx = np.array([1, 2, 0.5, 2.5, 2.6, 3.1], dtype=np.float32).reshape((-1, 1))y = np.array([3.7, 4.6, 1.65, 5.68, 5.98, 6.95], dtype=np.float32).reshape(-1, 1)\nb. 构建线性回归模型# 继承torch.nn.Moduleclass LinearRegressionModel(torch.nn.Module):    def __init__(self, input_dim, output_dim):        super(LinearRegressionModel, self).__init__()        self.linear = torch.nn.Linear(input_dim, output_dim)  # 对应直线方程y = kx + b    def forward(self, x):        return self.linear(x)  # 重载forward(), 根据模型计算并返回预测结果\n\nc. 创建损失功能与优化器data_input_dim = 1  # 输入维度为1data_output_dim = 1  # 输出维度为1model = LinearRegressionModel(data_input_dim, data_output_dim)  # 实例化criterion = torch.nn.MSELoss()  # 均值平方损失learning_rate = 0.01  # 学习率optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)  # 优化器, 求解参数梯度\n\nd. 迭代训练# 迭代训练for index in range(100):    # 将NumPy数组转为torch变量    input_x = torch.from_numpy(data_x).requires_grad_()  # 需要为其计算梯度    input_y = torch.from_numpy(data_y)    optimizer.zero_grad()  # 梯度置零    output_y = model(input_x)  # 得到输出    loss = criterion(output_y, input_y)  # 计算损失    loss.backward()  # 计算梯度，反向传播    optimizer.step()  # 更新参数    print('迭代索引: {}, 损失: {}'.format(index, loss.item()))\n\ne. 绘制结果predicted_y = model(torch.from_numpy(data_x).requires_grad_()).data.numpy()  # 得到预测结果plt.plot(data_x, data_y, 'go', label='True data', alpha=0.5)  # 绘制数据集plt.plot(data_x, predicted_y, '--', label='Predictions', alpha=0.5)  # 绘制回归直线plt.legend()plt.show()\n最终完整代码为：\nimport numpy as npimport torchfrom matplotlib import pyplot as pltdata_x = np.array([1, 2, 0.5, 2.5, 2.6, 3.1], dtype=np.float32).reshape((-1, 1))data_y = np.array([3.7, 4.6, 1.65, 5.68, 5.98, 6.95], dtype=np.float32).reshape(-1, 1)# 继承torch.nn.Moduleclass LinearRegressionModel(torch.nn.Module):    def __init__(self, input_dim, output_dim):        super(LinearRegressionModel, self).__init__()        self.linear = torch.nn.Linear(input_dim, output_dim)  # 对应直线方程y = kx + b    def forward(self, x):        return self.linear(x)  # 重载forward(), 根据模型计算并返回预测结果data_input_dim = 1  # 输入维度为1data_output_dim = 1  # 输出维度为1model = LinearRegressionModel(data_input_dim, data_output_dim)  # 实例化criterion = torch.nn.MSELoss()  # 均值平方损失learning_rate = 0.01  # 学习率optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)  # 优化器, 求解参数梯度# 迭代训练for index in range(100):    # 将NumPy数组转为torch变量    input_x = torch.from_numpy(data_x).requires_grad_()  # 需要为其计算梯度    input_y = torch.from_numpy(data_y)    optimizer.zero_grad()  # 梯度置零    output_y = model(input_x)  # 得到输出    loss = criterion(output_y, input_y)  # 计算损失    loss.backward()  # 计算梯度，反向传播    optimizer.step()  # 更新参数    print('迭代索引: {}, 损失: {}'.format(index, loss.item()))predicted_y = model(torch.from_numpy(data_x).requires_grad_()).data.numpy()  # 得到预测结果plt.plot(data_x, data_y, 'go', label='True data', alpha=0.5)  # 绘制数据集plt.plot(data_x, predicted_y, '--', label='Predictions', alpha=0.5)  # 绘制回归直线plt.legend()plt.show()\n\n最终得到：\n\n\n三、OpenVINO™1. 概念OpenVINO™ ToolKit主要功能包含：\n\n支持边缘卷积神经网络的推理加速\n支持在英特尔CPU、HD卡、NCS2、FPGA等设备上的混合执行/异构计算执行\n通过大量的预训练模型库做到加速从产品原型到市场化的过程\n支持传统的计算机视觉标准库，包括OpenCV、OpenCL等\n\n人工智能应用/模型的开发在第二阶段模型部署中，可以借助OpenVINO™ ToolKit的压缩量化、推理加速能力达到模型推理时的最佳性能（速度与精度）。相比第一阶段，第二阶段更为重要，它决定模型最终是否可以实现商业目标，带来商业价值。英特尔发布的开源版本OpenVINO™ ToolKit支持从云端到边缘的模型部署，通过自身人工智能技术优势着力解决人工智能落地环节的商业痛点。\n\n上图中矩形框内的部分是OpenVINO™的核心功能。矩形框外表示第三方提供的模型与上层应用。\n2. 功能与组件深度学习模型优化器（Deep Learning Model Optimizer）跨平台的命令行工具包，支持导入来自主流的深度学习框架的模型，模型文件可能由TensorFlow、PyTorch、Caffe、MXNet、ONNX等深度学习框架与工具生成。模型优化器支持对导入模型的转换、优化、导出。\n深度学习推理引擎（Deep Learning Inference Engine）一个统一的API接口层，支持对深度学习模型的高效推理，支持跨操作系统、多种底层硬件的异构模式推理计算，这些硬件包括Intel CPU、Intel集成显卡、NCS2计算棒、VPU、FPGA等。\n推理引擎样例（Inference Engine Sample）一系列的示例代码文件，通过控制台运行演示如何在第三方应用中集成推理引擎开发。\n深度学习工作台（Deep Learning Workbench）一个基于WEB端的智能化图形交互界面，允许你更加灵活地尝试OpenVINO™提供各种组件功能。\n后训练优化工具（Post-Training Optimization Tool）一个验证与执行量化INT8精度的工具，此功能包含在模型优化器命令行文件夹下面。\n开放的模型库（Open Model Zoo）OMZ主要有两个部分。第一部分是Demos教程，主要包括Python与C++的SDK教程，教程主要涉及计算机视觉与语音识别相关的内容。第二部分是模型，包含Intel提供与其它公开支持OpenVINO™部署推理的模型，总数超过240+，对于很多常见的视觉任务都无需再训练模型，直接使用模型再通过推理引擎部署即可。需要注意的是public（非Intel提供）部分的模型，需要开发者自己转换为IR格式中间文件，才能通过推理引擎部署调用。\nOpenCV组件OpenVINO™ ToolKit在支持深度学习模型部署的同时，还把OpenCV作为支持传统视觉算法处理的组件，集成到了OpenVINO™ ToolKit中，因而可以自动获取OpenCV框架的支持，这对熟悉OpenCV框架的开发者来说是一个大大的福利！并且OpenVINO™提供的官方教程中，图像预处理与推理引擎输出的后处理，图像与图形绘制等均采用了OpenCV相关函数完成，对大多数OpenCV开发者来说看这些代码毫无违和感。\n3. 安装打开Intel® Distribution of OpenVINO™ Toolkit\n\n如上图，由于后续基本上采用Python开发，所以我们选择PIP的方式安装\n\n选择PyTorch框架，得到如下安装代码：\npip install openvino-dev[pytorch]==2022.1.0\n\n未完待续…\n四、参考\nPyTorch + OpenVINO™ 开发实战系列教程 第一篇\nPyTorch + OpenVINO™ 开发实战系列教程 第二篇\n\n","tags":["PyTorch","OpenVINO","深度学习"]},{"title":"Python3.9交叉编译到Android平台","url":"/2021/08/01/Python3-9%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%88%B0Android%E5%B9%B3%E5%8F%B0/","content":"前言手机上也能运行Python？当然，我们只需要将其交叉编译到Android平台就可以了！\n本次笔记将使用NDK的交叉编译链，为AArch64平台交叉编译Python3.9。\n\nAndroid NDK 版本：r21e\n编译环境：Ubuntu 21.04\n\n步骤一、下载交叉编译所需源码Python3.9\n二、交叉编译Python3.9解压Python3.9的源码\n然后在根目录输入以下指令：\nexport NDK=/home/xayah/NDK                              # NDK根目录绝对路径export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64     # 交叉编译链路径export TARGET=aarch64-linux-android                             # 交叉编译目标export API=24                                                   # 最小目标SDK版本配置(24 即为 Android 7.0)export AR=$TOOLCHAIN/bin/llvm-arexport CC=$TOOLCHAIN/bin/$TARGET$API-clangexport AS=$CCexport CXX=$TOOLCHAIN/bin/$TARGET$API-clang++export LD=$TOOLCHAIN/bin/ldexport RANLIB=$TOOLCHAIN/bin/llvm-ranlibexport STRIP=$TOOLCHAIN/bin/llvm-strip./configure --host=$TARGET --build=aarch64 --disable-ipv6 ac_cv_file__dev_ptmx=no ac_cv_file__dev_ptc=no --prefix=/home/xayah/py/install\n\n然而，我们遇到了一个错误：\nconfigure: error: readelf for the host is required for cross builds\n\n看来是工具链没有配置完整，还差一个readelf，NDK的交叉编译链里已经集成了它，我们只需要加上去即可。\nexport READELF=$TOOLCHAIN/bin/readelf\n\n再配置一次\n./configure --host=$TARGET --build=aarch64 --disable-ipv6 ac_cv_file__dev_ptmx=no ac_cv_file__dev_ptc=no --prefix=/home/xayah/py/install\n\n这次配置成功了！\n让我们进行接下来的编译吧：\nmake -j128 &amp;&amp; make install -j128\n\n稍加等待，编译成功！\nxayah@xayah-virtual-machine:~/py/install$ pwd/home/xayah/py/installxayah@xayah-virtual-machine:~/py/install$ lsbin  include  lib  sharexayah@xayah-virtual-machine:~/py/install$ cd binxayah@xayah-virtual-machine:~/py/install/bin$ ls2to3      idle3    pydoc3    python3    python3.9-config2to3-3.9  idle3.9  pydoc3.9  python3.9  python3-config\n\n在Android平台上测试首先将编译产物打包再将其推送到Android平台中\nadb push py.zip /data/local/tmp/\n\n由于Android对权限的限制，我们不能推送到任意目录，但可以将其推送到/data/local/tmp/目录，因为它具有完整的文件操作权限。\nxayah@xayah-virtual-machine:~/py/install$ adb push py.zip /data/local/tmp/py.zip: 1 file pushed, 0 skipped. 37.2 MB/s (56531714 bytes in 1.450s)\n\n推送成功，接下来我们进入adb shell操作\nxayah@xayah-virtual-machine:~/py/install$ adb shellcas:/ $ cd /data/local/tmpcas:/data/local/tmp $ lspy.zipcas:/data/local/tmp $ unzip py.zip &gt; /dev/nullcas:/data/local/tmp $ lsbin  include  lib  py.zip  sharecas:/data/local/tmp $ cd bincas:/data/local/tmp/bin $ ls2to3      idle3    pydoc3    python3         python3.92to3-3.9  idle3.9  pydoc3.9  python3-config  python3.9-configcas:/data/local/tmp/bin $ ./python3.9Python 3.9.6 (default, Aug  1 2021, 16:27:01) [Clang 9.0.9 (https://android.googlesource.com/toolchain/llvm-project a2a1e703c on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; print(&quot;Hello World!&quot;)Hello World!&gt;&gt;&gt; \n\n可以看到Python3.9成功的运行起来，并且输出Hello World!\n","tags":["Python","Android","交叉编译"]},{"title":"RESTful API笔记","url":"/2021/09/27/RESTful-API%E7%AC%94%E8%AE%B0/","content":"\n作者：覃超链接：https://www.zhihu.com/question/28557115/answer/48094438来源：知乎\n\n概念REST – Resource Representational State Transfer 资源在网络中以某种表现形式进行状态转移\nResource ：资源，即数据。例如 friends，profile等；\nRepresentational ：某种表现形式，例如JSON，XML，JPEG等；\nState Transfer ：状态变化。通过HTTP动词实现。\n一言以蔽之：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。\n规则\nURL中只使用名词来指定资源，原则上不使用动词。\n\nServer和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（On-wire data compression）。\n\n用 HTTP Status Code传递Server的状态信息。例如最常用的 200 表示成功，500 表示Server内部错误等。\n\n\n示例# 获取某人的好友列表/v1/friends\n\n# 获取某人的详细信息/v1/profile\n\n用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态变化：\n# 删除某人的好友DELETE /v1/friends\n\n# 添加好友POST /v1/friends\n\n# 更新个人资料UPDATE /v1/profile\n\n如下使用不符合规范：\nGET /v1/deleteFriend\n\n","tags":["笔记","后端","API"]},{"title":"STM32F103VBT6: 闪烁一盏LED灯","url":"/2022/11/23/STM32F103VBT6-%E9%97%AA%E7%83%81%E4%B8%80%E7%9B%8FLED%E7%81%AF/","content":"一、前言前面我们学习了很多单片机的知识，接下来我们即将进入到ARM的世界~本篇博文将从零开始实现一块基于STM32F103VBT6芯片的开发板上的LED灯的闪烁。\n二、环境准备MCUISP如何使用它下载到STM32板上呢？首先将开发板上的COM口接入PC，在软件中搜索串口并且选择CH 340串口，波特率选择115200即可。\n\n\n然后选择HEX文件并按照如下选项进行勾选\n\n\n准备就绪后，点击开始编程按钮，在开发板上按顺序快速按下REST和ISP按键即可下载。\n\n\nKeil uVision5该程序安装完成后记得安装本开发板的支持包Keil.STM32F1xx_DFP.xxx（双击即可安装）\nJ-Link可在此处下载并安装最新的J-Link\n\n\nSTM32CubeMX可在此处下载并安装最新的STM32CubeMX（需要注册并登录）\n安装完成后首次打开该应用，首先打开Embedded Software Packages Manager\n\n选择STM32F1并下载最新的软件包\n\n\n三、使用STM32CubeMX生成模板代码1. 创建工程打开STM32CubeMX，选择ACCESS TO MCU SELECTOR\n\n\n搜素STM32F103VBT6，双击右侧对应的STM32F103VBT6。\n\n\n\n2. 分配LED灯相关引脚\n\n从原理图可以看出，LED灯的A - E分别对应应引脚PE8 - PE15，而LED_SEL对应PB3。因此我们将其设置为推挽，即Output Push Pull，当然还可以为其添加标签，更便于标识。\n\n\n3. 模式配置将这9个引脚设置完毕后，我们接下来设置其调试模式。进入System Core - SYS，在Debug处选择Serial Wire，防止开发板被上锁导致只能下载一次的问题。\n\n\n4. 时钟配置这里我们使用时间中断来闪烁LED灯，因此我们需要配置时钟。进入Clock Configuration，观察到默认频率为8MHz（实际上可以根据自己的需求进行调整，或使用外部时钟等等，这里我们使用系统内部的时钟即可）\n\n\n返回Pinout &amp; Configuration界面，进入Timers - TIM1首先设置时钟源(Clock Source)为系统时钟(Internal Clock)，然后在Parameter Settings中设置分频系数(Prescaler)、计数周期(Counter Period)以及自动重载(auto-reload preload)\n\n\n假设分频系数(Prescaler)为A，计数周期(Counter Period)为B，时钟频率为C，则这里时间溢出公式为我们将A设置为8000-1，B设置为1000-1，C为8Mhz，因此T = 1s，即我们的时间回调函数调用周期为1s。\n接下来我们开启时间中断\n\n\n5. 工程配置在Project Manager中设置工程名称、路径、工具链。\n\n\n在左侧选择Code Generator，勾选Generate peripheral initialization as a pair of '.c/.h' files per peripheral，即针对每个外设生成独立的.c和.h文件。\n\n\n6. 生成模板代码配置完成后，点击右上角GENERATE CODE按钮即可生成模板代码。\n\n\n\n在工程目录下，LED.ioc即为STM32CubeMX的工程文件，而MDK-ARM下的LED.uvprojx即为Keil工程文件。\n\n\n四、使用模板代码实现LED闪烁效果。使用Keil或其它工具打开该工程，我们可以发现STM32CubeMX已为我们生成了规范的目录结构。\n1. 开启LED灯。在gpio.c中我们可以找到IO口初始化的相关代码\nvoid MX_GPIO_Init(void){  GPIO_InitTypeDef GPIO_InitStruct = {0};  /* GPIO Ports Clock Enable */  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  /*Configure GPIO pin Output Level */  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11                          |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);  /*Configure GPIO pin Output Level */  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_RESET);  /*Configure GPIO pins : PE8 PE9 PE10 PE11                           PE12 PE13 PE14 PE15 */  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11                          |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_NOPULL;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  /*Configure GPIO pin : PB3 */  GPIO_InitStruct.Pin = GPIO_PIN_3;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_NOPULL;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);}\n因此我们可以依葫芦画瓢在main.c中为LED_SEL口使能，让其LED灯正常工作。\nint main(void){  HAL_Init();  SystemClock_Config();  MX_GPIO_Init();  MX_TIM1_Init();  // 允许LED输出  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_SET);  while (1) {}}\n其中GPIO_PIN_SET实为1，即高电平；同理GPIO_PIN_RESET为0，即低电平。\n2. 实现时间中断函数\n在tim.c中我们可以发现它有一个全局实例，时钟通过该实例进行区分。欲开启该时钟，我们需要将其初始化。\nint main(void){  HAL_Init();  SystemClock_Config();  MX_GPIO_Init();  MX_TIM1_Init();  // 允许LED输出  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_SET);  // 使能TIM1  HAL_TIM_Base_Start_IT(&amp;htim1);  while (1) {}}\n然后编写时间中断函数即可。\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){  if (htim-&gt;Instance == TIM1) {    // TIM1中断, 1s    HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_8);  }}\n这里我选择将LED灯A每1s进行一次翻转，从而实现闪烁效果。\n五、下载验证代码编写好后，如果正确安装了J-Link驱动，将开发板上的SWD口接入PC，则可在设备管理器中找到如下条目\n\n然后打开Keil，如下图配置J-Link调试。\n\n\n进入J-Link设置，按如下配置端口和频率\n\n\n\n然后编译\n\n\n\n至此，我们将其下载到开发板上，按下REST键即可验证。\n\n\n\n\n六、调试设置断点后，即可进入调试模式。\n\n","tags":["ARM","嵌入式"]},{"title":"Vue + Electron 搭建跨端桌面应用","url":"/2022/07/02/Vue-Electron-%E6%90%AD%E5%BB%BA%E8%B7%A8%E7%AB%AF%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/","content":"一、前言跨端应用开发一直都是热门需求，目前已经有很多方案可以实现跨端开发，然而 Flutter 对于目前热门的高刷屏适配摆烂， JetPack Compose 仍在发育之中， Electron 优势在于前端技术栈却亦受限于此，但如果我们熟悉前端开发，Electron仍是一个不错的选择。\n本文以 Vue2 热门框架 Quasar 为例，记录其Windows桌面程序搭建流程。\n二、流程1. 安装NodeJSNVM 对于Node版本管理非常方便，请参考其安装文档安装 NodeJS 。\n2. 安装Yarn相比于NPM，我更青睐 Yarn 。安装\nnpm install --global yarn\n验证\nyarn --version\n\n3. 安装Quasar CLIQuasar脚手架可以方便地为我们创建Quasar工程。\nyarn global add @quasar/cli\n\n4. 创建工程yarn create quasar\n根据提示选择相关配置来创建Quasar工程。\n5. 设置Yarn Electron淘宝源yarn config set electron_mirror https://cdn.npm.taobao.org/dist/electron/\n\n5. 添加Quasar Electron模式先进入工程目录，再添加Electron模式。\nquasar mode add electron\n\n6. 调试quasar dev -m electron\n","tags":["Vue","Electron","跨端"]},{"title":"Windows Subsystem for Linux 2 的艺术","url":"/2022/02/12/Windows-Subsystem-for-Linux-2-%E7%9A%84%E8%89%BA%E6%9C%AF/","content":"一、前言微软赛高！得益于其强大的技术支持，我们可以在 Windows 上无缝体验 Linux (Windows Subsystem for Linux) 甚至 Android (Windows Subsystem for Android) 。\n将 WSL2 与 Jetbrains系列IDE 或 VS Code 结合，我们可以在 Windows 下无缝开发并调试 Linux 环境程序。\n二、安装WSL21. 系统要求笔者使用的是 Windows 11 专业版。\n\n\n2. 启用 适用于Linux的Windows子系统打开 启用或关闭Windows功能\n\n\n启用 适用于Linux的Windows子系统\n\n\n3. 更新 WSL 2 Linux 内核下载并安装适用于 x64 计算机的 WSL2 Linux 内核更新包\n4. 将 WSL 2 设置为默认版本wsl --set-default-version 2\n\n5. 安装所选的 Linux 分发这里以Ubuntu 20.04 LTS为例你还可以选择\n\nUbuntu 18.04 LTS\nopenSUSE Leap 15.1\nSUSE Linux Enterprise Server 12 SP5\nSUSE Linux Enterprise Server 15 SP1\nKali Linux\nDebian GNU/Linux\nFedora Remix for WSL\nPengwin\nPengwin Enterprise\nAlpine WSL\nRaft（免费试用版）\n\n打开Microsoft Store，搜索Ubuntu 20.04并安装\n\n\n6. 配置账号打开Ubuntu 20.04（可从Microsoft Store打开），配置用户名密码。\n\n\n7. 修改安装目录默认WSL位于C盘，如果使用频率较高的话，你会发现C盘占用空间蹭蹭往上涨~这里笔者选择修改安装目录到D盘\n1) 查看已安装的Linux发行版本wsl -l --all -v\n\n\n2) 导出Ubuntu到D盘wsl --export Ubuntu-20.04 D:\\WSL2\\WSL-Ubuntu20.04.tar\n\n3) 注销当前Ubuntuwsl --unregister Ubuntu-20.04\n\n4) 将导出的文件重新导入并安装wsl --import Ubuntu-20.04 D:\\WSL2\\WSL-Ubuntu20.04 D:\\WSL2\\WSL-Ubuntu20.04.tar --version 2\n\n5) 重新设置用户名（将$USERNAME修改为安装时的用户名，密码不变）ubuntu2004 config --default-user $USERNAME\n\n* Windows Terminal设置默认启动目录\\\\wsl.localhost\\Ubuntu-20.04\\home\\$USERNAME\n\n\n6) 登录到WSL2\n\n三、环境配置1. 软件源修改为阿里源使用Vim打开sources.list\nsudo vim /etc/apt/sources.list\n键入:%d清空粘贴阿里源代码\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n按Esc，键入:wq保存并退出更新源并升级\nsudo apt-get update &amp;&amp; sudo apt-get upgrade\n\n2. 开启Systemd某些程序需要Systemd的支持，因此我们使用ubuntu-wsl2-systemd-script来开启。安装git\nsudo apt-get install git\n克隆脚本仓库\ngit clone https://github.com/DamionGans/ubuntu-wsl2-systemd-script.git\n跳转到ubuntu-wsl2-systemd-script目录\ncd ubuntu-wsl2-systemd-script\n运行安装脚本\nbash ubuntu-wsl2-systemd-script.sh\n重启Ubuntu（宿主机终端执行）\nwsl --shutdown Ubuntu-20.04\n再次登录到Ubuntu，验证Systemd\nsystemctl\n\n如上图则配置成功\n四、配置并使用宿主机代理创建并编辑.proxyrc文件\nvim .proxyrc\n输入以下代码（$port为宿主机代理端口，请自行修改）\n#!/bin/bashhost_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)export ALL_PROXY=&quot;http://$host_ip:$port&quot;\n按Esc，键入:wq保存并退出以后每次连接宿主机代理只需source .proxyrc即可生效\n五、参考文章\nWin10使用WSL2正确姿势\nwin10 wsl2修改默认安装目录到其他盘\n为 WSL2 一键设置代理\n\n","tags":["WSL2","Linux"]},{"title":"从绘板到跑路: 基于IAP15F2K61S2芯片的单片机折腾笔记","url":"/2022/07/14/%E4%BB%8E%E7%BB%98%E6%9D%BF%E5%88%B0%E8%B7%91%E8%B7%AF-%E5%9F%BA%E4%BA%8EIAP15F2K61S2%E8%8A%AF%E7%89%87%E7%9A%84%E5%8D%95%E7%89%87%E6%9C%BA%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/","content":"一、前言最近有个项目需要一块专用单片机用于实现PWM调频、电量测量（实际上是电压测量）、光照测量、485以及串口通信，并且项目代码基于学校老师封装的BSP，由于其是为基于IAP15F2K61S2芯片设计的开发板，因此打算基于同款芯片重新设计一块。\n二、工具工欲善其事，必先利其器。\n\nPCB设计工具。这里采用老师推荐的嘉立创EDA。\nMoney。\n\n三、绘制原理图原理图是设计流程中的基础，它是最终单片机上的一个个模块电路。由于是基于学校的开发板，因此可以借鉴其部分原理图。\n1. 芯片a) 查看原版原理图\n\nb) 添加元件打开嘉立创EDA，新建好工程后创建第一张原理图，然后打开元件库\n\n搜索IAP15F2K61S2 LQFP44\n\n在添加元件时，最好选择立创商城的元件，这样在购买的时候比较方便。\nc) 绘制原理图将其放置在原理图上，根据实际需求修改引脚：\n\nPWM调频需要用到PCA模块，因此引出4、5号引脚\n电量测量以及光照测量需要用到模数转换器（ADC），因此引出7、8、9号引脚\n485通信需要接收/发送数据以及使能信号，因此分别引出38、6、25号引脚\n串口通信需要接收/发送数据，因此分别引出18、19号引脚\n这里芯片的VCC引脚和GND引脚之间连接了一个104的电容，而104指的是即它的作用实际上是过滤电路中的高频噪声。\n\n2. USBa) 查看原版原理图\n右上角是FM收音机模块的一部分，而这里不需要用到它。\nb) 绘制原理图\n添加好元件后就可以绘制原理图了，这里把接口换成了Type-C（使用倒是方便，但非常难焊）。\n3. 485a) 查看原版原理图\n\nb) 绘制原理图\n\n4. PWMa) 绘制原理图下图存在部分错误，会在后文中指出。\n\n由于可以通过芯片在软件层实现PCA调频，因此可以借助MOS管导通特性，从而将输入的12V进行调频。将P1.0/P1.1口接入NMOS管的栅极，12V外部输入接入PMOS管的源极，当P1.0/P1.1输入高电平时NMOS管源极和漏极导通，PMOS管栅极相当于接地，其源极和漏极导通，从而使12V输出到漏极，通过对导通时间与周期的比例（即占空比）的控制，即可控制输出电压。其中二极管接地的作用是稳压和保护，防止反向击穿；电感通直流，阻交流；电容接地则是滤波。\n5. 电量（电压）测量a) 绘制原理图\nV_Voltage0/V_Voltage1得到的值是2k电阻的电压，因此将值除以2乘以20即为所测电压。\n6. 光照测量a) 查看原版原理图\n\nb) 绘制原理图\n这里没有直接接入光敏电阻，而是改成用连接器外接。\n四、绘制PCBPCB设计是设计流程中的重要环节，它决定了最终成品板的模样。\n1. 原理图转PCB将所有原理图绘制完成后，可以打开左侧工具栏中的设计管理器，检查是否还有未连接网络。\n\n检查完成之后，单击设计 - 原理图转PCB或者快捷工具栏对应的图标，将原理图转为PCB。后续如果原理图有更改，则可以选择更新PCB。\n\n\n2. 绘制首先根据实际情况填写参数，新建PCB。\n\n新建好后，就可以对PCB进行设计了。\n\n每个人的设计风格和理念都不同，但仍需要遵守一定的准则，以保证开发板的稳定性。\na) 绘制步骤根据原理图进行大致布局 → 微调元件位置 → 根据需要可选择放置焊盘 → 连线 → 微调元件位号位置，适当添加引脚标识（如GND等） → 添加泪滴（增强连线稳定性） → 铺铜（增强散热、屏蔽、保证PCB工艺电镀效果等）\nb) 注意事项\n尽量保证每个模块电路中的元件靠近，使得传输距离更短，更稳定，并且连线时更简单。\n连线时切忌直角转弯，应更平滑。错误：\n正确：\n在条件允许的情况下尽量增大导线的线宽。\n布局时应考虑部分元件对电路的影响，例如考虑晶振对电路的辐射作用，将其布局在开发板边缘位置更好。\n正面无法继续连线时，可放置过孔在背面继续连线。应注意立创EDA默认的过孔直径不满足DRC检查，可适当调整。\n铺铜不是必要的，但一般的电路板中铺铜更好。可对某部分特殊网络进行铺铜，例如本开发板背面对GND，正面对VUSB、VCC、+12V铺铜。此外铺铜间距不应太小，因为PCB工艺可能会有偏差。\n\nc) 查看成品绘制完成后，可以查看成品的各种样图。\n\n\n","tags":["单片机"]},{"title":"利用WebView实现Vue打包至Android移动端","url":"/2021/12/06/%E5%88%A9%E7%94%A8WebView%E5%AE%9E%E7%8E%B0Vue%E6%89%93%E5%8C%85%E8%87%B3Android%E7%A7%BB%E5%8A%A8%E7%AB%AF/","content":"前言Vue打包至移动端目前已经有许多解决方案，例如HBuilder、Cordova等等。但个人认为过程实在是太过于繁杂，且有的还需要联网验证，于是有了这篇文章。原理就是利用原生Android WebView本地加载Vue打包后的静态HTML，本文章以Android为例，使用Android Studio本地打包，IOS端同理。\n准备工具：Android Studio源码：npm run build之后的静态资源，例如dist文件夹\n步骤1. 打开Android Studio\n\n2. 新建项目 New Project - Empty Activity - Next填写Name（应用名称）、Package Name（包名）、Language（以Kotlin为例）、Minimum SDK（应用支持的最低Android版本），然后点击Finish创建项目。初次安装AS并创建项目需要联网下载Gradle等依赖，请耐心等待。\n\n\n3. 主题设置为NoActionBar默认主题会有一个ActionBar，需要去掉以保证加载后的Vue UI统一性。首先在左侧打开themes下的两个主题文件，其中一个是深色模式的主题，我们需要将两个都改为NoActionBar。这里以浅色模式为例。\n\n↓\n\n\n4. 设置状态栏背景颜色同样，在浅色模式主题文件中，修改android:statusBarColor为你想要的颜色，并将状态栏文字图标等设为深色\n&lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;\n\n深色模式同理。\n\n\n5. 布局添加WebView打开activity_main.xml：\n\n删除TextView并添加WebView：\n&lt;WebView    android:id=&quot;@+id/web_view&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;\n\n\n6. 本地加载打包后的HTML在项目目录下app\\src\\main创建assets文件夹，将打包后的dist放入assets：\n\n打开MainActivity.kt\n\n绑定组件：\nval webView: WebView = findViewById(R.id.web_view)\n本地加载HTML：\nwebView.loadUrl(&quot;file:////android_asset/dist/index.html&quot;)\n允许JS交互：\nwebView.settings.javaScriptEnabled = true\n\n打开AndroidManifest.xml ：\n\n添加INTERNET权限：\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\n\n8. 更换APP图标左栏右键res - drawable - New - Image Asset\n\n配置图标前景、背景：\n\n\nNext - Finish\n\n删除ic_launcher.webp、ic_launcher_round.webp（如果有的话）\n\n\n\n\n\n7. 调试1) Android调试以真机调试为例，当然也可以使用模拟器。真机调试需要在开发者模式开启USB调试模式。点击右上方绿色三角形运行。\n\n稍等片刻，会自动启动APP：\n\n\n\n2) WebView调试需要在开发者模式开启USB调试模式。在MainActivity.kt中添加以下代码：\nWebView.setWebContentsDebuggingEnabled(true)\n\n重新在AS中调试运行App，打开谷歌浏览器，地址栏输入：chrome://inspect/#devices进入远程调试工具。稍等片刻工具会自动载入已运行的WebView程序，点击inspect进入调试模式。\n\n\n8. 编译并签名点击工具栏 Build - Generate Signed Bundle / APK …\n\n选择APK - Next\n\n新建签名 Create new… 填写签名信息\n\n选择刚刚创建的签名文件 xxx.jks 填写对应信息后点击 Next\n\n\n选择release并点击Finish\n\n项目目录下app\\release即是编译完成的apk文件。\n\n\n\n9. 常见问题1) 跨域建议从后端解决跨域问题，以Flask为例：\npip3 install flask-cors\nfrom flask import Flaskfrom flask_cors import CORSapp = Flask(__name__)app.config[&#x27;JSON_AS_ASCII&#x27;] = False# 允许全局跨域CORS(app, supports_credentials=True)\n2) WebView调试出现ERR_CLEARTEXT_NOT_PERMITTED\n打开AndroidManifest.xml，在application标签下配置：\n&lt;application    ······    android:usesCleartextTraffic=&quot;true&quot;    ······&lt;/application&gt;","tags":["Android","Vue","WebView"]},{"title":"利用清华和科大镜像源全程国内同步Android源码","url":"/2021/07/08/%E5%88%A9%E7%94%A8%E6%B8%85%E5%8D%8E%E5%92%8C%E7%A7%91%E5%A4%A7%E9%95%9C%E5%83%8F%E6%BA%90%E5%85%A8%E7%A8%8B%E5%9B%BD%E5%86%85%E5%90%8C%E6%AD%A5Android%E6%BA%90%E7%A0%81/","content":"原CSDN博客地址\n环境： 2021-1-12\n系统： Ubuntu 20.04.1 LTS\n\n网上类似的资料已经很多了，但由于 时效性 或多或少会有一些问题，我在这里记录下 当前环境 下成功同步的方法\n具体步骤\n安装必要工具\n sudo apt install curl\n sudo apt install vim\n sudo apt install git\n在 ~/bin 目录下载 repo ：\n mkdir ~/bin\n cd ~/bin\n curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo\n chmod +x repo\n配置 repo 环境变量:\nsudo vim ~/.bashrc\n\n\n输入 i 进入编辑模式\n\n在 末尾 添加：\n  export PATH=~/bin:$PATH\n  export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;\n按 Esc 退出编辑模式，输入 :wq 保存并退出\n\n使环境变量生效： source ~/.bashrc\n\n\n\n在 清华/科大镜像源 下载 初始包 到 工作目录 （90GB左右）：\n 清华源初始包\n 科大源初始包\n\n在工作目录下解压： \ntar xf aosp-latest.tar\n\n\n经测试清华源下载的初始包直接 repo sync 会出现奇奇怪怪的问题，解决办法是：\n 显示隐藏文件 → 打开 aosp/.repo/manifests.git/config\n\n修改其中的 url 为：\n url = git://mirrors.ustc.edu.cn/aosp/platform/manifest\n\n\n\n修改 符号链接 将 python3 默认指向 python 命令：\n sudo rm /usr/bin/python\n sudo ln -s /usr/bin/python3 /usr/bin/python\n设置账号的 缺省身份标识 ：\n git config --global user.email &quot;you@example.com&quot;\n git config --global user.name &quot;Your Name&quot;\n回到 aosp 目录下同步源码： repo sync \n\n 成功 同步源码 !\n\n\n","tags":["Android","Git","Ubuntu"]},{"title":"成为Wheel Maker：发布Android库到MavenCentral","url":"/2022/02/25/%E6%88%90%E4%B8%BAWheel-Maker%EF%BC%9A%E5%8F%91%E5%B8%83Android%E5%BA%93%E5%88%B0MavenCentral/","content":"一、前言Android发展日新月异，由此诞生了许多强大的第三方库，例如Glide、OkHttp。我们当然也可以发布自己的库，当一回Wheel Maker！以前大家用Jcenter作为平台，而现在大家用MavenCentral。\n二、步骤1. 注册Sonatype账号MavenCentral由Sonatype运营，因此我们先 注册 一个 Sonatype账号。\n2. 创建问题首先填写项目和问题类型。\n\n项目：Community Support - Open Source Project Repository Hosting (OSSRH)\n问题类型：New Project\n然后根据具体情况填写库信息。\n收到了来自工作人员的回复\n回复中提到我们需要验证GroupId对应的域名，我这里为了方便就选择第二种方式，将GroupId改为io.github.xayahsususu。回到GitHub，新建一个名为OSSRH-78521（根据回复中的仓库名）的仓库。\n\n编辑这个问题，把GroupId改为io.github.xayahsususu并更新，然后将状态重新更新为开放，等待回复。几分钟之后，正常情况下会受到完成的回复，注意回复中提到的s01.oss.sonatype.org，这是我们管理上传库的地址，可能每个时期得到的地址不同。\n\n问题状态变为已解决\n\n\n3. 申请GPG密钥发布到MavenCentral的库需要签名，因此我们 下载 相应工具来生成密钥，这里以Windows为例安装Gpg4win，运行Kleopatra。\n\n左上角文件 - 新建密钥对 - 创建个人 OpenPGP 密钥对\n\n\n完成后在主界面打开生成的密钥，记住指纹后8位（后面要用到），然后生成吊销证书并保存\n\n接下来回到主界面右键密钥 - 在服务器上发布，若网络没有问题即可发布成功。\n\n发布成功后，再次右键密钥 - 备份私钥，将私钥导出（将后缀改为.gpg）。接下来打开密钥，修改密码。\n\n\n4. Android库发布脚本配置在项目根目录下新建publish-mavencentral.gradle输入以下代码（如果上文中回复得到的地址不为s01.oss.sonatype.org，则将其改为得到的地址）\napply plugin: &#x27;maven-publish&#x27;apply plugin: &#x27;signing&#x27;task androidSourcesJar(type: Jar) &#123;    classifier = &#x27;sources&#x27;    from android.sourceSets.main.java.source&#125;ext[&quot;signing.keyId&quot;] = &#x27;&#x27;ext[&quot;signing.password&quot;] = &#x27;&#x27;ext[&quot;signing.secretKeyRingFile&quot;] = &#x27;&#x27;ext[&quot;ossrhUsername&quot;] = &#x27;&#x27;ext[&quot;ossrhPassword&quot;] = &#x27;&#x27;File secretPropsFile = project.rootProject.file(&#x27;local.properties&#x27;)if (secretPropsFile.exists()) &#123;    println &quot;Found secret props file, loading props&quot;    Properties p = new Properties()    p.load(new FileInputStream(secretPropsFile))    p.each &#123; name, value -&gt;        ext[name] = value    &#125;&#125; else &#123;    println &quot;No props file, loading env vars&quot;&#125;publishing &#123;    publications &#123;        release(MavenPublication) &#123;            // The coordinates of the library, being set from variables that            // we&#x27;ll set up in a moment            groupId PUBLISH_GROUP_ID            artifactId PUBLISH_ARTIFACT_ID            version PUBLISH_VERSION            // Two artifacts, the `aar` and the sources            artifact(&quot;$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar&quot;)            artifact androidSourcesJar            // Self-explanatory metadata for the most part            pom &#123;                name = PUBLISH_ARTIFACT_ID                description = PUBLISH_DESCRIPTION                // If your project has a dedicated site, use its URL here                url = PUBLISH_GITHUB_URL                licenses &#123;                    license &#123;                        name = PUBLISH_LICENSE_NAME                        url = PUBLISH_LICENSE_URL                    &#125;                &#125;                developers &#123;                    developer &#123;                        id = PUBLISH_DEVELOPER_ID                        name = PUBLISH_DEVELOPER_NAME                        email = PUBLISH_DEVELOPER_EMAIL                    &#125;                &#125;                // Version control info, if you&#x27;re using GitHub, follow the format as seen here                scm &#123;                    connection = PUBLISH_CONNECTION                    developerConnection = PUBLISH_CONNECTION_DEVELOPER                    url = PUBLISH_CONNECTION_URL                &#125;                // A slightly hacky fix so that your POM will include any transitive dependencies                // that your library builds upon                withXml &#123;                    def dependenciesNode = asNode().appendNode(&#x27;dependencies&#x27;)                    project.configurations.implementation.allDependencies.each &#123;                        def dependencyNode = dependenciesNode.appendNode(&#x27;dependency&#x27;)                        dependencyNode.appendNode(&#x27;groupId&#x27;, it.group)                        dependencyNode.appendNode(&#x27;artifactId&#x27;, it.name)                        dependencyNode.appendNode(&#x27;version&#x27;, it.version)                    &#125;                &#125;            &#125;        &#125;    &#125;    repositories &#123;        // The repository to publish to, Sonatype/MavenCentral        maven &#123;            // This is an arbitrary name, you may also use &quot;mavencentral&quot; or            // any other name that&#x27;s descriptive for you            name = PUBLISH_MAVEN_NAME            def releasesRepoUrl = &quot;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&quot;            def snapshotsRepoUrl = &quot;https://s01.oss.sonatype.org/content/repositories/snapshots/&quot;            // You only need this if you want to publish snapshots, otherwise just set the URL            // to the release repo directly            url = version.endsWith(&#x27;SNAPSHOT&#x27;) ? snapshotsRepoUrl : releasesRepoUrl            // The username and password we&#x27;ve fetched earlier            credentials &#123;                username ossrhUsername                password ossrhPassword            &#125;        &#125;    &#125;&#125;signing &#123;    sign publishing.publications&#125;\n\n打开项目根目录中的local.properties，添加以下代码\nsigning.keyId=$密钥指纹后八位（无空格）signing.password=$密钥密码signing.secretKeyRingFile=$导出密钥的文件路径，例如：E\\:\\\\ProgramDesign\\\\AndroidProjects\\\\Signature\\\\Xayah_0xEB95FB34_SECRET.gpgossrhUsername=$Sonatype帐号ossrhPassword=$Sonatype密码\n打开待发布库目录下的build.gradle，行位添加以下代码（根据示例参考修改填写）\next &#123;    PUBLISH_GROUP_ID = &quot;io.github.xayahsususu&quot;    PUBLISH_ARTIFACT_ID = &#x27;materialyoufileexplorer&#x27;    PUBLISH_DESCRIPTION = &#x27;A file explorer with the style of Material You.&#x27;    PUBLISH_GITHUB_URL = &#x27;https://github.com/XayahSuSuSu/Android-MaterialYouFileExplorer&#x27;    PUBLISH_VERSION = &#x27;1.0.0&#x27;    PUBLISH_LICENSE_NAME = &#x27;GPL-3.0&#x27;    PUBLISH_LICENSE_URL = &#x27;https://choosealicense.com/licenses/gpl-3.0/&#x27;    PUBLISH_DE_URL = &#x27;https://choosealicense.com/licenses/gpl-3.0/&#x27;    PUBLISH_DEVELOPER_ID = &#x27;Xayah&#x27;    PUBLISH_DEVELOPER_NAME = &#x27;Xayah&#x27;    PUBLISH_DEVELOPER_EMAIL = &#x27;zds1249475336@gmail.com&#x27;    PUBLISH_CONNECTION = &#x27;scm:git:github.com/XayahSuSuSu/Android-MaterialYouFileExplorer.git&#x27;    PUBLISH_CONNECTION_DEVELOPER = &#x27;scm:git:ssh://github.com/XayahSuSuSu/Android-MaterialYouFileExplorer.git&#x27;    PUBLISH_CONNECTION_URL = &#x27;https://github.com/XayahSuSuSu/Android-MaterialYouFileExplorer/tree/main&#x27;    PUBLISH_MAVEN_NAME = &quot;MaterialYouFileExplorer&quot;&#125;apply from: &quot;$&#123;rootProject.projectDir&#125;/publish-mavencentral.gradle&quot;\n\n5. 发布Android库到MavenCentral打开Settings - Experimental - 取消勾选 Do not build Gradle task list during Gradle sync\n\n点击左上角File - Sync Project with Gradle Files\n\n完成后打开右侧Gradle窗口，双击运行build - assemble\n\n编译完成后，双击运行publishing - publishReleasePublicationTo${LibraryName}Repository 发布到https://s01.oss.sonatype.org （具体地址由上文回复中可得）\n\n打开管理地址后，进入Staging Repositories，即可看到我们上传的库记录。\n\n打开库记录，点击Close，输入描述后Confirm，稍等片刻即可刷新查看，若Close成功，则点击Release发布。发布成功后，之前的问题会收到发布成功的回复。\n\n假以时日，我们即可在https://repo1.maven.org/maven2/ 和 https://search.maven.org/ 中查看到我们发布的库信息。\n\n\n6. 使用已发布的Android库打开需要引用库的项目的app目录下的build.gradle，输入以下代码引用。格式为：\nimplementation &#x27;$PUBLISH_GROUP_ID:$PUBLISH_ARTIFACT_ID:$PUBLISH_VERSION&#x27;\n例如：\nimplementation &#x27;io.github.xayahsususu:materialyoufileexplorer:1.0.0&#x27;\n\n三、参考文章\nAndroid库发布到Maven Central全攻略\n\n","tags":["Android","MavenCentral"]},{"title":"春招: 自我救赎之路","url":"/2024/03/24/%E6%98%A5%E6%8B%9B-%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E%E4%B9%8B%E8%B7%AF/","content":"前言太累了，有空再写吧。\nTimeline\n2024-02-27三星投递简历\n\n2024-02-27OPPO投递简历\n\n2024-03-01VIVO投递简历\n\n2024-03-01 11:15VIVO测评\n\n2024-03-01米哈游投递简历\n\n2024-03-04OPPO重新投递简历\n\n2024-03-04华为投递简历\n\n2024-03-05字节投递简历\n\n2024-03-05小米投递简历\n\n2024-03-09 08:00OPPO笔试\n\n2024-03-11 15:00小米技术面试一、技术面试二\n\n2024-03-12 10:00小米技术面试三\n\n2024-03-13 15:00VIVO笔试\n\n2024-03-13 19:00华为笔试\n\n2024-03-14 15:10OPPO 技术面试\n\n2024-03-16 14:50OPPO 综合面试\n\n2024-03-17 10:00米哈游笔试\n\n2024-03-19 21:30新凯来个性测评\n\n2024-03-20 10:00OPPO HR面试\n\n2024.03.20 19:00虾皮笔试\n\n2024-03-21 10:30新凯来技术面试\n\n2024-03-22 15:00优博讯笔试\n\n2024-03-23 15:00新凯来综合面试\n\n2024-03-24 10:00新凯来电话资面\n\n2024-03-26 16:00VIVO线下面试（技术面+HR面）\n\n2024-03-27 15:00米哈游一面\n\n2024-03-28 15:00字节一面（已申请取消）\n\n2024-04-01 15:00米哈游二面\n\n\n记录三星SRCN-Android Platform开发 工程师 (江苏省·南京市)需求部门：三星电子（中国）研发中心职位类别：研发/设计发布时间：2024-02-27招聘人数：若干岗位职责：1、负责app framework开发与优化2、负责从平台层面优化app启动与响应时间、内存与CPU使用、android启动时间等性能优化3、负责处理android平台的兼容性问题，并支持通过相关认证4、负责android平台升级，android平台上相关先行技术的研究与验证5、负责android window system, network, graphic, input, mulitmedia模块开发6、负责virual gamepad开发和集成相关工作任职资格：1、熟悉计算机相关专业，熟练掌握C/C++/java其中任一门语言2、熟悉Linux系统及其常用命令，shell/python脚本的编写优先3、了解HTML，JS， 音频/视频 信号处理， Android 框架工作有接触优先 4、了解Android System 或者 Android HAL层开发经验者优先5、具备良好的沟通能力，熟悉算法和数据结构\n\n2024-02-27 投递简历，无内推码\n\nOPPO安卓应用工程师武汉市,深圳市,成都市 | 软件类 | 应届生 (2024届春季校园招聘) | 2024-01-15 发布岗位职责方向一：负责相机App需求开发、性能优化、交互优化；方向二：负责ColorOS系统应用开发与优化；方向三：负责ColorOSUI组件、资源框架定制、动画&amp;图形框架定制等的开发；方向四：负责移动互联网应用开发与优化；方向五：负责IoT客户端产品开发与优化；方向六：负责新业务的架构设计与开发；方向七：负责研究手机移动端新技术；方向八：负责IoT业务前端产品开发；方向九：负责基础软件平台前端开发。任职要求1.计算机、通信、电子信息、通信工程、软件工程等相关专业；2.熟悉Java/Kotlin语言；3.热爱互联网，对互联网产品和技术有浓厚的兴趣；4.具备优秀的分析问题和解决问题的能力，对解决具有挑战性的问题充满激情；5.深刻理解算法和数据结构相关知识，并熟练掌握Java编程语言；6.熟悉TCP/IP，HTTP，HTTPS等网络协议；7.学习能力强，具有良好的沟通能力和良好的团队合作精神；我们更希望你：1.有Android编程语言使用经验；2.参与过实际项目开发，熟悉软件工程开发流程；3.有计算机领域相关的编程大赛获奖经历。学历要求：本科及以上\n\n2024-02-27 投递简历，无内推码\n2024-03-04 参加校园宣讲会，拿到内推码重新投递简历\n2024-03-08 性格测评，邀请笔试\n2024-03-09 笔试\n2024-03-13 邀请专业面试\n2024-03-14 专业面试，邀请综合复试\n2024-03-16 综合复试\n2024-03-18 邀请HR面试\n2024-03-20 HR面试，结束30min后查状态码：PASS\n2024-03-22 官网进度更新：Offer排序中\n2024-03-25 OC\n2024-03-26 录用意向沟通会\n\nVIVO\nVIVO的邮件会被Gmail视为垃圾邮件，难绷\n\n\n2024-03-01 投递简历，无内推码，参加行测\n2024-03-12 邀请笔试\n2024-03-13 笔试\n2024-03-15 邀请线下面试\n2024-03-27 技术面试+HR面试\n2024-04-03 感谢信（自我感觉技术面答的还行，乐，可能还是太菜了，可能要薪太高，也可能HR觉得我最后大概率不会去VIVO？）\n\n米哈游移动客户端开发（Android）上海 | 程序&amp;技术类 | 全职 | 2024春招工作职责1. 负责米哈游旗下产品移动端的开发与维护；2. 负责移动端基础模块组件的开发与维护；3. 负责移动端研发质量和效率优化工具的开发与维护；4. 负责移动端研发体系平台能力建设；5. 负责移动端新技术的调研和落地。任职要求1. 统招本科及以上学历，计算机及相关专业；2. 具备扎实的数据结构、算法、操作系统、软件工程、设计模式、计算机网络等领域内专业知识；3. 热爱计算机科学和互联网技术，对移动产品有浓厚兴趣；4. 热爱编程，对技术和代码有追求，具备良好的学习能力、沟通能力、主动分析及解决问题能力，具有团队合作精神。加分项1. 有开源项目贡献者或 ACM 比赛经验者优先；2. 对 iOS/Android 其中一个平台的应用开发有了解，有实际项目的开发经历或实习经历优先。投递说明IM 团队介绍：大型协同效率套件，米哈游核心工业化管线重要协作工具，为米哈游员工提供全球化一站式协作服务，包括 IM、文档、音视频、日历、开放能力、Admin 管理后台、等多个业务模块。并根据游戏行业研发特点，和米哈游管线协作方式，定义 Workspace、Project Mode 等能力，在效率工具领域领先其他产品。\n\n2024-03-01 投递简历，有内推码\n2024-03-15 邀请笔试\n2024-03-17 笔试\n2024-03-19 邀请面试\n2024-03-27 面试\n2024-03-28 邀请复试\n2024-04-01 复试\n\n华为软件开发工程师 - 应用软件开发工程师岗位职责1、在这里，您可以接触最前沿的软件领域技术，参与开发业界最优秀的手机、平板、可穿戴、智能家居、车载等全品类终端精品；2、在这里，您可以创作极致用户体验的应用APP，围绕鸿蒙生态从事HarmonyOS应用软件研发，以最快的速度看到您贡献的代码被成千上万人使用；3、在这里，您可以接触到业内先进的开发模式与开发工具，与前辈们进行平等的沟通交流，快速成长。岗位要求1、计算机、通信、软件工程等相关专业本科及以上学历；2、对终端产品软件开发充满激情；3、热爱编程，基础扎实，熟悉掌握JAVA/C/C++编程语言，有良好的编程习惯。工作地点中国\\上海-上海中国\\北京-北京中国\\四川-成都中国\\山东-济南中国\\广东-东莞中国\\广东-深圳中国\\江苏-南京中国\\江苏-苏州中国\\浙江-杭州中国\\湖北-武汉中国\\湖南-长沙中国\\陕西-西安意向部门第一意向部门 - 光产品线 - 湖北武汉\n\n2024-03-04 投递简历，将简历编号发给了武汉光产品线HR，提交电子设计大赛国一证书申请免机试\n2024-03-08 HR回复不符合条件\n2024-03-12 官网进度更新\n2024-03-13 笔试\n\n字节跳动客户端开发工程师-Flow | 杭州 | 正式 | 研发 - 客户端 | 2024校招全职补录 | 职位 ID：A238115职位描述团队介绍：字节跳动Flow产品研发团队，专注研究AI智能化相关业务落地，目前落地豆包、Cici 等 APP，以及对应的Bot 开发平台等AI智能化创新产品，业务和团队均处于快速发展期，成长空间大，欢迎各位同学加入！1、负责Android/iOS客户端研发，编写高质量代码；2、设计良好的代码结构，对程序进行优化，满足产品体验。职位要求1、2024届获得本科及以上学历，计算机相关专业；2、熟悉Java/Kotlin/Objective-C/Swift/C++中的至少一门语言；3、有良好的编程习惯，代码结构清晰，命名规范；4、能够独立思考产品中的技术架构和实现，以及未来的扩展性，给出合理的解决方案；5、有优秀的调试和解决问题能力，逻辑思维清晰严谨；6、良好的沟通能力，严谨的工作态度与高质量意识，良好的抗压能力，乐于协作。\n\n2024-03-05 投递简历，有内推码\n2024-03-15 官网进度更新：评估中\n2024-03-19 官网进度更新：面试中，HR电话约面，邮件邀请面试\n2024-03-28 思考了很久，最终还是决定联系HR取消面试\n\n小米Android开发工程师（可接受Java方向）-澎湃OS北京市、南京市 | 校招 | 正式 | 软件研发类 | 2024届春季校招计划职位描述1.参与小米跨端智联模块的设计与开发；2.能按时、独立、高质量地完成工作，确保相关代码逻辑的健壮性与正确性；3.独立完成部分系统的系统分析以及系统设计文档的撰写；4.维护、升级和优化现有系统，并能够快速定位并及时修复软件缺陷。职位要求1.具备良好的Java编程能力，熟悉常用的算法及数据结构；2.了解Android系统开发技术，具有android开发经验优先；3.具备良好的分析、解决问题的能力以及学习能力；4.具备良好的工作态度、沟通技巧以及团队协作精神。\n\n2024-03-05 投递简历，有内推码\n2024-03-07 官网进度更新：评估中\n2024-03-08 官网进度更新：面试中，邀请面试\n2024-03-11 技术面试一、技术面试二，中途无休约2.5小时，邀请面试\n2024-03-12 技术面试三\n2024-03-20 HR电话问薪以及其它个人信息，以安排后续HR面试，申请添加微信。\n2024-03-20 官网进度更新：转移至其他职位 - 流程终止 - 转移至其他职位\n2024-03-20 官网进度更新：被转移至：Android研发工程师，从校招-正式转为了社招-全职，微信询问HR，答曰“没事，是校招”\n2024-03-29 微信询问HR进度，未回复\n2024-04-06 HR回复称3月20号的是预沟通，也是会挂人的，难绷，下次能不能明说是要薪不够性价比\n\n虾皮（24届春招）Android开发工程师职位描述：1、开发互联网应用或框架，编写高质量、整洁简单、可维护性的代码，构建可重复使用的代码以及公共库；2、构建新的移动端应用，对现有Bug进行快速修复，不断优化现有产品，提高用户体验；3、学习和研究新的移动端技术和框架，快速运用到应用开发中；4、根据策划和产品部门的需求，完成需求分析并进行对应的功能设计；5、根据工作需要，设计并完成各种辅助工具的开发。任职资格：1、2024届本科及以上学历，计算机软件相关专业；2、掌握至少一种编程语言，包括但不限于Java、C、C++；3、热爱编码，对移动端产品有浓厚的兴趣，有求知欲，热爱学习新知识，对于创新以及解决具有挑战性问题充满激情；4、优秀的逻辑思维能力、学习能力和沟通能力，有客户端项目经验的同学优先。\n\n2024-03-07 投递简历，有内推码\n2024-03-18 邀请笔试\n2024-03-20 笔试\n2024-03-28 HR电话约面，申请终止流程\n\n新凯来\n2024-03-13 BOSS直聘上HR申请查看简历，邀请面试（需要提交简历、《深圳市新凯来技术有限公司职位申请登记表》、《新凯来知识产权和商业秘密保护承诺书》）\n2024-03-18 HR申请添加微信，回复邮件并提交简历、《深圳市新凯来技术有限公司职位申请登记表》、《新凯来知识产权和商业秘密保护承诺书》\n2024-03-20 HR通过微信邀请技术面试\n2024-03-21 腾讯会议技术面试\n2024-03-22 HR通过微信邀请综合面试\n2024-03-23 腾讯会议综合面试\n2024-03-24 电话资面，告知10天左右反馈审批结果\n\n交通银行软件开发工程师（成都）职位信息招聘部门：交通银行四川省分行-软件开发团队工作地点：四川省 成都市 截止时间：2024-04-14职位描述从事软件开发、应用架构设计、系统架构设计等相关工作，主要包括但不限于：1.开展业务需求调研和分析，应用架构方案设计以及需求实现；承担计算机应用系统的开发任务，编写和完善技术文档，并参与后续测试、投产、运行维护及推广等相关工作；2.根据应用架构和技术发展规划，参与推进全行重点项目的规划设计、评审及实施；3.参与网络运行情况的监控管理，研究并制定网络设备方案，完成相关软硬件产品的配置和管理工作；4.跟踪基础架构（小型机、PC服务器、存储、AIX、Linux操作系统等）、云计算等相关的新兴技术，参与系统架构规划及设计、相关技术标准研制和日常管理工作；5.跟踪国内外银行业务计算机应用系统软件和计算机技术发展趋势，持续提高技术水平和产品创新能力。职位要求1.本科及以上学历、学位应届毕业生，计算机科学与技术、软件工程、电子信息工程等金融科技类专业及其他理、工、农、医类专业毕业者优先；2.较好的计算机专业基础，具备计算机和金融等复合型专业背景者优先；3.具有较好的英语听说读写能力，须通过大学英语四级（CET4）考试（成绩在425分及以上），或提供具备相应外语能力的资格证明；4.具有较强的综合分析能力、沟通协调能力和文字表达能力；具有良好的逻辑思维能力及稳定的心理素质，良好的责任感和团队合作精神；5.身体健康，品行端正，无任何违法违规违纪行为；6.符合交通银行招录回避及履职回避规定。\n\n2024-03-13 （总行）投递简历，误操作导致投递被放弃\n2024-03-18 （交通银行四川省分行） 投递简历\n2024-03-19 漏接四川成都电话：171******60\n\n优博讯校园招聘-Android系统开发工程师毕业要求：2024届投递时间：2024年3月1日-2024年5月31日岗位职责1、负责智能手持终端PDA或POS产品Android Framework相关的设计、开发、调试、测试等；2、负责Android系统SDK及UI的开发维护；3、负责基于Android操作系统的软件平台研究、开发与优化工作，并在Android平台完成产品软件的高质量交付。4、分析市场需求，完成软件需求分析并及时交付高质量软件。岗位要求1、本科或硕士学历，电子信息类、计算机类、自动化类相关专业；2、熟悉Java/C++/C语言，熟悉Android系统工作原理，熟悉Android框架、Android系统库；3、优秀的学习能力，沟通能力，严谨的逻辑思维，能够快速响应需求；4、有责任心，抗压力强，有良好的团队合作意识。\n\n\n2024-03-08 牛客网HR申请查看简历，通过初筛\n2024-03-22 邮箱邀请笔试，完成笔试\n\n","tags":["随想"]},{"title":"树莓派入门体验笔记","url":"/2021/09/13/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C%E7%AC%94%E8%AE%B0/","content":"前言老早就对这块神奇的微型电脑感兴趣，机缘巧合之下暂时搞到一块，我手上这块是树莓派3B。\n\n\n镜像烧录起初我还以为我手上这块能够直接U盘引导，在我无数次尝试下终于放弃了这个想法，实际上 树莓派3B+ 才行。\n因此只能用SD卡了！虽然卡能直接插在板子上，但烧录镜像的时候还是需要读卡器这一远古神器。\n我的烧录环境是Windows。\n下载并安装 Raspberry Pi Imager 。\n打开Raspberry Pi Imager\n\n\n首先选择镜像（官方的Raspberry Pi OS蛮好用的）\n\n\n把SD卡插入读卡器，再连接到PC\n然后选择存储卡\n\n\n接下来点击Write，可以坐下来喝一杯奶茶并等待完成。\n\n\n开机前准备如果有HDMI接口和显示器，那么可以直接进行下一步，然后手动连接网络。\n如果有网线，那么也可以直接进行下一步。\n如果啥都没有（像我一样），那么就需要在开机前对烧录好系统的SD卡“动点手脚”了。\n首先重新拔插读卡器\n不要格式化H:（Windows无法识别Linux文件系统）\n\n\n然后打开另一个boot分区\n在该分区根目录下新建一个名为 ssh 的空白文件，以打开树莓派默认关闭的SSH功能\n再在该分区下新建 wpa_supplicant.conf ，配置待连接的WIFI信息。\ncountry=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;    ssid=&quot;WifiName&quot;    psk=&quot;Password&quot;    priority=1&#125;\n\n\n\n最后，boot分区根目录新建文件如下：\n\n\n到此，万事俱备，只欠东风。\n开机将SD卡插在树莓派背后，再接上电源。\n如果正常的话，此时树莓派红灯常亮（树莓派电源正常），绿灯闪烁（读写SD卡正常）。\n在之前的网络配置正常的前提下，我们通过路由器可查看到树莓派的IP地址。\n\n\n打开任意一款SSH工具（我这里用的是Xshell）\n输入相应IP地址和端口（默认22）\n\n\n接收主机密钥\n\n\n登录默认账号： pi\n\n\n默认密码： raspberry\n\n\n至此，我们已成功开机并登录！\n\n\n初次开机的一些配置换源第一次启动Linux，首先要做的当然是换源啦！\n这里以阿里源为例。\n首先查看系统代号：\nlsb_release -a\n\n\n\n我手上这块树莓派OS系统代号是buster（如果是其他版本，请自行更换下述代码中的buster），修改两处源\nsudo nano /etc/apt/sources.list\n\n将之前的用 # 注释掉，再加入以下内容：\ndeb http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpideb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi\n\n\n\n键入 Ctrl + O 保存键入 Enter（回车） 确认文件名键入 Ctrl + X 退出\nsudo nano /etc/apt/sources.list.d/raspi.list\n\n将之前的用 # 注释掉，再加入以下内容：\ndeb http://mirrors.aliyun.com/raspbian/raspbian/ buster maindeb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main\n\n\n\n键入 Ctrl + O 保存键入 Enter（回车） 确认文件名键入 Ctrl + X 退出\n更新源并升级：\nsudo apt-get update &amp;&amp; sudo apt-get upgrade\n\n校准时间选择Asia - ShangHai：\nsudo dpkg-reconfigure tzdata\n\n关机可得好好保护数据！关机时记得\nsudo shutdown -r now\n\n然后再断电！\n","tags":["Linux","树莓派"]},{"title":"用Photoshop实现IOS/MacOS的模糊效果","url":"/2022/07/28/%E7%94%A8Photoshop%E5%AE%9E%E7%8E%B0IOS-MacOS%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C/","content":"一、前言IOS/MacOS对于模糊的理解已然是登峰造极，但我们平常使用普通的高斯模糊却做不出这种效果，这是为什么呢？如何用Photoshop做出类似于IOS/MacOS那样好看的模糊呢？\n步骤1. 准备一张素材图片\n\n2. 导入PS\n\n3. 拷贝图层(Ctrl + J)\n\n4. 添加模糊滤镜选中拷贝的图层，选择滤镜 - 模糊 - 高斯模糊，半径根据需要可调30-50，或者其他适合的半径\n\n\n5. 绘制遮罩以一个圆角矩形为例，我们只需要其形状，因此该矩形的颜色或描边不需要管它。\n\n然后右键矩形图层 - 栅格化图层，并用魔棒工具选中该矩形形状\n\n然后选中模糊的图层，点击下方的添加图层蒙版按钮\n\n删除矩形图层，即可得到模糊遮罩\n\n但是效果看起来不太行！我们解锁模糊图层和蒙版，选中模糊图层，使用快捷键(Ctrl + u)打开色相窗口，将饱和度和明度进行适当调整。\n\n\n这下看起来好很多了，我们选中遮罩层，调整一下遮罩的位置和大小。\n\n针布戳\n","tags":["Photoshop","高斯模糊"]},{"title":"计算机视觉：OpenCV学习笔记","url":"/2022/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9AOpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"一、前言OpenCV是计算机视觉领域一款热门的框架，人脸识别、二维码处理、深度学习中都能见到它的身影~\n二、安装1. C++版安装\n在官网中下载OpenCV源码，本文以OpenCV – 4.5.5为例。\n\n安装相关依赖\nsudo apt-get install libgtk2.0-dev\n解压至任意目录\nunzip opencv-4.5.5.zip\n进入解压后的文件夹，创建build文件夹并进入\ncd opencv-4.5.5mkdir build &amp;&amp; cd build\nCMake生成Makefile\ncmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/ ..\n编译OpenCV（-j为线程数，视实际情况更改，太大可能会爆内存，实在不行就单线程吧hhh）\nmake -j8\n安装\nsudo make install\n验证（运行源码根目录下samples/cpp/example_cmake后弹出Hello OpenCV即为成功）\ncd ../samples/cpp/example_cmakecmake .make./opencv_example\n\n\n2. Python版安装通过pip安装\npip3 install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n三、基础用法\n本文主要记录基于Python的OpenCV笔记\n\n1. 导入OpenCVimport cv2\n\n2. 读取图片 - imread()img = cv2.imread(\"ari.jpg\")\n第一个参数是图片的路径，绝对路径和相对路径均可。第二个参数是可选参数，可填以下内容：\n\ncv2.IMREAD_COLOR（默认）： 加载彩色图像。任何图像的透明度都将被忽略。\ncv2.IMREAD_GRAYSCALE：以灰度模式加载图像。\ncv2.IMREAD_UNCHANGED：保留读取图片原有颜色通道（包括透明通道）。\n\n3. 显示图片 - imshow()cv2.imshow(\"ari\", img)\n第一个参数是窗口的标题，第二个参数传入读取的img对象。\n\n\n4. 调整窗口 - namedWindow()cv2.namedWindow(\"ari\")\n第一个参数是窗口的标题。第二个参数是可选参数，可填以下内容：\n\ncv2.WINDOW_NORMAL：可调整窗口大小。\ncv2.WINDOW_AUTOSIZE（默认）：窗口内容图片为真实大小，窗口大小不可调整。\ncv2.WINDOW_OPENGL：支持OpenGL。\n\n5. 等待按键 - waitKey()cv2.waitKey(0)\n当调用imshow()后，需要再调用waitKey()控制窗口显示时间。当参数≤0时，则窗口一直等待，返回 -1 或按键值，当为$time时，则窗口显示$timems，在此期间按键则返回按键值，否则返回 -1 。\n6. 保存图片 - imwrite()cv2.imwrite(\"ari_out.jpg\", img)\n第一个参数是保存的路径及名称，第二个参数传入读取的img对象。\n三、进阶操作1. 读取网络摄像机rtsp流import cv2cam = cv2.VideoCapture(\"rtsp://admin:123456@192.168.56.56:554/ch01.264\")  # rtsp流地址while cam.isOpened():    flag, img = cam.read()    cv2.imshow('Cam', img)    cv2.waitKey(1)  # 1ms刷新一次\n\n2. 单目相机标定与坐标系转换最近有一个项目需要将单目摄像机拍摄到的照片中的像素坐标转换为世界坐标，于是研究了一下相关的原理和代码。\n1) 原理在相机模型中，我们需要理解四个坐标系以及它们之间的关系：\n\n像素坐标系（u, v）\n图像坐标系（x, y）\n相机坐标系（Xc, Yc, Zc）\n世界坐标系（Xw, Yw, Zw）如图：\n\na. 像素坐标系（u, v）与图像坐标系（x, y）转换\n假设像素在u轴和v轴方向上的物理尺寸为dx和dy。根据上图可以推导出该公式：转换为矩阵形式：\nb. 相机坐标系（Xc, Yc, Zc）与世界坐标系（Xw, Yw, Zw）转换\n从世界坐标系变换到相机坐标系属于刚体变换，物体不会发生形变，只需进行旋转和平移。如上图，R表示旋转矩阵，T表示旋转向量。用矩阵表示其关系：\n令：因此可表示为\nc. 相机坐标系（Xc, Yc, Zc）与图像坐标系（x, y）转换\n如图，根据相似三角形原理，可得：可变换为：因此可用矩阵表示：\nd. 综合公式将上面的矩阵公式综合，即可得出以下公式：其中，称为相机内参。称为相机外参。\ne. 求解我们的需求是根据像素坐标求世界坐标，而世界坐标系建立在地面，因此可令Zw=0。即：将相机外参展开：化简可得：将上式改写为AX=B的形式：解出这个矩阵方程即可求解 世界坐标（Xw, Yw, 0） 以及 相机坐标系原点到所求点的直线距离Zc ！\n2) 实现未完待续…\n3) 参考\n世界坐标系、相机坐标系、图像平面坐标系\n\n","tags":["Linux","OpenCV"]}]