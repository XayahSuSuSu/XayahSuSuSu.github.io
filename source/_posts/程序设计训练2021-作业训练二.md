---
title: 程序设计训练2021-作业训练二
date: 2021-07-12 12:27:53
tags: [ 'CCF', 'C++' ]
---

# 导航

##### **[Python实现方案](https://www.seaeye.cn/archives/175.html)**

###### [一、字符串反转2](#字符串反转2)
###### [二、487-3279](#487-3279)
###### [三、缺席考试的是谁？](#缺席考试的是谁？)
###### [四、电话号码](#电话号码)
###### [五、点球大战](#点球大战)
###### [六、飞行棋](#飞行棋)
###### [七、棋盘](#棋盘)
###### [八、Engine-字符串](#Engine-字符串)
###### [九、字符串压缩](#字符串压缩)
###### [十、拼写检查](#拼写检查)
###### [十一、最小的K个数](#最小的K个数)
###### [十二、绩点计算](#绩点计算)
###### [十三、xxx定律](#xxx定律)
###### [十四、数的距离差](#数的距离差)
###### [十五、亲和数](#亲和数)
###### [十六、金币](#金币)
###### [十七、小A的计算器](#小A的计算器)
###### [十八、小丑排序](#小丑排序)
###### [十九、数圈](#数圈)
###### [二十、锤子剪刀布](#锤子剪刀布)
###### [二十一、新型冠状病毒（COVID19）传播](#新型冠状病毒（COVID19）传播)

# 字符串反转2

> 类型：字符串
>
> 难度：1

## 【问题描述】

&emsp;&emsp;给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： “hello xiao mi”-> “mi xiao hello”

## 【输入形式】

&emsp;&emsp;输入数据有多组，每组占一行，包含一个句子(句子长度小于1000个字符)

## 【输出形式】

&emsp;&emsp;对于每个测试示例，要求输出句子中单词反转后形成的句子

## 【样例输入】

    hello xiao mi
    I am a student

## 【样例输出】

    mi xiao hello
    student a am I

## 【思路】

&emsp;&emsp;利用栈的先入后出特性，将每个单词作为一个元素推入栈中，再依次出栈。

## 【代码（C++）】
```
#include <iostream>
#include <stack>
#include <sstream>

using namespace std;

int main() {
    stack<string> s;
    string str;
    stringstream sstream; // 利用字符串流得到每行的每个单词
    ios::sync_with_stdio(false); // 清除IO流缓存，使其效率接近scanf与printf
    cout.tie(nullptr); // 解除cout绑定 注意不要与printf混用
    while (getline(cin, str)) { // 以行读入
        sstream << str; //输入到字符串流
        string word;
        while (sstream >> word) { // 从字符串流流输出单词
            s.push(word); // 单词入栈
        }
        while (!s.empty()) {
            cout << s.top() << " ";
            s.pop(); // 将已输出单词出栈
        }
        cout << "\n";
        sstream.clear(); // 清空字符串流，避免未知错误
    }
}
```

# 487-3279

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;每个人都喜欢有令人难忘的电话号码。要想让电话号码变得令人难忘的一种方法是拼出一个令人难忘的单词或短语。例如，你可以拨打滑铁卢大学的电话，拨打令人难忘的电话号码TUT-GLOP。

&emsp;&emsp;有时只有一部分号码被用来拼写一个单词，例如，你可以拨打310-gino从Gino's订购披萨。

&emsp;&emsp;要使电话号码令人难忘的另一种方法是以一种令人难忘的方式对数字进行分组。你可以从比萨饼小屋中订购比萨饼，方法是拨打他们的“3个10”，即号码3-10-10-10。

&emsp;&emsp;电话号码的标准格式是七位的十进制数字，第三和第四位之间包含连字符（例如888-1200）。电话的键盘提供字母到数字的映射，如下所示：

&emsp;&emsp;A, B, C映射到2

&emsp;&emsp;D, E, F映射到3

&emsp;&emsp;G, H, I映射到4

&emsp;&emsp;J, K, L映射到5

&emsp;&emsp;M, N, O映射到6

&emsp;&emsp;P, R, S映射到7

&emsp;&emsp;T, U, V映射到8

&emsp;&emsp;W, X, Y映射到9

&emsp;&emsp;Q和Z没有映射。连接符不拨号，必要时可加上或去除。TUT-GLOP的标准格式是888-4567，310-GINO的标准格式是310-4466，3-10-10-10的标准格式是310-1010。

&emsp;&emsp;当两个电话号码有相同的标准格式时是等价的（拨同样的号码）。

&emsp;&emsp;你的公司正在编制本地企业的电话号码目录，作为质量控制的一部分，你需要检查没有两个（或多个）企业具有相同的电话号码。

## 【输入形式】

&emsp;&emsp;输入包括一个案例。输入的第一行为一个正整数，指定目录中电话号码的数目(最多100，000)。其余的各行列出目录中的电话号码，每个号码单独占一行。每个电话号码都是一个由十进制数字、大写字母(不包括Q和z)和连字符组成的字符串。字符串中的七个字符或是数字或是字母。

## 【输出形式】

&emsp;&emsp;对于出现超过一次的每个号码，按照标准格式及字典序每个输出一行，然后是空格，接着输出出现的次数。只出现1次的电话号码不输出。

## 【样例输入】

    12
    4873279
    ITS-EASY
    888-4567
    3-10-10-10
    888-GLOP
    TUT-GLOP
    967-11-11
    310-GINO
    F101010
    888-1200
    -4-8-7-3-2-7-9-
    487-3279

## 【样例输出】

    310-1010 2
    487-3279 4
    888-4567 3

## 【思路】

&emsp;&emsp;先将输入的号码标准格式化，按照字典序排序后，再计数判断并输出

## 【代码（C++）】
```
#include <iostream>
#include <sstream>
#include <algorithm>

using namespace std;

int main() {
    int n;
    cin >> n;
    string str[n]; // 定义最终字符串数组
    for (int i = 0; i < n; ++i) {
        string tmpNum; // 定义临时变量用于接收待处理号码
        stringstream sstream; // 定义字符串流用于处理号码中的每个字符
        stringstream sstreamOut; // 定义字符串流用于构造标准格式号码
        cin >> tmpNum;
        sstream << tmpNum; // 入流
        char a; // 定义单个字符用于接收
        int count = 0; // 处理的字符个数，用于判断是否到第三个数字以构造 '-'
        while (sstream >> a) {
            if (a != '-') {
                sstreamOut << a;
                count++;
                if (count == 3)
                    sstreamOut << '-'; // 构造 xxx-xxxx 中的 -
            }
        }
        string formatNum; // 定义标准格式号码
        sstreamOut >> formatNum; // 从字符串流输出到formatNum
        for (int j = 0; j < 8; ++j) { // 将号码中的字母转为数字
            if (formatNum[j] >= 'A' && formatNum[j] <= 'C')
                formatNum[j] = '2';
            else if (formatNum[j] >= 'D' && formatNum[j] <= 'F')
                formatNum[j] = '3';
            else if (formatNum[j] >= 'G' && formatNum[j] <= 'I')
                formatNum[j] = '4';
            else if (formatNum[j] >= 'J' && formatNum[j] <= 'L')
                formatNum[j] = '5';
            else if (formatNum[j] >= 'M' && formatNum[j] <= 'O')
                formatNum[j] = '6';
            else if (formatNum[j] >= 'P' && formatNum[j] <= 'S')
                formatNum[j] = '7';
            else if (formatNum[j] >= 'T' && formatNum[j] <= 'V')
                formatNum[j] = '8';
            else if (formatNum[j] >= 'W' && formatNum[j] <= 'Y')
                formatNum[j] = '9';
        }
        str[i] = formatNum; // 将构造好的标准格式号码赋值给最终的判断数组
    }
    sort(str, str + n); // 按照字典序排序
    int numCount = 1; // 定义号码出现次数，用于判断
    for (int i = 0; i < n - 1; ++i) {
//        cout << str[i] << endl;
        if (str[i] == str[i + 1]) { // 如果当前号码和下个号码一样，则计数+1
            numCount++;
        } else { // 如果不一样，当计数＞1时，按照格式输出，并且重新计数
            if (numCount > 1)
                cout << str[i] << " " << numCount << endl;
            numCount = 1;
        }
    }
}
```

# 缺席考试的是谁？

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;程序设计考试结束了，传来个不好的消息：有一个学生没参加考试!需要尽快知道缺席考试的人是谁，以便尽快做出处理。

&emsp;&emsp;糟糕的是，尽管有签到表，但由于人数较多，签到情况比较混乱：有的签到表签在一张白纸上，有的虽然签在名册上，但并不是签在自己姓名旁，更有学生签到了别的签到表上……

&emsp;&emsp;现在只能根据这2n-1个姓名（名册上有n个学生姓名，签到有n-1个姓名，签到姓名和名册姓名可能混在一起了），来找到缺席考试的人是谁。唯一一个有利的条件是所有参加考试的人都签了名，且只签一次，签名也都正确无误。

&emsp;&emsp;现在任务交给你：编写一个程序，找出缺席考试的是谁。

## 【输入形式】

&emsp;&emsp;有多组测试数据。

&emsp;&emsp;每组测试数据开始一行，是一个正整数n，表示总人数，n=0意味着输入结束并且不需要处理。

&emsp;&emsp;以下2n-1行，每行一个字符串，长度不超过20，表示一个人的姓名。姓名有大小写的英文字母、常用汉字组成(注意每个汉字占2个字节，中英文姓名都不排除有重名情况)。

&emsp;&emsp;40%的测试数据1 ≤ n≤ 10；

&emsp;&emsp;30%的测试数据1 ≤ n≤ 100；

&emsp;&emsp;20%的测试数据1 ≤ n≤ 103；

&emsp;&emsp;10%的测试数据1 ≤ n≤ 104；

&emsp;&emsp;提示：大量输入数据，C/C++输入推荐使用scanf函数

## 【输出形式】

&emsp;&emsp;对于每组测试数据，输出一行，只包含一个字符串，表示缺席的人的姓名。

## 【样例输入】

    2
    张三
    张三
    李四
    0

## 【样例输出】

    李四

## 【思路】

&emsp;&emsp;这里简单地讲解下 **scanf** 和 **map** 的用法。

#### scanf：

&emsp;&emsp;**scanf** 是一个 **C标准库函数** ，由 **两个参数** 组成

```
scanf($格式控制字符串, $地址表列);
```

&emsp;&emsp;**格式控制字符串：**

|类型|合格的输入|参数的类型|
|:-:|:-:|:-:|
|%a、%A|读入一个浮点值(仅 C99 有效)。|float|
|%c|单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。|char|
|%d|十进制整数：数字前面的 + 或 - 号是可选的。|int|
|%e、%E、%f、%F、%g、%G|浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4|float|
|%i|读入十进制，八进制，十六进制整数 。|int|
|%o|八进制整数。|int|
|%s|字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。|char|
|%u|无符号的十进制整数。|unsigned int|
|%x、%X|十六进制整数。|int|
|%p|读入一个指针 。|×|
|%[]|扫描字符集合 。|×|
|%%|读 % 符号。|×|

&emsp;&emsp;&emsp;&emsp;● **参考资料：**[C 库函数 - scanf()](https://www.runoob.com/cprogramming/c-function-scanf.html)

&emsp;&emsp;**地址表列：**

&emsp;&emsp;&emsp;&emsp;使用 **取地址符&**

&emsp;&emsp;&emsp;&emsp;由于这是一个 **C标准库函数** ，因此不能直接传入C++的string，需要使用char[]代替

&emsp;&emsp;&emsp;&emsp;示例：
```
int a,b,c;
scanf("%d, %d, %d",&a,&b,&c);
```
```
char name[20];
scanf("%s", name);
```

#### map：

&emsp;&emsp;**map** 是 **STL** 中的一个 **键值对容器** ，它提供 **一对一** 的 **Hash** ，相当于 **Python** 里的 **字典（Dictionary）** ，**JSON** 里的 **键(Key) 值 (Value)** 。

&emsp;&emsp;不过相比于上述两种概念，C++里的使用更加复杂。仅在此说明本题需要用到的地方。

&emsp;&emsp;以 **未使用命名空间std** 为例：

&emsp;&emsp;即 **未包含：**
```
using namespace std;
```

&emsp;&emsp;**引入头文件：**
```
#include <map>
```

&emsp;&emsp;**初始化：**
```
std::map<std::string, int> student;
```

&emsp;&emsp;**插入：**
```
student.insert(std::pair<std::string, int>(name, 1); // pair（位于 std:: 命名空间）将string和bool合成一组
```

&emsp;&emsp;**遍历：**
```
std::map<std::string, int>::iterator iterator; // 声明迭代器，类似于指针或者数组下标
for (iterator = student.begin(); iterator != student.end(); iterator++) {
    std::cout << iterator->first << ": " << iterator->second << endl;
    // iterator->first 相当于当前元素的第一个值， iterator->second 相当于当前元素的第二个值
}
```

&emsp;&emsp;**判断是否有重复键(Key)：**
```
std::pair<map<std::string, int>::iterator, bool> isExist; // pair将map的迭代器和bool合成一组
isExist = student.insert(std::pair<std::string, int>(name, 1));
if (!isExist.second) {
    student[name] += 1;
}
```


## 【代码（C++）】
```
#include <iostream>
#include <map>

using namespace std;

int main() {
    int n;
    while (cin >> n && n != 0) {
        map<string, int> student; // 定义学生姓名键值对 <姓名,计数>
        for (int i = 0; i < 2 * n - 1; ++i) {
            char name[20]; // 定义姓名字符数组（相当于字符串）
            scanf("%s", name); // 使用 scanf 输入姓名
            pair<map<string, int>::iterator, bool> isExist; // 定义检查重复性pair
            isExist = student.insert(pair<string, int>(name, 1)); // 若有重复项则isExist Value值为false
            if (!isExist.second) {
                student[name] += 1; // 计数+1
            }
        }
        map<string, int>::iterator iterator; // 定义map迭代器
        for (iterator = student.begin(); iterator != student.end(); iterator++) { // 遍历map
            // 请注意：题目中提示 “中英文姓名都不排除有重名情况”
            // 即若有两个人都叫 张三
            // 当两个 张三 都签到之后，map中 张三 的计数为 4
            // 若只有一个 张三 签到，而另一个 张三 没有签到时，map中 张三 的计数为 3
            // 因此，当map中的计数为偶数时，则无论是否有重名，重名者均已签到
            // 当map中的计数为奇数时，则无论是否有重名，必有一人未签到
            if (iterator->second % 2 != 0) {
                cout << iterator->first << endl;
            }
        }
    }
}
```

# 电话号码

> 类型：字符串，模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;程序设计考试结束了，传来个不好的消息：有一个学生没参加考试!需要尽快知道缺席考试的人是谁，以便尽快做出处理。

&emsp;&emsp;糟糕的是，尽管有签到表，但由于人数较多，签到情况比较混乱：有的签到表签在一张白纸上，有的虽然签在名册上，但并不是签在自己姓名旁，更有学生签到了别的签到表上……

&emsp;&emsp;现在只能根据这2n-1个姓名（名册上有n个学生姓名，签到有n-1个姓名，签到姓名和名册姓名可能混在一起了），来找到缺席考试的人是谁。唯一一个有利的条件是所有参加考试的人都签了名，且只签一次，签名也都正确无误。

&emsp;&emsp;现在任务交给你：编写一个程序，找出缺席考试的是谁。

## 【输入形式】

&emsp;&emsp;Vasya有几本电话簿，记录了他的朋友们的电话号码，每一个朋友都可以有一或几个电话号码。

&emsp;&emsp;Vasya决定整理关于朋友电话号码的信息。给定n个字符串，来自于Vasya的电话簿中的条目。每一条都以朋友的姓名开头，然后跟着当前条目中的电话号码个数，然后是本人的电话号码。有可能几个相同的电话被记录在同一个记录中。

&emsp;&emsp;Vasya还认为，如果电话号码a是电话号码b的后缀（也就是说，号码b以a结尾），这两个号码被当作同一个电话号码，那么a被认为是无城市代码，它不应该被考虑。

&emsp;&emsp;输出整理后Vasya朋友的电话号码信息。有可能两个不同的人有相同的号码。如果一个人有两个电话号码x和y，x是y的后缀（即y以x结尾），则不输出x。 

&emsp;&emsp;如果Vasya的电话簿中的某些朋友记录了几次，那么只需要记录一次。 

## 【输出形式】

&emsp;&emsp;输出Vasya的朋友的电话号码的有序信息。首先输出电话簿中的朋友数目m。

&emsp;&emsp;接下来的m行，包含以格式“姓名 电话号码个数 电话号码1 ... 电话号码k"的条目，号码间以空格分隔。每个记录包含当前朋友的所有电话号码。

&emsp;&emsp;每个条目输出按照姓名字母序进行排序，电话号码按照从小到大的顺序排列（注意电话号码比较规则："1"<"01"、"12"<"012"，依此类推）

## 【样例输入】

    4
    ivan 3 123 123 456
    ivan 2 456 456
    ivan 8 789 3 23 6 56 9 89 2
    dasha 2 23 789

## 【样例输出】

    2
    dasha 2 23 789 
    ivan 4 2 123 456 789

## 【思路】

&emsp;&emsp;定义结构体Friend，存储朋友的名字，号码数量，具体号码。合理利用动态数组（向量），存储时先判断是否再存储。这里在删除无城市前缀号码时，没有用迭代器实现，而是将无城市前缀号码赋值为一个不可能的号码 "*"，同时号码数量-1，在输出时不输出即可。

## 【代码（C++）】
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;

struct Friend {
    string name; // 名字
    int count = 0; // 号码数量
    vector<string> num; // 号码动态数组
};

void addNum(string num, Friend &f) {
    bool isExist = false;
    for (string &i : f.num) {
        if (num == i) {
            isExist = true;
        }
    }
    if (!isExist) {
        f.count++;
        f.num.push_back(num);
    }
} // 向某一个朋友添加号码，重复时忽略

void addFri(Friend &f, vector<Friend> &fs) {
    bool isExist = false;
    for (Friend &i : fs) {
        if (f.name == i.name) {
            isExist = true;
            for (string &j : f.num) {
                addNum(j, i);
            }
        }
    }
    if (!isExist) {
        fs.push_back(f);
    }
} // 向电话簿添加朋友的记录，重复时合并

bool cmp(string a, string b) {
    if (a.size() != b.size()) {
        // 注意电话号码比较规则：”1”<”01”、”12”<”012”，依此类推。
        // 这里我觉得题目没有说的太清楚，实际上 1 和 01 根本没有比较的可能，因为1已经作为无城市号码被忽略了。
        // 因此这里的意思其实是：2 < 01，03 < 002 ...
        return a.size() < b.size();
    } else {
        return a < b;
    }
} // 对某个朋友的号码动态数组进行排序的规则

void cleanNum(Friend &f) {
    for (auto &i:f.num) {
        for (auto &j:f.num) {
            if (i != j) {
                // 目标是是判断j的后缀是否是i
                stack<char> si, sj;
                for (char &k : i) {
                    si.push(k); // i入栈
                }
                for (char &k : j) {
                    sj.push(k); // j入栈
                }
                // 利用栈的先入后出特性，将i、j反转
                bool isBack = true;
                while (!si.empty()) {
                    if (si.top() == sj.top()) {
                        si.pop();
                        sj.pop();
                        // 相同则出栈
                    } else {
                        // 当存在不一样的字符，则i不是j的后缀
                        isBack = false;
                        break;
                    }
                }
                // 如果si弹栈到空栈每个字符都和sj一样，那么i就是j的后缀，将其标记为 *，同时计数-1
                if (isBack) {
                    i = "*";
                    f.count--;
                }
            }
        }
    }
} // 删除无城市号码

bool cmp2(Friend a, Friend b) {
    return a.name < b.name;
} // 对电话簿进行排序的规则

int main() {
    int n;
    cin >> n;
    vector<Friend> friends; // 定义号码簿动态数组
    for (int i = 0; i < n; ++i) {
        Friend f; // 定义朋友类
        int count; // 用于接收号码数量，以便后续接收具体号码
        cin >> f.name >> count;
        for (int j = 0; j < count; ++j) {
            string num;
            cin >> num;
            addNum(num, f); // 添加号码（重复则忽略）
        }
        addFri(f, friends); // 添加记录到号码簿（重复则合并）
    }
    sort(friends.begin(), friends.end(), cmp2); // 按照字典序对号码簿排序
    cout << friends.size() << endl; // 输出号码簿记录数量
    for (auto &i : friends) {
        sort(i.num.begin(), i.num.end(), cmp); // 对某条记录的号码动态数组排序
        cleanNum(i); // 清除无城市号码
        cout << i.name << " " << i.count << " "; // 先输出记录中的朋友名称和号码数量
        for (auto &j : i.num) {
            // 根据标记输出具体号码
            if (j != "*")
                cout << j << " ";
        }
        cout << endl;
    }
}
```

# 点球大战

> 类型：字符串
>
> 难度：3

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 飞行棋

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 棋盘

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# Engine-字符串

> 类型：字符串
>
> 难度：4

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 字符串压缩

> 类型：字符串
>
> 难度：4

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 拼写检查

> 类型：字符串，模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 最小的K个数

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 绩点计算

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# xxx定律

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 数的距离差

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 亲和数

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 金币

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 小A的计算器

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 小丑排序

> 类型：排序
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 数圈

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 锤子剪刀布

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 新型冠状病毒（COVID19）传播

> 类型：排序
>
> 难度：4

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```