---
title: 程序设计训练2021-作业训练二
date: 2021-07-12 12:27:53
tags: [ 'CCF', 'C++' ]
---

# 导航

##### **[Python实现方案](https://www.seaeye.cn/archives/175.html)**

###### [一、字符串反转2](#字符串反转2)
###### [二、487-3279](#487-3279)
###### [三、缺席考试的是谁？](#缺席考试的是谁？)
###### [四、电话号码](#电话号码)
###### [五、点球大战](#点球大战)
###### [六、飞行棋](#飞行棋)
###### [七、棋盘](#棋盘)
###### [八、Engine-字符串](#Engine-字符串)
###### [九、字符串压缩](#字符串压缩)
###### [十、拼写检查](#拼写检查)
###### [十一、最小的K个数](#最小的K个数)
###### [十二、绩点计算](#绩点计算)
###### [十三、xxx定律](#xxx定律)
###### [十四、数的距离差](#数的距离差)
###### [十五、亲和数](#亲和数)
###### [十六、金币](#金币)
###### [十七、小A的计算器](#小A的计算器)
###### [十八、小丑排序](#小丑排序)
###### [十九、数圈](#数圈)
###### [二十、锤子剪刀布](#锤子剪刀布)
###### [二十一、新型冠状病毒（COVID19）传播](#新型冠状病毒（COVID19）传播)

# 字符串反转2

> 类型：字符串
>
> 难度：1

## 【问题描述】

&emsp;&emsp;给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： “hello xiao mi”-> “mi xiao hello”

## 【输入形式】

&emsp;&emsp;输入数据有多组，每组占一行，包含一个句子(句子长度小于1000个字符)

## 【输出形式】

&emsp;&emsp;对于每个测试示例，要求输出句子中单词反转后形成的句子

## 【样例输入】

    hello xiao mi
    I am a student

## 【样例输出】

    mi xiao hello
    student a am I

## 【思路】

&emsp;&emsp;利用栈的先入后出特性，将每个单词作为一个元素推入栈中，再依次出栈。

## 【代码（C++）】
```
#include <iostream>
#include <stack>
#include <sstream>

using namespace std;

int main() {
    stack<string> s;
    string str;
    stringstream sstream; // 利用字符串流得到每行的每个单词
    ios::sync_with_stdio(false); // 清除IO流缓存，使其效率接近scanf与printf
    cout.tie(nullptr); // 解除cout绑定 注意不要与printf混用
    while (getline(cin, str)) { // 以行读入
        sstream << str; //输入到字符串流
        string word;
        while (sstream >> word) { // 从字符串流流输出单词
            s.push(word); // 单词入栈
        }
        while (!s.empty()) {
            cout << s.top() << " ";
            s.pop(); // 将已输出单词出栈
        }
        cout << "\n";
        sstream.clear(); // 清空字符串流，避免未知错误
    }
}
```

# 487-3279

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;每个人都喜欢有令人难忘的电话号码。要想让电话号码变得令人难忘的一种方法是拼出一个令人难忘的单词或短语。例如，你可以拨打滑铁卢大学的电话，拨打令人难忘的电话号码TUT-GLOP。

&emsp;&emsp;有时只有一部分号码被用来拼写一个单词，例如，你可以拨打310-gino从Gino's订购披萨。

&emsp;&emsp;要使电话号码令人难忘的另一种方法是以一种令人难忘的方式对数字进行分组。你可以从比萨饼小屋中订购比萨饼，方法是拨打他们的“3个10”，即号码3-10-10-10。

&emsp;&emsp;电话号码的标准格式是七位的十进制数字，第三和第四位之间包含连字符（例如888-1200）。电话的键盘提供字母到数字的映射，如下所示：

&emsp;&emsp;A, B, C映射到2

&emsp;&emsp;D, E, F映射到3

&emsp;&emsp;G, H, I映射到4

&emsp;&emsp;J, K, L映射到5

&emsp;&emsp;M, N, O映射到6

&emsp;&emsp;P, R, S映射到7

&emsp;&emsp;T, U, V映射到8

&emsp;&emsp;W, X, Y映射到9

&emsp;&emsp;Q和Z没有映射。连接符不拨号，必要时可加上或去除。TUT-GLOP的标准格式是888-4567，310-GINO的标准格式是310-4466，3-10-10-10的标准格式是310-1010。

&emsp;&emsp;当两个电话号码有相同的标准格式时是等价的（拨同样的号码）。

&emsp;&emsp;你的公司正在编制本地企业的电话号码目录，作为质量控制的一部分，你需要检查没有两个（或多个）企业具有相同的电话号码。

## 【输入形式】

&emsp;&emsp;输入包括一个案例。输入的第一行为一个正整数，指定目录中电话号码的数目(最多100，000)。其余的各行列出目录中的电话号码，每个号码单独占一行。每个电话号码都是一个由十进制数字、大写字母(不包括Q和z)和连字符组成的字符串。字符串中的七个字符或是数字或是字母。

## 【输出形式】

&emsp;&emsp;对于出现超过一次的每个号码，按照标准格式及字典序每个输出一行，然后是空格，接着输出出现的次数。只出现1次的电话号码不输出。

## 【样例输入】

    12
    4873279
    ITS-EASY
    888-4567
    3-10-10-10
    888-GLOP
    TUT-GLOP
    967-11-11
    310-GINO
    F101010
    888-1200
    -4-8-7-3-2-7-9-
    487-3279

## 【样例输出】

    310-1010 2
    487-3279 4
    888-4567 3

## 【思路】

&emsp;&emsp;先将输入的号码标准格式化，按照字典序排序后，再计数判断并输出

## 【代码（C++）】
```
#include <iostream>
#include <sstream>
#include <algorithm>

using namespace std;

int main() {
    int n;
    cin >> n;
    string str[n]; // 定义最终字符串数组
    for (int i = 0; i < n; ++i) {
        string tmpNum; // 定义临时变量用于接收待处理号码
        stringstream sstream; // 定义字符串流用于处理号码中的每个字符
        stringstream sstreamOut; // 定义字符串流用于构造标准格式号码
        cin >> tmpNum;
        sstream << tmpNum; // 入流
        char a; // 定义单个字符用于接收
        int count = 0; // 处理的字符个数，用于判断是否到第三个数字以构造 '-'
        while (sstream >> a) {
            if (a != '-') {
                sstreamOut << a;
                count++;
                if (count == 3)
                    sstreamOut << '-'; // 构造 xxx-xxxx 中的 -
            }
        }
        string formatNum; // 定义标准格式号码
        sstreamOut >> formatNum; // 从字符串流输出到formatNum
        for (int j = 0; j < 8; ++j) { // 将号码中的字母转为数字
            if (formatNum[j] >= 'A' && formatNum[j] <= 'C')
                formatNum[j] = '2';
            else if (formatNum[j] >= 'D' && formatNum[j] <= 'F')
                formatNum[j] = '3';
            else if (formatNum[j] >= 'G' && formatNum[j] <= 'I')
                formatNum[j] = '4';
            else if (formatNum[j] >= 'J' && formatNum[j] <= 'L')
                formatNum[j] = '5';
            else if (formatNum[j] >= 'M' && formatNum[j] <= 'O')
                formatNum[j] = '6';
            else if (formatNum[j] >= 'P' && formatNum[j] <= 'S')
                formatNum[j] = '7';
            else if (formatNum[j] >= 'T' && formatNum[j] <= 'V')
                formatNum[j] = '8';
            else if (formatNum[j] >= 'W' && formatNum[j] <= 'Y')
                formatNum[j] = '9';
        }
        str[i] = formatNum; // 将构造好的标准格式号码赋值给最终的判断数组
    }
    sort(str, str + n); // 按照字典序排序
    int numCount = 1; // 定义号码出现次数，用于判断
    for (int i = 0; i < n - 1; ++i) {
//        cout << str[i] << endl;
        if (str[i] == str[i + 1]) { // 如果当前号码和下个号码一样，则计数+1
            numCount++;
        } else { // 如果不一样，当计数＞1时，按照格式输出，并且重新计数
            if (numCount > 1)
                cout << str[i] << " " << numCount << endl;
            numCount = 1;
        }
    }
}
```

# 缺席考试的是谁？

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;程序设计考试结束了，传来个不好的消息：有一个学生没参加考试!需要尽快知道缺席考试的人是谁，以便尽快做出处理。

&emsp;&emsp;糟糕的是，尽管有签到表，但由于人数较多，签到情况比较混乱：有的签到表签在一张白纸上，有的虽然签在名册上，但并不是签在自己姓名旁，更有学生签到了别的签到表上……

&emsp;&emsp;现在只能根据这2n-1个姓名（名册上有n个学生姓名，签到有n-1个姓名，签到姓名和名册姓名可能混在一起了），来找到缺席考试的人是谁。唯一一个有利的条件是所有参加考试的人都签了名，且只签一次，签名也都正确无误。

&emsp;&emsp;现在任务交给你：编写一个程序，找出缺席考试的是谁。

## 【输入形式】

&emsp;&emsp;有多组测试数据。

&emsp;&emsp;每组测试数据开始一行，是一个正整数n，表示总人数，n=0意味着输入结束并且不需要处理。

&emsp;&emsp;以下2n-1行，每行一个字符串，长度不超过20，表示一个人的姓名。姓名有大小写的英文字母、常用汉字组成(注意每个汉字占2个字节，中英文姓名都不排除有重名情况)。

&emsp;&emsp;40%的测试数据1 ≤ n≤ 10；

&emsp;&emsp;30%的测试数据1 ≤ n≤ 100；

&emsp;&emsp;20%的测试数据1 ≤ n≤ 103；

&emsp;&emsp;10%的测试数据1 ≤ n≤ 104；

&emsp;&emsp;提示：大量输入数据，C/C++输入推荐使用scanf函数

## 【输出形式】

&emsp;&emsp;对于每组测试数据，输出一行，只包含一个字符串，表示缺席的人的姓名。

## 【样例输入】

    2
    张三
    张三
    李四
    0

## 【样例输出】

    李四

## 【思路】

&emsp;&emsp;这里简单地讲解下 **scanf** 和 **map** 的用法。

#### scanf：

&emsp;&emsp;**scanf** 是一个 **C标准库函数** ，由 **两个参数** 组成

```
scanf($格式控制字符串, $地址表列);
```

&emsp;&emsp;**格式控制字符串：**

|类型|合格的输入|参数的类型|
|:-:|:-:|:-:|
|%a、%A|读入一个浮点值(仅 C99 有效)。|float|
|%c|单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。|char|
|%d|十进制整数：数字前面的 + 或 - 号是可选的。|int|
|%e、%E、%f、%F、%g、%G|浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4|float|
|%i|读入十进制，八进制，十六进制整数 。|int|
|%o|八进制整数。|int|
|%s|字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。|char|
|%u|无符号的十进制整数。|unsigned int|
|%x、%X|十六进制整数。|int|
|%p|读入一个指针 。|×|
|%[]|扫描字符集合 。|×|
|%%|读 % 符号。|×|

&emsp;&emsp;&emsp;&emsp;● **参考资料：**[C 库函数 - scanf()](https://www.runoob.com/cprogramming/c-function-scanf.html)

&emsp;&emsp;**地址表列：**

&emsp;&emsp;&emsp;&emsp;使用 **取地址符&**

&emsp;&emsp;&emsp;&emsp;由于这是一个 **C标准库函数** ，因此不能直接传入C++的string，需要使用char[]代替

&emsp;&emsp;&emsp;&emsp;示例：
```
int a,b,c;
scanf("%d, %d, %d",&a,&b,&c);
```
```
char name[20];
scanf("%s", name);
```

#### map：

&emsp;&emsp;**map** 是 **STL** 中的一个 **键值对容器** ，它提供 **一对一** 的 **Hash** ，相当于 **Python** 里的 **字典（Dictionary）** ，**JSON** 里的 **键(Key) 值 (Value)** 。

&emsp;&emsp;不过相比于上述两种概念，C++里的使用更加复杂。仅在此说明本题需要用到的地方。

&emsp;&emsp;以 **未使用命名空间std** 为例：

&emsp;&emsp;即 **未包含：**
```
using namespace std;
```

&emsp;&emsp;**引入头文件：**
```
#include <map>
```

&emsp;&emsp;**初始化：**
```
std::map<std::string, int> student;
```

&emsp;&emsp;**插入：**
```
student.insert(std::pair<std::string, int>(name, 1); // pair（位于 std:: 命名空间）将string和bool合成一组
```

&emsp;&emsp;**遍历：**
```
std::map<std::string, int>::iterator iterator; // 声明迭代器，类似于指针或者数组下标
for (iterator = student.begin(); iterator != student.end(); iterator++) {
    std::cout << iterator->first << ": " << iterator->second << endl;
    // iterator->first 相当于当前元素的第一个值， iterator->second 相当于当前元素的第二个值
}
```

&emsp;&emsp;**判断是否有重复键(Key)：**
```
std::pair<map<std::string, int>::iterator, bool> isExist; // pair将map的迭代器和bool合成一组
isExist = student.insert(std::pair<std::string, int>(name, 1));
if (!isExist.second) {
    student[name] += 1;
}
```


## 【代码（C++）】
```
#include <iostream>
#include <map>

using namespace std;

int main() {
    int n;
    while (cin >> n && n != 0) {
        map<string, int> student; // 定义学生姓名键值对 <姓名,计数>
        for (int i = 0; i < 2 * n - 1; ++i) {
            char name[20]; // 定义姓名字符数组（相当于字符串）
            scanf("%s", name); // 使用 scanf 输入姓名
            pair<map<string, int>::iterator, bool> isExist; // 定义检查重复性pair
            isExist = student.insert(pair<string, int>(name, 1)); // 若有重复项则isExist Value值为false
            if (!isExist.second) {
                student[name] += 1; // 计数+1
            }
        }
        map<string, int>::iterator iterator; // 定义map迭代器
        for (iterator = student.begin(); iterator != student.end(); iterator++) { // 遍历map
            // 请注意：题目中提示 “中英文姓名都不排除有重名情况”
            // 即若有两个人都叫 张三
            // 当两个 张三 都签到之后，map中 张三 的计数为 4
            // 若只有一个 张三 签到，而另一个 张三 没有签到时，map中 张三 的计数为 3
            // 因此，当map中的计数为偶数时，则无论是否有重名，重名者均已签到
            // 当map中的计数为奇数时，则无论是否有重名，必有一人未签到
            if (iterator->second % 2 != 0) {
                cout << iterator->first << endl;
            }
        }
    }
}
```

# 电话号码

> 类型：字符串，模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;程序设计考试结束了，传来个不好的消息：有一个学生没参加考试!需要尽快知道缺席考试的人是谁，以便尽快做出处理。

&emsp;&emsp;糟糕的是，尽管有签到表，但由于人数较多，签到情况比较混乱：有的签到表签在一张白纸上，有的虽然签在名册上，但并不是签在自己姓名旁，更有学生签到了别的签到表上……

&emsp;&emsp;现在只能根据这2n-1个姓名（名册上有n个学生姓名，签到有n-1个姓名，签到姓名和名册姓名可能混在一起了），来找到缺席考试的人是谁。唯一一个有利的条件是所有参加考试的人都签了名，且只签一次，签名也都正确无误。

&emsp;&emsp;现在任务交给你：编写一个程序，找出缺席考试的是谁。

## 【输入形式】

&emsp;&emsp;Vasya有几本电话簿，记录了他的朋友们的电话号码，每一个朋友都可以有一或几个电话号码。

&emsp;&emsp;Vasya决定整理关于朋友电话号码的信息。给定n个字符串，来自于Vasya的电话簿中的条目。每一条都以朋友的姓名开头，然后跟着当前条目中的电话号码个数，然后是本人的电话号码。有可能几个相同的电话被记录在同一个记录中。

&emsp;&emsp;Vasya还认为，如果电话号码a是电话号码b的后缀（也就是说，号码b以a结尾），这两个号码被当作同一个电话号码，那么a被认为是无城市代码，它不应该被考虑。

&emsp;&emsp;输出整理后Vasya朋友的电话号码信息。有可能两个不同的人有相同的号码。如果一个人有两个电话号码x和y，x是y的后缀（即y以x结尾），则不输出x。 

&emsp;&emsp;如果Vasya的电话簿中的某些朋友记录了几次，那么只需要记录一次。 

## 【输出形式】

&emsp;&emsp;输出Vasya的朋友的电话号码的有序信息。首先输出电话簿中的朋友数目m。

&emsp;&emsp;接下来的m行，包含以格式“姓名 电话号码个数 电话号码1 ... 电话号码k"的条目，号码间以空格分隔。每个记录包含当前朋友的所有电话号码。

&emsp;&emsp;每个条目输出按照姓名字母序进行排序，电话号码按照从小到大的顺序排列（注意电话号码比较规则："1"<"01"、"12"<"012"，依此类推）

## 【样例输入】

    4
    ivan 3 123 123 456
    ivan 2 456 456
    ivan 8 789 3 23 6 56 9 89 2
    dasha 2 23 789

## 【样例输出】

    2
    dasha 2 23 789 
    ivan 4 2 123 456 789

## 【思路】

&emsp;&emsp;定义结构体Friend，存储朋友的名字，号码数量，具体号码。合理利用动态数组（向量），存储时先判断是否再存储。这里在删除无城市前缀号码时，没有用迭代器实现，而是将无城市前缀号码赋值为一个不可能的号码 "*"，同时号码数量-1，在输出时不输出即可。

## 【代码（C++）】
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;

struct Friend {
    string name; // 名字
    int count = 0; // 号码数量
    vector<string> num; // 号码动态数组
};

void addNum(string num, Friend &f) {
    bool isExist = false;
    for (string &i : f.num) {
        if (num == i) {
            isExist = true;
        }
    }
    if (!isExist) {
        f.count++;
        f.num.push_back(num);
    }
} // 向某一个朋友添加号码，重复时忽略

void addFri(Friend &f, vector<Friend> &fs) {
    bool isExist = false;
    for (Friend &i : fs) {
        if (f.name == i.name) {
            isExist = true;
            for (string &j : f.num) {
                addNum(j, i);
            }
        }
    }
    if (!isExist) {
        fs.push_back(f);
    }
} // 向电话簿添加朋友的记录，重复时合并

bool cmp(string a, string b) {
    if (a.size() != b.size()) {
        // 注意电话号码比较规则：”1”<”01”、”12”<”012”，依此类推。
        // 这里我觉得题目没有说的太清楚，实际上 1 和 01 根本没有比较的可能，因为1已经作为无城市号码被忽略了。
        // 因此这里的意思其实是：2 < 01，03 < 002 ...
        return a.size() < b.size();
    } else {
        return a < b;
    }
} // 对某个朋友的号码动态数组进行排序的规则

void cleanNum(Friend &f) {
    for (auto &i:f.num) {
        for (auto &j:f.num) {
            if (i != j) {
                // 目标是是判断j的后缀是否是i
                stack<char> si, sj;
                for (char &k : i) {
                    si.push(k); // i入栈
                }
                for (char &k : j) {
                    sj.push(k); // j入栈
                }
                // 利用栈的先入后出特性，将i、j反转
                bool isBack = true;
                while (!si.empty()) {
                    if (si.top() == sj.top()) {
                        si.pop();
                        sj.pop();
                        // 相同则出栈
                    } else {
                        // 当存在不一样的字符，则i不是j的后缀
                        isBack = false;
                        break;
                    }
                }
                // 如果si弹栈到空栈每个字符都和sj一样，那么i就是j的后缀，将其标记为 *，同时计数-1
                if (isBack) {
                    i = "*";
                    f.count--;
                }
            }
        }
    }
} // 删除无城市号码

bool cmp2(Friend a, Friend b) {
    return a.name < b.name;
} // 对电话簿进行排序的规则

int main() {
    int n;
    cin >> n;
    vector<Friend> friends; // 定义号码簿动态数组
    for (int i = 0; i < n; ++i) {
        Friend f; // 定义朋友类
        int count; // 用于接收号码数量，以便后续接收具体号码
        cin >> f.name >> count;
        for (int j = 0; j < count; ++j) {
            string num;
            cin >> num;
            addNum(num, f); // 添加号码（重复则忽略）
        }
        addFri(f, friends); // 添加记录到号码簿（重复则合并）
    }
    sort(friends.begin(), friends.end(), cmp2); // 按照字典序对号码簿排序
    cout << friends.size() << endl; // 输出号码簿记录数量
    for (auto &i : friends) {
        sort(i.num.begin(), i.num.end(), cmp); // 对某条记录的号码动态数组排序
        cleanNum(i); // 清除无城市号码
        cout << i.name << " " << i.count << " "; // 先输出记录中的朋友名称和号码数量
        for (auto &j : i.num) {
            // 根据标记输出具体号码
            if (j != "*")
                cout << j << " ";
        }
        cout << endl;
    }
}
```

# 点球大战

> 类型：字符串
>
> 难度：3

## 【问题描述】

&emsp;&emsp;在足球比赛中，有不少赛事，例如世界杯淘汰赛和欧洲冠军联赛淘汰赛中，当比赛双方经过正规比赛和加时赛之后仍然不分胜负时，需要进行点球大战来决定谁能够获得最终的胜利。点球大战的规则非常简单，两方轮流派出球员罚点球，每方各罚5个。当5轮点球结束以后如果仍然不分胜负，则进入一轮定胜负的阶段。两方各派一名球员罚点球，直到有一方罚进而另一方没有进为止。 

&emsp;&emsp;在北美职业冰球联赛中，也有点球大战。与足球的规则不同的是，它只先罚3轮点球，随后就进入一轮定胜负的阶段，而其他的规则完全一样。 

&emsp;&emsp;在本题中，输入将给出每次点球是否罚进，而你的任务则是输出一个“比分板”。

## 【输入形式】

&emsp;&emsp;输入包含多组数据。每组数据的第一行包含一个整数N(1<=N<=18)，表示双方总共罚了多少个点球，N=0表示输入结束。随后有N行，每行是一个如下形式的字符串： 

&emsp;&emsp;&emsp;&emsp;●XXXX good：表示这个点球罚进 

&emsp;&emsp;&emsp;&emsp;●或者XXXX no good：表示这个点球没有罚进 

&emsp;&emsp;&emsp;&emsp;●其中XXXX表示球员名字（全部由字母和空格组成，保证不会出现歧义） 

&emsp;&emsp;&emsp;&emsp;●每一行保证不超过100个字符。 

&emsp;&emsp;&emsp;&emsp;●XXXX和good以及XXXX和no、no和good之间保证有且只有1个空格。 

&emsp;&emsp;&emsp;&emsp;●good、no good都是小写。本题是大小写相关的。 

&emsp;&emsp;数据不保证点球大战一定结束，也不保证在结束以后立即结束这组数据（即：不用判断点球大战是否结束，只用把罚进的点球往比分上加即可）。

## 【输出形式】

&emsp;&emsp;对每组数据，输出一个比分板。

&emsp;&emsp;一个点球如果罚进，则在对应的地方标上’O’，如果没有进则标上’X’。

&emsp;&emsp;先罚球的队伍的信息在上面，后罚的在下面。

&emsp;&emsp;最右边标上两队的比分。具体格式参考样例输出。

&emsp;&emsp;注意如果一轮点球只罚了一个，则后面那个点球对应的地方写上’-’。

## 【样例输入】

    6
    Riise good
    Ballack good
    Gerrard no good
    Lampard no good
    Fernando Torres good
    Malouda good
    9
    Christiano Ronaldo no good
    Messi no good
    Giggs good
    Abidal no good
    Carrick good
    Ronaldinho good
    Rooney good
    Henry no good
    Tevez good
    0

## 【样例输出】

    1 2 3 Score
    O X O 2
    O X O 2
    1 2 3 4 5 Score
    X O O O O 4
    X X O X - 1

## 【思路】

&emsp;&emsp;逐行解析进球数并存储在数组中，按照奇偶关系分割出两个球队的得分情况，再依次输出

## 【代码（C++）】
```
#include <iostream>
#include <sstream>
#include <vector>

using namespace std;

int main() {
    int N;
    while (cin >> N && N != 0) {
        string line; // 接收每行数据
        stringstream sstream; // 定义字符串流，用于对每行非空格数据处理
        vector<char> socre; // 定义得分情况动态数组
        cin.ignore(); // 清除缓存，避免影响后续getline()
        for (int i = 0; i < N; ++i) {
            getline(cin, line); // 按行输入
            sstream << line;  // 入流
            string word; // 定义每行每单位非空格数据变量
            vector<string> v; // 将非空格数据存入动态数组
            while (sstream >> word) {
                v.push_back(word); // 入组
            }
            sstream.clear(); // 清空字符串流，避免影响下次操作
            bool isIn = true; // 定义是否进球标志
            for (int j = 0; j < v.size(); ++j) {
                if (v[j] == "good" && j != 0) {
                    // 如果当前单词是good并且它不在首位
                    if (v[j - 1] == "no") {
                        // 如果当前单词是good，并且与它相邻的前一个单词是no
                        isIn = false;
                    }
                }
            }
            if (isIn)
                socre.push_back('O');
            else
                socre.push_back('X');
        }
        for (int i = 0; i < (socre.size() + 1) / 2; ++i) {
            // 得分情况动态数组中，（siez+1）÷2即为最高得分
            cout << i + 1 << " ";
        }
        cout << "Score" << endl;
        int count = 0;
        for (int i = 0; i < N; ++i) {
            if (i % 2 == 0) {
                // 如果索引对2的余数是0，则是第一个球队的得分情况
                cout << socre[i] << " ";
                if (socre[i] == 'O')
                    count++;
            }
        }
        cout << count << endl;
        count = 0;
        for (int i = 0; i < N; ++i) {
            if (i % 2 != 0) {
                // 如果索引对2的余数不是0，则是第二个球队的得分情况
                cout << socre[i] << " ";
                if (socre[i] == 'O')
                    count++;
            }
        }
        if (N % 2 != 0) {
            // 如果N是奇数，那么第二只球队必少罚一球
            cout << "-" << " ";
        }
        cout << count << endl;
    }

}
```

# 飞行棋

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;大家当年一定都下过飞行棋吧。现在Lele和Yueyue要下的棋和这个很相似，只是更简单一点而已。

&emsp;&emsp;棋盘由N个格子组成，分别标记为第0格到第N-1格。格子分为两种，一种是普通格子，即表示在该格可以停留。否则是特殊的格子，一旦走到上面，就要根据上面标记的数飞到相应的格子上。如果飞到一个特殊的格子上，则可以继续飞。

&emsp;&emsp;除了第0格外，其他格子都只能容纳一个玩家。即一旦A玩家已经在某个格子上，B玩家又走到这里，A玩家则会被踢回第0格，而B玩家留在这个格子上面。

&emsp;&emsp;第N-1个格子是终点，一旦一个玩家走到这个格子上，该玩家获胜，游戏结束。

&emsp;&emsp;刚刚开始时，两个玩家都站在第0格上，依次扔骰子，根据骰子显示的点数走相应的格子数。比如，玩家在第0格，扔出了5点，则会走到第5个格子上。如果玩家走得超出了棋盘的范围，则要往回走一定的步数。比如，棋盘一共有7(0~6)个格子,玩家在第4格上，扔出了6点，最终他会走到第2格上(4->5->6->5->4->3->2)。

&emsp;&emsp;根据观察，骰子扔出来的数也是有规律的。
对于每一盘棋，扔出的第一个点数为 F0=(A*C+B)%6+1,第二个点数为 F1=(A*F0+B)%6+1,第三个点数为 F2=(A*F1+B)%6+1 ....依此类推。

&emsp;&emsp;每一盘棋都是由Lele先走，现在就请你当裁判，看谁能获胜。

## 【输入形式】

&emsp;&emsp;本题目包含多组测试，请处理到文件结束。

&emsp;&emsp;每组数据占两行。

&emsp;&emsp;第一行有4个整数N,A,B,C(含义见题目描述，6<N<200,0<=A,B,C<=2^31)。

&emsp;&emsp;第二行有N个字符串，分别表示棋盘上第0个到第N-1个格子的内容。两个字符串之间用一个空格分隔开。

&emsp;&emsp;如果字符串为"N",则表示这个格子为普通格子。否则字符串为"GX"(X为0到N-1之间的整数)的形式，其中X表示玩家走到这个格子时，要马上飞到第X个格子。

&emsp;&emsp;数据保证第0个和第N-1个格子一定为"N"。

## 【输出形式】

&emsp;&emsp;对于每组数据，在一行内输出结果。

&emsp;&emsp;如果Lele能赢这盘棋，则输出"Lele",如果Yueyue赢的话，就输出"Yueyue"。

## 【样例输入】

    7 1 0 6
    N G3 N N N N N
    7 1 0 6
    N G4 N N N N N

## 【样例输出】

    Lele
    Yueyue

## 【思路】

&emsp;&emsp;将格子抽象化为数组，将所有格子都想成特殊格，而普通格则为对应本身的特殊格，其下标与位置对应，其值与其格对应的位置对应。

&emsp;&emsp;按照题目所给公式计算每一次投掷骰子的步数。

&emsp;&emsp;根据骰子得到的步数计算两人每次游戏的位置，最后再判断谁到达终点。

## 【代码（C++）】
```
#include <iostream>
#include <vector>

using namespace std;

int getStep(int A, int C, int B) {
    return (A * C + B) % 6 + 1;
}// 根据公式计算每一次掷骰子得到的步数

int main() {
    int N, A, B, C; // 定义题目所需变量
    while (cin >> N >> A >> B >> C) {
        // “本题目包含多组测试，请处理到文件结束。”
        // 使用while(cin>>xxx)
        vector<int> cell; // 定义格子的动态数组
        // 将所有的格子都想成特殊格，格子数组的值为其对应需要走到的格子位置
        // 普通格的值即为其本身的位置，而特殊格的值是相应G后面的数值
        for (int i = 0; i < N; ++i) {
            string s; // 定义临时变量s，用于接收格子数据
            cin >> s; // 输入
            if (s[0] == 'N') {
                // 如果是普通格，则直接推入
                cell.push_back(i);
            } else {
                // 如果是特殊格，则将第一个字符设置为0，然后转为int推入
                s[0] = '0';
                cell.push_back(stoi(s));
            }
        }
        bool isLele = true; // 设置标志符，判定当前是谁走
        int mC = C; // 初始化投掷步数
        int Lele = 0, Yueyue = 0; // 初始化两人的位置
        while (true) {
            mC = getStep(A, mC, B); // 第n次掷骰子得到的步数
            int mStep = cell[mC]; // 获取这个格子对应的实际格子位置
//            while (mStep != cell[mStep]) {
//                mStep = cell[mStep];
//            }
            // “特殊的格子，一旦走到上面，就要根据上面标记的数飞到相应的格子上。
            // 如果飞到一个特殊的格子上，则可以继续飞。”
            // 这个循环是针对连续特殊格的情况
            // 奇怪的是，这个循环加上去之后会有两个样例超时
//            cout << "mC: " << mC << endl;
            if (isLele) {
                // 如果是Lele
                Lele += mStep; // 步数计算
//                cout << "Lele: " << Lele << endl;
                if (Lele > N - 1) {
                    Lele = N - 1 - (Lele - (N - 1)); // 如果已经到头了，就返回
                }
                if (Lele == Yueyue) {
                    Yueyue = 0; // 如果相遇，则把Yueyue踢回起点
                }
                if (Lele == N - 1) {
                    // 到达终点
                    cout << "Lele" << endl;
                    break;
                }
            } else {
                // 如果是Yueyue
                Yueyue += mStep; // 步数计算
//                cout << "Yueyue: " << Yueyue << endl;
                if (Yueyue > N - 1) {
                    Yueyue = N - (Yueyue - (N - 1)); // 如果已经到头了，就返回
                }
                if (Yueyue == Lele) {
                    Lele = 0; // 如果相遇，则把Lele踢回起点
                }
                if (Yueyue == N - 1) {
                    // 到达终点
                    cout << "Yueyue" << endl;
                    break;
                }
            }
            isLele = !isLele; // 取反
        }
    }

}
```

# 棋盘

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;棋盘是指一个行和列编号从1~N的NxN的二进制矩阵，当行号和列号之和为偶数时该矩阵对应位置为黑色的(1)，否则为白色的(0)。以下图示为N=1、2、3时的棋盘。

{% asset_img board.jpg 棋盘 %}

&emsp;&emsp;给出一个NxN的二进制矩阵，请找出位于该矩阵内的最大尺寸的完整棋盘，以及最大尺寸棋盘的数量（棋盘可以交叠）。

## 【输入形式】

&emsp;&emsp;每个测试用例的第一行是一个正整数N(1<=N<=2000)，表示給定矩阵的行数和列数，接下来的N行描述了这个矩阵：每行有N个字符，既可以是“1”（代表黑块），也可以是“0”（代表白块）。矩阵至少包含一个“1”字符。

## 【输出形式】

&emsp;&emsp;输出最大尺寸棋盘的行列的大小，以及最大棋盘的个数，以空格分隔。

## 【样例输入】

    5
    00101
    11010
    00101
    01010
    11101

## 【样例输出】

    3 3

## 【思路】

&emsp;&emsp;值为1的格即为最小的棋盘，而每个更大的棋盘其左上角值必是1。因此遍历整个棋盘，逢1判断。

## 【代码（C++）】
```
#include <iostream>
#include <stack>

using namespace std;

int main() {
    int N;
    cin >> N;
    int matrix[N][N]; // 定义矩阵数组
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            char a;
            cin >> a;
            matrix[i][j] = a - 48; // char '0' 与 int 0 的ASCII码相差48
//            cout << matrix[i][j] << " ";
        }
//        cout << "\n";
    }
    int size[N]; // 定义棋盘尺寸数组，下标+1为其尺寸大小，值为其数量
    int tmpMaxSize; // 定义临时最大尺寸变量
    for (int i = 0; i < N; ++i) {
        size[i] = 0; // 初始化为0
    }
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            // matrix[i][j]为当前基点
            if (matrix[i][j] == 1) {
                // 值为1才有可能成为一个棋盘
                tmpMaxSize = min(N - i, N - j);
                // 计算其理论上最大边界长度
//                cout << "N - i: " << N - i << endl;
//                cout << "N - j: " << N - j << endl;
//                cout << "tmpMaxSize: " << tmpMaxSize << endl;
                for (int k = 1; k <= tmpMaxSize; ++k) {
                    // 边界长度至少为1
                    bool isMatrix = true; // 标志符，用于判断是否是矩阵
                    for (int l = 0; l < k; ++l) {
                        // 纵列
                        for (int m = 0; m < k - 1; ++m) {
                            // 横列
                            if (matrix[i + l][j + m] == matrix[i + l][j + m + 1]) {
                                // 如果当前格与其右边格值一样，则不满足要求
                                isMatrix = false;
                                break;
                            }
                        }
                        if (l != 0) {
                            if (matrix[i + l][j] == matrix[i + l - 1][j]) {
                                // 如果当前格与其上边格值一样，则不满足要求
                                isMatrix = false;
                            }
                        }
                        if (!isMatrix) {
                            // 如果不是矩阵，直接跳出循环，节省时间
                            break;
                        }
                    }
                    if (isMatrix)
                        // 如果是矩阵，则在矩阵数组里记录
                        size[k - 1]++;
                }
            }
        }
    }
    stack<int> s; // 定义栈，利用其先入后出的特性反向查找矩阵数组中的最大值及其数量
    for (int i = 0; i < N; ++i) {
        s.push(size[i]); // 入栈
//        cout << size[i] << " ";
    }
    int count = 0, maxSize = 0; // 定义计数和最大尺寸变量
    while (!s.empty()) {
        if (s.top() == 0) {
            // 如果栈顶是0，那么这个尺寸的棋盘不存在
            s.pop(); // 弹栈
            count++; // 计数+1
        } else {
            // 反之则找到棋盘的最大尺寸，跳出循环
            maxSize = s.top(); // 赋值
            break;
        }
    }
    cout << N - count << " " << maxSize; // 输出
}
```

# Engine-字符串

> 类型：字符串
>
> 难度：4

## 【问题描述】

&emsp;&emsp;谷歌、百度等搜索引擎已经成为了互连网中不可或缺的一部分。在本题中，你的任务也是设计一个搜索论文的搜索引擎，当然，本题的要求比起实际的需求要少了许多。

&emsp;&emsp;本题的输入将首先给出一系列的论文，对于每篇论文首先给出标题，然后给出它被引用的次数。然后会有一系列的搜索询问，询问标题中包含特定关键词的论文有哪些。

&emsp;&emsp;每一个询问可能包含多个关键词，你需要找出标题包含所有关键词的论文。

&emsp;&emsp;“包含”必须是标题中有一个词正好是给定的关键词，不区分大小写。

&emsp;&emsp;对每个询问，都按被引用的次数从多到少输出满足条件的论文的标题。如果有被引用的次数相同的论文，则按照论文在输入中的顺序排列，先给出的论文排在前面。

## 【输入形式】

&emsp;&emsp;每组数据首先有一行包含一个整数N(1<=N<=1000)，表示论文的数目，N=0表示输入结束。每组论文的信息第一行是论文的标题，由字母（大小写均可）和空格组成，不超过10个词，每个词不超过20个字符，标题总共不超过250个字符。第二行是一个整数K(0<=K&&<=108)，表示它被引用的次数。在论文信息结束以后，有一行包含一个整数M(1<=M<=100)，表示询问的数目。接下来有M行，每行是一个询问，由L(1<=L<=10)个空格分开的词构成，每个词不超过20个字符。

## 【输出形式】

&emsp;&emsp;对每个询问，按照题目给定的顺序输出满足条件的论文的标题；如果没有满足条件的论文，就不输出。在每组询问的输出之后输出一行“\*\*\*”，在每组数据的输出之后输出一行“---”。

## 【样例输入1】

    6
    Finding the Shortest Path
    120
    Finding the k Shortest Path
    80
    Find Augmenting Path in General Graph
    80
    Matching in Bipartite Graph
    200
    Finding kth Shortest Path
    50
    Graph Theory and its Applications
    40
    6
    shortest path
    k shortest path
    graph
    path
    find
    application
    0

## 【样例输出1】

    Finding the Shortest Path
    Finding the k Shortest Path
    Finding kth Shortest Path
    ***
    Finding the k Shortest Path
    ***
    Matching in Bipartite Graph
    Find Augmenting Path in General Graph
    Graph Theory and its Applications
    ***
    Finding the Shortest Path
    Finding the k Shortest Path
    Find Augmenting Path in General Graph
    Finding kth Shortest Path
    ***
    Find Augmenting Path in General Graph
    ***
    ***
    ---

## 【样例输入2】

    1
    Finding the Shortest Path
    120
    2
    Path
    Pat
    0

## 【样例输出2】

    Finding the Shortest Path
    ***
    ***
    ---

## 【样例说明】

&emsp;&emsp;需要查询的内容为“k shortest path”，他包含了3个独立的关键词。

## 【思路】

&emsp;&emsp;先将文章及引用次数用结构体数组存储，然后根据题目要求排序，再依次按照询问输出。

## 【代码（C++）】
```
#include <iostream>
#include <algorithm>
#include <sstream>
#include <vector>
#include <stack>

using namespace std;

struct Article {
    string title; // 标题
    string titleLow; // 标题（小写字母）
    int times = 0; // 引用次数
    vector<string> word; // 小写标题关键词动态数组
}; // 文章结构体

bool cmp(Article a, Article b) {
    return a.times > b.times;
} // 逆序排序规则

int main() {
    int N;
    while (cin >> N && N != 0) {
        Article articles[N]; // 定义文章数组
        stringstream sstream; // 定义字符串流
        for (int i = 0; i < N; ++i) {
            // cin和getline混用请注意缓存区换行符问题
            cin.ignore();
            getline(cin, articles[i].title);
            cin >> articles[i].times; // 输入引用次数
            articles[i].titleLow = articles[i].title; // 复制原标题
            // 利用 algorithm 里的transform函数将字符串转换为小写
            transform(articles[i].titleLow.begin(), articles[i].titleLow.end(), articles[i].titleLow.begin(),
                      ::tolower);
            sstream << articles[i].titleLow; // 入流
            string tmpWord; // 定义临时单词变量
            while (sstream >> tmpWord) {
                articles[i].word.push_back(tmpWord); // 将小写化标题的每个关键字存入
            }
            sstream.clear(); // 使用后注意清空
        }
        stable_sort(articles, articles + N, cmp); // 要求引用次数相同且原序不变，则使用 algorithm 中的稳定排序算法
        int M;
        cin >> M;
        string keyWord; // 定义询问变量
        for (int i = 0; i < M; ++i) {
            if (i == 0)
                cin.ignore(); // cin和getline混用请注意缓存区换行符问题
            getline(cin, keyWord);
            if (keyWord.empty()) {
                // 防止getline读入换行符造成数据紊乱
                // 实际上测试数据在讯问过程中没有直接输入换行符，所以注释不影响ac
                i--;
                continue;
            }
            // 将输入的询问全部转为小写
            transform(keyWord.begin(), keyWord.end(), keyWord.begin(), ::tolower);
            for (int j = 0; j < N; ++j) {
                string key; // 定义单个关键词变量
                sstream << keyWord; // 询问入流
                stack<string> s; // 定义栈，用于判断某个文章标题是否含有全部关键词
                while (sstream >> key) {
                    s.push(key); // 将询问关键词依次入栈，这里用队列也可以
                }
                sstream.clear(); // 使用后注意清空
                int size = s.size(); // s的size理论不超过int最大值，因此直接用int存就可以了
                for (int k = 0; k < size; ++k) {
                    // 循环size次，每次循环中关键词匹配则出栈
                    // 最后若空栈则该文章标题中含有全部关键词
                    for (auto &l : articles[j].word) {
                        if (s.top() == l) {
                            s.pop();
                            break;
                        }
                    }
                }
                if (s.empty())
                    cout << articles[j].title << endl;
            }
            cout << "***" << endl;
        }
        if (!keyWord.empty())
            cout << "---" << endl;
    }
}
```

# 字符串压缩

> 类型：字符串
>
> 难度：4

## 【问题描述】

&emsp;&emsp;给定一个由n个小写字母组成的字符串s，需要使用最少数量的钱币来压缩它。

&emsp;&emsp;压缩该字符串，必须将s表示为多个相互连接的非空字符串: s=t1t2...tk，其中第 i 个字符串按照下列两种方法之一编码：

&emsp;&emsp;&emsp;&emsp;●如果|ti|=1，也就是说 ti为单个字符组成的字符串，编码时需要支付a个钱币

&emsp;&emsp;&emsp;&emsp;●如果ti是t1t2...ti-1的子串，编码时需要支付b个钱币

&emsp;&emsp;你的任务是计算压缩给定的字符串需要花费的最小钱币数。

## 【输入形式】

&emsp;&emsp;输入的第一行包含3个用空格分隔的正整数：n、a和b(1≤n、a、b≤5000)，第二行为一个长度为n的小写字符串。

## 【输出形式】

&emsp;&emsp;输出一个整数，表示你需要为压缩s所需要支付的最小钱币数。

## 【样例输入1】

    3 3 1
    aba

## 【样例输出1】

    7

## 【样例输入2】

    4 1 1
    abcd

## 【样例输出2】

    4

## 【样例输入3】

    4 10 1
    aaaa

## 【样例输出3】

    12

## 【思路】

&emsp;&emsp; **动态规划法仅得到某种意义上的局部最优解** 

    37 10 30
    cdddccbdcdcdcdbcbdcbcdddccadcdcddaaab

&emsp;&emsp;&emsp;&emsp;● 感谢 **[B1ue1nWh1te](https://www.seaeye.cn/)** 提供的数据。

&emsp;&emsp;若按照普通的动态规划法计算，最后该样例得到的答案为 **320** ，而优化后的算法才能得到正确答案  **310**

----------------------------------------------------------

&emsp;&emsp;动态规划法的思想是 **局部最优** 得到 **整体最优** ，那么将字符串s **逆置** ，从逆置后的 **第一个字符** 开始，若第一个字符能够在剩下的字符串中找到，便试图寻找 **前两个字符** 组成的字符串能否在剩下的字符串中找到，直到找到能够在剩下字符串中找到的 **最长左字符串** 。

&emsp;&emsp;此时，需要判断 **局部最优情况** ，是 **b钱币方案** 花费更少还是 **a钱币方案** 花费更少？还是相同？如果 **b钱币方案** 花费更少，那么当然选择该方案。如果两者相同甚至 **a钱币方案** 花费更少，那么就选择 **a钱币方案** （此处落入局部最优 **非** 全局最优 **陷阱** ）

&emsp;&emsp; **（优化后）** 只处理最左边的 **第一个字符** 。

&emsp;&emsp;&emsp;&emsp;例如，

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;● a = 30，b = 10。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;● cdddccbdcdcdcdbcbdcb **cdd** dccadcd **cdd** aaab

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;● cdddccbdc **dcdcd** bcbdcbcdddcca **dcdcd** daaab

&emsp;&emsp;&emsp;&emsp;当处理到从右往左数第 **10** 个字符时，哪种方案花费更少？

## 【代码（C++）】
```
#include <iostream>
#include <sstream>
#include <stack>

using namespace std;

int main() {
    int n, a, b;
    cin >> n >> a >> b;
    string mStr;
    cin >> mStr;
    // 输入题目所给数据
    stringstream sstream; // 定义字符串流，用于逆置字符串s
    for (int i = (int) mStr.size() - 1; i >= 0; --i) {
        sstream << mStr[i]; // 逆置入流
    }
    string mRts; // 定义逆置后的字符串
    sstream >> mRts; // 存入
    sstream.clear(); // 清空字符串流
    int payment = 0; // 初始化最终所需要支付的最小钱币数
    while (!mRts.empty()) {
        // 将逆置的字符串分为左右两个部分，每次处理左边的部分，直到右边的部分为空
        // 每次循环处理后，mRts = 剩下的右边部分
//        cout << "mRts: " << mRts << endl;
        stack<string> leftStack; // 定义左边部分的栈，用于回退得值
        stack<string> rightStack; // 定义右边部分的栈，用于回退得值
        for (int i = 1; i <= mRts.size(); ++i) {
            // 从1开始，查看长度为i的左边部分是否能在右边找到
            stringstream leftSstream; // 定义左流
            for (int j = 0; j < i; ++j) {
                leftSstream << mRts[j];
            }
            stringstream rightSstream; // 定义右流
            for (int j = i; j < mRts.size(); ++j) {
                rightSstream << mRts[j];
            }
            string leftStr, rightStr; // 定义左字符串，右字符串
            leftSstream >> leftStr; // 出流
            rightSstream >> rightStr; // 出流
            leftStack.push(leftStr); // 左字符串入栈
            rightStack.push(rightStr); // 右字符串入栈
            leftSstream.clear(); // 清空字符串流
            rightSstream.clear(); // 清空字符串流
//            cout << "leftStr: " << leftStr << endl;
//            cout << "rightStr: " << rightStr << endl;
//            cout << "--------------------------" << endl;
            if (rightStack.top().find(leftStack.top()) <= rightStack.top().size()) {
                // 如果在右边部分找到了左边部分的字符串，则继续进行下一次循环
                // 直到找不到为止，此时利用栈的特性退回到上次的左字符串和右字符串
                continue;
            } else {
                // 此时右字符串中已经找不到左字符串。
                // 根据栈的大小判断，如果栈大小为1，那么左边长度为1的字符串都不能在右边找到
                // 那么只能满足支付a个钱币的条件
                // 如果栈的大小大于1，那么左边字符串的花费可能比每个字符支付a个钱币的花费更少
                // 什么时候左边字符串的花费比每个字符支付a个钱币的花费相同或更多呢？
                // a = 10 b = 30
                // cc c -- 更多
                // ccc ccc  -- 相同
                if (leftStack.size() > 1) {
                    // 栈大小大于1的情况
                    leftStack.pop(); // 弹栈退回上次的左字符串
                    rightStack.pop(); // 弹栈退回上次的右字符串
                    if (b < a * leftStack.top().size()) {
                        // 左边字符串的花费比每个字符支付a个钱币的花费更少
                        // 那么就采用这个方案
                        payment += b;
//                        cout << "b < a * leftStack.top().size()" << endl;
                    } else {
                        // 否则，退回最上层右字符串，使左字符串长度为1，然后进行下一次处理
                        while (!rightStack.empty()) {
                            if (rightStack.size() == 1)
                                mRts = rightStack.top(); // 得到最上层右字符串
                            rightStack.pop();
                        }
                        payment += a; // 仅当作左字符串为1处理
//                        cout << "b >= a * leftStack.top().size()" << endl;
                        break;
                    }
                    mRts = rightStack.top(); // 把右字符串栈顶赋值给mRts，进行下次循环处理
                    break;
                } else {
                    // 栈大小只有1的情况
                    mRts = rightStack.top(); // 把右字符串栈顶赋值给mRts，进行下次循环处理
                    payment += a; // 直接采用支付a个钱币的方案
//                    cout << "else" << endl;
                    break;
                }
            }
        }
//        cout << "payment: " << payment << endl;
    }
    cout << payment;
}
```

# 拼写检查

> 类型：字符串，模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 最小的K个数

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 绩点计算

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# xxx定律

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 数的距离差

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 亲和数

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 金币

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 小A的计算器

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 小丑排序

> 类型：排序
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 数圈

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 锤子剪刀布

> 类型：模拟
>
> 难度：2

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```

# 新型冠状病毒（COVID19）传播

> 类型：排序
>
> 难度：4

## 【问题描述】

&emsp;&emsp;

## 【输入形式】

&emsp;&emsp;

## 【输出形式】

&emsp;&emsp;

## 【样例输入】



## 【样例输出】



## 【思路】



## 【代码（C++）】
```

```