---
title: 程序设计训练2021-作业训练一
date: 2021-07-09 17:26:17
tags:  [ 'CCF', 'C++' ]
---

# 导航

###### [一、众数](#众数)
###### [二、错误的里程表](#错误的里程表)
###### [三、拳王阿里](#拳王阿里)
###### [四、欧洲冠军联赛](#欧洲冠军联赛)
###### [五、合法的括号串](#合法的括号串)
###### [六、世界杯来了](#世界杯来了)
###### [七、F1方程式冠军](#F1方程式冠军)
###### [八、买房与选房](#买房与选房)
###### [九、二叉树遍历，从前序、中序到后序](#二叉树遍历，从前序、中序到后序)
###### [十、内存管理](#内存管理)
###### [十一、平均方差](#平均方差)
###### [十二、IP地址](#IP地址)
###### [十三、开关与灯](#开关与灯)
###### [十四、可删除的点](#可删除的点)

# 众数

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;一组数据中出现最多的数，称为众数。比如

&emsp;&emsp;1 2 3 3

&emsp;&emsp;众数为3。一组数据中也可能有多个众数，以最先出现的作为众数。比如

&emsp;&emsp;2 2 3 3

&emsp;&emsp;众数为2。

&emsp;&emsp;问题是一组按升序排好的数据，指出它的众数。

## 【输入形式】

&emsp;&emsp;有多组测试数据（不超过100组测试数据）。

&emsp;&emsp;每组测试数据占两行，第一行是正整数N：表示这组测试数据中数据项数。

&emsp;&emsp;第二行是N个用空格隔开的正整数，表示这组测试数据的数据元素。每个数据元素都不大于10000。

&emsp;&emsp;N=0，表示输入结束，并且不需要处理。

&emsp;&emsp;40%的测试数据N 1 ≤N≤ 10；

&emsp;&emsp;30%的测试数据N 10 < N≤ 100；

&emsp;&emsp;20%的测试数据N 100 < N≤ 1000；

&emsp;&emsp;10%的测试数据N 1000 < N≤ 10000；

## 【输出形式】

&emsp;&emsp;对于每组测试数据，输出一行包含一个正整数：对应的众数

## 【样例输入】

    4
    1 2 3 3
    4
    2 2 3 3
    0
## 【样例输出】

    3
    2

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>

using namespace std;

int main() {
    int n;
    while (cin >> n && n != 0) {
        int before;
        int value, countBefore = 0, countNow = 0;
        for (int i = 0; i < n; i++) {
            int now;
            cin >> now;
            if (i == 0) {
                value = now;
                countNow = 1;
            } else {
                if (now == before) {
                    countNow++;
                } else {
                    countNow = 1;
                }
            }
            if (countNow > countBefore) {
                value = now;
                countBefore = countNow;
            }
            before = now;
        }
        cout << value << endl;
    }
}
```

# 错误的里程表

> 类型：数学
>
> 难度：3

## 【问题描述】

&emsp;&emsp;三月八日，小明买了台新车。但很快小明发现汽车的里程表有问题：里程表上每一位都不显示数字3和数字8，也就是说直接从数字2跳到数字4，直接从数字7跳到数字9。小明纳闷：这车到底行驶里程是多少。

&emsp;&emsp;现在，小明向你求助：根据里程表显示的数字，给出真实的行驶里程。

## 【输入形式】

&emsp;&emsp;输入有多组测试数据。

&emsp;&emsp;输入第一行正整数T，表示有多少组测试数据。

&emsp;&emsp;后面有T行，每行一个非负整数，表示里程表显示数字，里面不含有数字3和8。该数字不超过10位。

&emsp;&emsp;40%的测试数据组数T  10≤T≤ 102；

&emsp;&emsp;30%的测试数据组数T  102≤T≤ 103；

&emsp;&emsp;20%的测试数据组数T  103≤T≤ 104；

&emsp;&emsp;10%的测试数据组数T  104≤T≤ 105；

## 【输出形式】

&emsp;&emsp;对于每组测试数据，输出一个整数占一行：真实的行程里程。

## 【样例输入】

    6
    0
    1
    12
    159
    111224459
    124567976

## 【样例输出】

    0
    1
    10
    103
    19212007
    21913077

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <cmath>

using namespace std;

int main() {
    long long int n, count, result;
    cin >> n;
    for (long long int i = 0; i < n; ++i) {
        long long int m;
        cin >> m;
        result = m;
        count = 0;
        long long int length = -1;
        long long int prev = 0;
        do {
            long long int each = m % 10;
            length++;
            for (long long int j = 1; j <= each; ++j) {
                if (j == 3 || j == 8) count += pow(10, length);
                else count += prev;
            }
            prev = 8 * prev + 2 * (long long int) pow(10, length);
            m /= 10;
        } while (m != 0);
        cout << result - count << endl;
    }
}
```

# 拳王阿里

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;阿里是上个世纪美国最著名的拳击手，阿里在20年的时间里多次获得重量级拳王称号。不过不幸的是，他在之后患上了帕金森氏病。他参加了许多比赛，多到连自己都数不清了。

&emsp;&emsp;有这么一段时间，他总是参加各种不同的比赛，以至于他自己也不知道从第一场比赛开始到最后一场比赛结束到底用了多长时间。他只记得比赛的第一天是星期几（S)，最后一场比赛的最后一天是星期几(E)。他还记得比赛的总天数（包括第一和最后一天）不少于L天，也不多于R天。给定S和E，能否唯一确定参加比赛总天数(包含该段时间内比赛间的间隔天数)？

## 【输入形式】

&emsp;&emsp;输入的第一行包含一个整数T，代表测试数据的组数。接下来是 T 组数据。每组数据仅有一行，首先包含两个字符串S和E，然后包含两个整数L和R。

&emsp;&emsp;&emsp;&emsp;● 1 ≤ T ≤ 10,000        1 ≤ L ≤ R ≤ 100

&emsp;&emsp;&emsp;&emsp;● S, E ∈ {“monday”,“tuesday”,“wednesday”,“thursday”,“friday”,“saturday”, “sunday”}

## 【输出形式】

&emsp;&emsp;对于每组数据：

&emsp;&emsp;&emsp;&emsp;● 如果不存在满足条件的天数，输出一行“impossible”；

&emsp;&emsp;&emsp;&emsp;● 如果存在多个满足条件的天数，输出一行“many”；

&emsp;&emsp;&emsp;&emsp;● 否则，输出一行，包含一个整数，代表唯一满足条件的天数。

## 【样例输入】

    3
    saturday sunday 2 4 
    monday wednesday 1 20 
    saturday sunday 3 5

## 【样例输出】

    2
    many
    impossible

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>

using namespace std;

int getIndex(string &mS) {
    if (mS == "monday")
        return 0;
    else if (mS == "tuesday")
        return 1;
    else if (mS == "wednesday")
        return 2;
    else if (mS == "thursday")
        return 3;
    else if (mS == "friday")
        return 4;
    else if (mS == "saturday")
        return 5;
    else if (mS == "sunday")
        return 6;
    else
        return -1;
}

int getMin(int s, int e) {
    int minCount = 1;
    while (s != e) {
        s = (s + 1) % 7;
        minCount++;
    }
    return minCount;
}

int main() {
    int T;
    cin >> T;
    for (int i = 0; i < T; ++i) {
        string S, E;
        int s, e, l, r;
        cin >> S >> E >> l >> r;
        s = getIndex(S);
        e = getIndex(E);
//        cout << "s: " << s << endl;
//        cout << "e: " << e << endl;
        int min = getMin(s, e);
        if (min > r) cout << "impossible" << endl;
        else {
            while (min <= r) {
                if (min >= l) break;
                else min += 7;
            }
            if (min > r) cout << "impossible" << endl;
            else {
                if (min + 7 <= r)cout << "many" << endl;
                else cout << min << endl;
            }
        }
    }
}
```

# 欧洲冠军联赛

> 类型：排序
>
> 难度：3

## 【问题描述】

&emsp;&emsp;欧洲冠军联赛常被誉为全世界最具影响力的俱乐部级赛事。在比赛的小组赛阶段，欧洲的各个足球俱乐部被分为八个小组，每个小组中四支球队。每个小组中的球队按照如下规则排序：

&emsp;&emsp;&emsp;&emsp;● 球队会根据比赛结果获得积分。一场比赛的双方被称为主队和客队。如果其中一方进球数多于另一方，那么进球较多的一方获得3 分，另一方获得0 分。如果双方打成平手，则各得1分。

&emsp;&emsp;&emsp;&emsp;● 球队的净胜球数是其进球数减去失球数（不考虑该球队在比赛中作为主队还是客队）。

&emsp;&emsp;&emsp;&emsp;● 积分较高的球队排名更加靠前。

&emsp;&emsp;&emsp;&emsp;●  如果两支球队积分相同，那么净胜球数较多的球队排名靠前。

&emsp;&emsp;小组的各队伍进行循环赛，即每两支球队之间进行两场比赛，双方交替作为主队。给定一个小组内12 场比赛的结果，请求出小组的出线队伍：即排名第一和第二的两支球队。

&emsp;&emsp;保证答案唯一。

## 【输入形式】

&emsp;&emsp;输入的第一行包含一个整数T，代表测试数据的组数。接下来是 T 组数据。

&emsp;&emsp;每组数据共有12 行，每行描述一场比赛，格式为：“主队队名主队进球数vs. 客队进球数客队队名”，其中“主队队名”和“客队队名”为字符串，“主队进球数”和“客队进球数”为两球队在本场比赛中各自的进球数量。    

&emsp;&emsp;&emsp;&emsp;● 1 ≤ T ≤ 50

&emsp;&emsp;&emsp;&emsp;● 球队队名仅包含小写英文字母

&emsp;&emsp;&emsp;&emsp;● 球队队名长度不超过10 个字符

&emsp;&emsp;&emsp;&emsp;● 0 ≤ 进球数 ≤ 100

## 【输出形式】

&emsp;&emsp;对于每组数据，输出一行，包含两个字符串，代表排名第一和第二的球队的队名。

## 【样例输入】

    2
    manutd 8 vs. 2 arsenal 
    lyon 1 vs. 2 manutd 
    fcbarca 0 vs. 0 lyon 
    fcbarca 5 vs. 1 arsenal 
    manutd 3 vs. 1 fcbarca 
    arsenal 6 vs. 0 lyon 
    arsenal 0 vs. 0 manutd 
    manutd 4 vs. 2 lyon 
    arsenal 2 vs. 2 fcbarca 
    lyon 0 vs. 3 fcbarca 
    lyon 1 vs. 0 arsenal
    fcbarca 0 vs. 1 manutd
    a 3 vs. 0 b 
    a 0 vs. 0 c 
    a 0 vs. 0 d 
    b 0 vs. 0 a 
    b 4 vs. 0 c 
    b 0 vs. 0 d 
    c 0 vs. 0 a 
    c 0 vs. 0 b 
    c 1 vs. 0 d 
    d 3 vs. 0 a 
    d 0 vs. 0 b 
    d 0 vs. 0 c

## 【样例输出】

    manutd fcbarca 
    d b

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <algorithm>

using namespace std;


struct Team {
    string name = "-1";
    int scoreGet = 0;
    int scoreLose = 0;
};


void addTeam(string &s, Team *team) {
    for (int i = 0; i < 4; ++i) {
        if (s != team[i].name) {
            if (team[i].name == "-1") {
                team[i].name = s;
                break;
            }
        } else break;

    }
}


bool cmp(Team a, Team b) {
    if (a.scoreGet != b.scoreGet)
        return a.scoreGet > b.scoreGet;
    else
        return a.scoreLose > b.scoreLose;
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        string teamLeft[12], teamRight[12], shit;
        Team teamArr[4];
        int scoreLeft[12], scoreRight[12];
        for (int j = 0; j < 12; ++j) {
            cin >> teamLeft[j] >> scoreLeft[j] >> shit >> scoreRight[j] >> teamRight[j];
            addTeam(teamLeft[j], teamArr);
            addTeam(teamRight[j], teamArr);
        }
        for (int j = 0; j < 4; ++j) {
            for (int k = 0; k < 12; ++k) {
                if (teamLeft[k] == teamArr[j].name) {
                    if (scoreLeft[k] > scoreRight[k])
                        teamArr[j].scoreGet += 3;
                    else if (scoreLeft[k] == scoreRight[k])
                        teamArr[j].scoreGet += 1;
                    teamArr[j].scoreLose += scoreLeft[k] - scoreRight[k];
                }
                if (teamRight[k] == teamArr[j].name) {
                    if (scoreLeft[k] < scoreRight[k])
                        teamArr[j].scoreGet += 3;
                    else if (scoreLeft[k] == scoreRight[k])
                        teamArr[j].scoreGet += 1;
                    teamArr[j].scoreLose += scoreRight[k] - scoreLeft[k];
                }
            }
        }
        sort(teamArr, teamArr + 4, cmp);
        cout << endl;
        cout << teamArr[0].name << " " << teamArr[1].name << endl;

    }

}
```

# 合法的括号串

> 类型：线性表
>
> 难度：3

## 【问题描述】

&emsp;&emsp;一个合法的括号串，是指只包含括号的串，如果满足如下条件：

&emsp;&emsp;&emsp;&emsp;● （1）<> () [] {} 这四对括号是合法的；

&emsp;&emsp;&emsp;&emsp;● （2）如果r是合法括号串，则<r> (r) [r] {r}也是；

&emsp;&emsp;&emsp;&emsp;● （3）如果r，s是合法括号串，则rs也是；

&emsp;&emsp;所以<<>> , [<>{}(())],[({<>})]是合法的括号串，而)(,[( ])就不是。

## 【输入形式】

&emsp;&emsp;输入第一行正整数t (10 ≤ n ≤ 100)，表示有多少组测试数据。

&emsp;&emsp;后面有t行，每行一个只包含8种括号符号的括号串。

&emsp;&emsp;40%的括号串的长度L 2 ≤ L≤ 20；

&emsp;&emsp;30%的括号串的长度L 2 ≤ L≤ 200；

&emsp;&emsp;20%的括号串的长度L 2 ≤ L≤ 2000；

&emsp;&emsp;10%的括号串的长度L 2 ≤ L≤ 20000；

## 【输出形式】

&emsp;&emsp;对于每组测试数据，如果括号串是合法的，输出“Yes”（输出没有引号）占一行，否则，输出“No”（输出没有引号）占一行。

## 【样例输入】

    6
    <<>> 
    )(
    [<>{}(())]
    [({<>})]
    [(])
    <([{

## 【样例输出】

    Yes
    No
    Yes
    Yes
    No
    No

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <stack>
#include <sstream>

using namespace std;

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        string in;
        stringstream sstrem;
        char c;
        stack<char> s;
        cin >> in;
        sstrem << in;
        while (sstrem >> c) {
            if (!s.empty())
                if (s.top() == '<' && c == '>' || s.top() == '(' && c == ')' || s.top() == '[' && c == ']' ||
                    s.top() == '{' && c == '}')
                    s.pop();
                else
                    s.push(c);
            else
                s.push(c);
        }
        if (!s.empty())
            cout << "No" << endl;
        else
            cout << "Yes" << endl;
    }
}
```

# 世界杯来了

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;2018年俄罗斯世界杯结束了，法国获得冠军，全世界球迷度过了一个非常愉快的夏天。作为中国球迷，不能总是看别人踢球，这不福利来了，根据FIFA（国际足联）及全体成员协会的一致决定，2118年世界杯将在中国举办，作为东道主，中国队将无需参加预选赛而直接参加决赛阶段的比赛。

&emsp;&emsp;比赛规则如下：

&emsp;&emsp;&emsp;&emsp;● 总共n（n为偶数）个球队参加比赛

&emsp;&emsp;&emsp;&emsp;● 按照分组赛积分排名，前n/2的球队进入淘汰赛

&emsp;&emsp;&emsp;&emsp;● 积分排名的规则如下：球队获胜得3分，平局得1分，失利得0分，按照积分递减、净胜球递减以及进球数递减方式排名

&emsp;&emsp;编写一个程序，根据给出的参赛队伍名单和所有比赛的结果，找出成功进入淘汰赛阶段的球队名单。

## 【输入形式】

&emsp;&emsp;第一行输入包含唯一整数n(1<=n<=50)，参加世界杯决赛的球队数量。接下来的n行是各球队的名字，为长度不超过30个字符的英文字符。接下来的n*(n-1)/2行，每行格式name1-name2 num1:num2（0<=num1, num2<=100），表示对阵球队及比分. 

## 【输出形式】

&emsp;&emsp;输入n/2行，表示进入淘汰赛阶段的球队，按照字典序进行排列，每个球队名字占一行。

## 【样例输入】

    4
    A
    B
    C
    D
    A-B 1:1
    A-C 2:2
    A-D 1:0
    B-C 1:0
    B-D 0:3
    C-D 0:3

## 【样例输出】

    A
    D

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <algorithm>

using namespace std;

struct Team {
    string name;
    int score = 0;
    int inOut = 0;
    int in = 0;
};

bool cmp(Team a, Team b) {
    if (a.score != b.score)
        return a.score > b.score;
    else if (a.inOut != b.inOut)
        return a.inOut > b.inOut;
    else if (a.in != b.in)
        return a.in > b.in;
}

bool cmp2(Team A, Team B) {
    return A.name < B.name;
}

int main() {
    int n;
    cin >> n;
    Team team[n];
    for (int i = 0; i < n; ++i) {
        cin >> team[i].name;
    }
    for (int i = 0; i < n * (n - 1) / 2; ++i) {
        string t, s;
        cin >> t >> s;
        string teamLeft = t.substr(0, t.find('-'));
        string teamRight = t.substr(t.find('-') + 1, t.size());
        int inLeft = stoi(s.substr(0, s.find(':')));
        int inRight = stoi(s.substr(s.find(':') + 1, s.size()));
        for (int j = 0; j < n; ++j) {
            if (teamLeft == team[j].name) {
                if (inLeft > inRight)
                    team[j].score += 3;
                else if (inLeft == inRight)
                    team[j].score += 1;
                team[j].in += inLeft;
                team[j].inOut += inLeft - inRight;
            }
            if (teamRight == team[j].name) {
                if (inLeft < inRight)
                    team[j].score += 3;
                else if (inLeft == inRight)
                    team[j].score += 1;
                team[j].in += inRight;
                team[j].inOut += inRight - inLeft;
            }
        }
    }
    sort(team, team + n, cmp);
    sort(team, team + n / 2, cmp2);
//    cout << team[0].name << endl;

    for (int j = 0; j < n / 2; ++j) {
//        cout << team[j].name << " " << team[j].score << " " << team[j].inOut << " " << team[j].in << endl;
        cout << team[j].name << endl;

    }
}
```

# F1方程式冠军

> 类型：模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;一级方程式F1锦标赛由一系列称为大奖赛的分站赛组成。每一场比赛的车手都根据他们的最后位置获得积分。只有前10名车手按以下顺序获得分数：25、18、15、12、10、8、6、4、2、1。在锦标赛结束时，得分最多的车手是冠军。如果有平分，则冠军是赢的最多的人（即排位第一）。如果还是平分，则选择得到排位第二最多的人，依此类推，直到没有更多的排位进行比较。

&emsp;&emsp;后来又提出了另一个得分制度，其中冠军是赢的最多的。如果有平手，冠军是得分最多的。如果仍然存在平手，则按原来的得分制度进行，即比较第二、第三、第四、...排位的次数。

&emsp;&emsp;在本赛季，你会得到所有比赛的结果，你将根据两个得分系统来分别确定冠军。数据保证两套系统都能得到唯一的冠军。

## 【输入形式】

&emsp;&emsp;第一行一个整数t（1<=t<=20），t是分站赛的场次数。之后是每个分站赛的最终排位情况，每个的第一行一个整数n(1<=n<=100)表示排位车手人数，之后n行按排位列出车手的名字，排位从第一到最后，车手的名字为长度不超过50的英文字符，大小写区分。

## 【输出形式】

&emsp;&emsp;输出为两行，第一行为按照原始规则确定的冠军，第二行是按照可选规则确定的冠军。

## 【样例输入】

    3
    3
    apple
    banana
    pear
    2
    pear
    banana
    2
    apple
    banana

## 【样例输出】

    banana
    apple

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <algorithm>

using namespace std;

struct Player {
    string name = "-1";
    int score = 0;
    int rank[100] = {0};
};

int countScore(int mRank) {
    if (mRank > 10)
        return 0;
    else if (mRank == 1)
        return 25;
    else if (mRank == 2)
        return 18;
    else if (mRank == 3)
        return 15;
    else if (mRank == 4)
        return 12;
    else if (mRank == 5)
        return 10;
    else if (mRank == 6)
        return 8;
    else if (mRank == 7)
        return 6;
    else if (mRank == 8)
        return 4;
    else if (mRank == 9)
        return 2;
    else if (mRank == 10)
        return 1;
    return 0;
}

void countPlayer(string &name, int rank, Player *player) {
    for (int i = 0; i < 100; ++i) {
        if (name != player[i].name) {
            if (player[i].name == "-1") {
                player[i].name = name;
                player[i].score += countScore(rank);
                player[i].rank[rank - 1] += 1;
                break;
            }
        } else {
            player[i].score += countScore(rank);
            player[i].rank[rank - 1] += 1;
            break;
        }
    }
}

bool cmp(Player a, Player b) {
    if (a.score != b.score)
        return a.score > b.score;
    else
        for (int i = 0; i < 100; ++i) {
            if (a.rank[i] != b.rank[i])
                return a.rank[i] > b.rank[i];
        }
    return false;
}

bool cmp2(Player a, Player b) {
    if (a.rank[0] != b.rank[0])
        return a.rank[0] > b.rank[0];
    else if (a.score != b.score)
        return a.score > b.score;
    else
        for (int i = 1; i < 100; ++i) {
            if (a.rank[i] != b.rank[i])
                return a.rank[i] > b.rank[i];
        }
    return false;
}

int main() {
    int t;
    cin >> t;
    Player player[100];
    for (int i = 0; i < t; ++i) {
        int n;
        cin >> n;
        for (int j = 0; j < n; ++j) {
            string s;
            cin >> s;
            countPlayer(s, j + 1, player);
        }
    }
    sort(player, player + 100, cmp);
    cout << player[0].name << endl;
    sort(player, player + 100, cmp2);
    cout << player[0].name << endl;
}
```

# 买房与选房

> 类型：排序
>
> 难度：4

## 【问题描述】

&emsp;&emsp;在 X 国许多一线城市住房非常紧张，政府部门制定了相关的政策，重点满足住房刚性需求（住房面积为0，社保缴纳必须超过2年），然后才能照顾改善性需求（住房面积大于0）。

&emsp;&emsp;具体的原则为：

&emsp;&emsp;&emsp;&emsp;● 对于刚性需求，缴纳社保月数多者优先

&emsp;&emsp;&emsp;&emsp;● 对于改善性需求，现有自有住房面积小者优先

&emsp;&emsp;由于房源有限，为公平起见，开发商在不违背上述原则下特意指定同等条件下申报时间同时作为排队的条件，时间越早优先级越高。

&emsp;&emsp;最近有一批新楼盘准备开盘，总共有 m （≤1000）套房，所有的网上申报工作都已经完成并保存到二进制文件house.bin中，申请者提交了自己的基本材料，格式为：身份证号（18位，加1位空字符'\0'，共19位）、社保缴纳月数、自有住房面积、申报时间(格式为：MM-DD-YYYY，10位字符串，加1位空字符'\0'，共11位)，社保缴纳月数、自有住房面积均为整数，文件最后为总报名人数 n（≤105）。



&emsp;&emsp;申请者可以通过身份证号查询最终的结果。

## 【输入形式】

&emsp;&emsp;输入的第一行为两个正整数 m（≤1000）和 T （ T ≤ n ），分别表示本次开盘的楼盘可供申请的套数以及查询的组数

&emsp;&emsp;接下来的 T 行，每行为一个18位的字符串，表示需要查询的身份证号

## 【输出形式】

&emsp;&emsp;输出为 T 行，对应每个查询的输出结果：

&emsp;&emsp;&emsp;&emsp;● 1. 申请者不符合购房条件或排位超出了所推出的房源数量不能中签，则输出"Sorry";

&emsp;&emsp;&emsp;&emsp;● 2. 申请者符合购房条件，且该名次人数为1人，则直接输出一个整数，表示选房顺序号;

&emsp;&emsp;&emsp;&emsp;● 3. 申请者符合购房条件，且该名次人数有多人，同时人数不大于所剩房源数量，则直接输出用空格分隔的两个整数，表示选房顺序号区间;

&emsp;&emsp;&emsp;&emsp;● 4. 申请者符合购房条件，且该名次人数有多人，同时人数大于所剩房源数量，则输出用/分隔两个整数，如 A/B，表示 B 人中选 A 人，选房顺序为排名倒数 A 名范围。

## 【样例输入】

    9 6
    350102200609166049
    350102200609163286
    250342323545313434
    130502201805070787
    110101196003074525
    430102201102181455

## 【样例输出】

    2
    3 4
    Sorry
    6
    2/3
    Sorry

## 【代码框架】

**建议复制以下代码框架， 在此基础上完成本题需求。此建议不是必须，你可以忽略。**

```
#include <iostream>

using namespace std;

struct people {
    char id[19];                  /* 身份证号码 */
    int social;                     /* 社保缴纳月数 */
    int area;                       /* 现有住房面积 */
    char date[11];              /* 申报日期 */
};

people *getMess(int &n);

int main() {
    people *person;          /* 指向所有报名人的基本资料首地址，通过调用函数getMess获取 */
    int n;                            /* n为报名人数，通过调用函数getMess获取 */
    person = getMess(n);

    // ...

    return 0;
}

people *getMess(int &n) {            /* 将文件数据读入内存 */
    FILE *fp;
    fp = fopen("house.bin", "rb");
    fseek(fp, -1 * (long) sizeof(int), 2);
    fread(&n, sizeof(int), 1, fp);
    rewind(fp);
    people *tmp = new people[n];
    fread(tmp, sizeof(people), n, fp);
    fclose(fp);
    return tmp;
}
```

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <sstream>
#include <fstream>
#include <algorithm>

using namespace std;

struct people {
    char id[19];                  /* 身份证号码 */
    int social;                     /* 社保缴纳月数 */
    int area;                       /* 现有住房面积 */
    char date[11];              /* 申报日期 */
};

struct People {
    people p;
    int rankAcutally = 0; // 实际排行
    int rank = 0; // 带重排名
    long long int time = 0; // 日期
    int count = 1; // 同排名人数
    int index = 1; // 同排名索引
};

people *getMess(int &n) {            /* 将文件数据读入内存 */
    FILE *fp;
    fp = fopen("house.bin", "rb");
    fseek(fp, -1 * (long) sizeof(int), 2);
    fread(&n, sizeof(int), 1, fp);
    rewind(fp);
    auto *tmp = new people[n];
    fread(tmp, sizeof(people), n, fp);
    fclose(fp);
    return tmp;
}

bool cmp(People a, People b) {
    if (a.p.area == 0 && a.p.social > 24 && b.p.area != 0)
        return true;
    else if (a.p.area != 0 && (b.p.area == 0 && b.p.social <= 24))
        return true;
    else if (a.p.area == 0 && a.p.social > 24 && b.p.area == 0 && b.p.social <= 24)
        return true;
    else if (a.p.area == 0 && b.p.area == 0) {
        if (a.p.social != b.p.social)
            return a.p.social > b.p.social;
        else if (a.time != b.time)
            return a.time < b.time;
    } else if (a.p.area != 0 && b.p.area != 0) {
        if (a.p.area != b.p.area)
            return a.p.area < b.p.area;
        else if (a.time != b.time)
            return a.time < b.time;
    }
    return false;
}

People findById(string &id, People *p, int n) {
    for (int i = 0; i < n; ++i) {
        if (id == p[i].p.id)
            return p[i];
    }
    return p[0];
}

int main() {
    people *persons;          /* 指向所有报名人的基本资料首地址，通过调用函数getMess获取 */
    int n;                            /* n为报名人数，通过调用函数getMess获取 */
    persons = getMess(n);
//    int n = 14;
//    ifstream in("test.txt");
//    people persons[n];
//    for (int i = 0; i < n; ++i) {
//        in >> persons[i].id >> persons[i].social >> persons[i].area >> persons[i].date;
//    }
    People person[n];
    for (int i = 0; i < n; ++i) {
        person[i].p = persons[i];
    }
    for (int i = 0; i < n; ++i) {
        string s = person[i].p.date;
        string m = s.substr(0, s.find('-'));
        string d = s.substr(s.find('-') + 1, s.find('-', s.find('-') + 1) - s.find('-') - 1);
        string y = s.substr(s.find('-', s.find('-') + 1) + 1, s.length() - (s.find('-') + 1 + 1));
        stringstream sstrem;
        sstrem << y << m << d;
        sstrem >> person[i].time;
    }
    sort(person, person + n, cmp);
    for (int i = 0; i < n; ++i) {
        person[i].rankAcutally = i + 1;
        if (i == 0)
            person[i].rank = i + 1;
        else {
            if ((person[i].p.social == person[i - 1].p.social && person[i].p.area == person[i - 1].p.area &&
                 person[i].time == person[i - 1].time) ||
                (person[i].p.area != 0 && person[i - 1].p.area != 0 &&
                 person[i].time == person[i - 1].time)) {
                person[i].rank = person[i - 1].rank;
                person[i].count = person[i - 1].count + 1;
                for (int j = 0; j < person[i].count; ++j) {
                    person[i - j].index = person[i].count - j;
                    person[i - j].count = person[i].count;
                }
            } else person[i].rank = person[i - 1].rank + 1;
        }
    }
//    for (int i = 0; i < n; ++i) {
//        cout << person[i].p.id << " " << person[i].p.social << " " << person[i].p.area << " " << person[i].p.date << " "
//             << person[i].rankAcutally << " " << person[i].rank << " " << person[i].count << " " << person[i].index
//             << endl;
//    }
    int m, T;
    cin >> m >> T;
    for (int i = 0; i < T; ++i) {
        string id;
        cin >> id;
        People p = findById(id, person, n);
        int tail = p.rankAcutally - p.index + p.count; // 当前rank里最后一个人的实际排名
        int head = p.rankAcutally - p.index + 1; // 当前rank里第一个人的实际排名
        if (p.p.area == 0 && p.p.social <= 24) {
            cout << "Sorry" << endl;
        } else {
            if (tail <= m) {
                if (p.count == 1) {
                    cout << p.rankAcutally << endl;
                } else cout << p.rankAcutally - p.index + 1 << " " << head + p.count - 1 << endl;
            } else {
                if (head <= m) {
                    cout << m - head + 1 << "/" << p.count << endl;
                } else {
                    cout << "Sorry" << endl;
                }
            }
        }
    }
}
```

# 二叉树遍历，从前序、中序到后序

> 类型：树
>
> 难度：4

## 【问题描述】

&emsp;&emsp;二叉树是一种非常重要的数据结构，非常多其他数据结构都是基于二叉树的基础演变而来的。对于二叉树，深度遍历有前序、中序以及后序三种遍历方法。

&emsp;&emsp;三种基本的遍历思想为：

&emsp;&emsp;前序遍历：根结点 ---> 左子树 ---> 右子树

&emsp;&emsp;中序遍历：左子树---> 根结点 ---> 右子树

&emsp;&emsp;后序遍历：左子树 ---> 右子树 ---> 根结点

&emsp;&emsp;比如，求以下二叉树的各种遍历

{% asset_img tree.png Android11+的特殊权限变化 %}

&emsp;&emsp;前序遍历：1  2  4  5  7  8  3  6 

&emsp;&emsp;中序遍历：4  2  7  5  8  1  3  6

&emsp;&emsp;后序遍历：4  7  8  5  2  6  3  1

&emsp;&emsp;需要你编写程序解决的问题是：已知一个二叉树的前序遍历和中序遍历的结果，给出该二叉树的后序遍历的结果。

## 【输入形式】

&emsp;&emsp;有多组测试数据，每组测试数据三行，每组测试数据第一行只有一个正整数n，表示二叉树节点的数目，n=0意味着输入结束并且不需要处理。

&emsp;&emsp;每组测试数据第二行是二叉树的前序遍历的结果，是一个长度为n的字符串，每个节点由一个字符表示，字符是大小写英文字母及10个数字,不同的节点用不同的字符表示，也即无论前序遍历和中序遍历的字符串中没有重复的字符。

&emsp;&emsp;每组测试数据第二行是二叉树的中序遍历的结果，也是一个长度为n的字符串。

&emsp;&emsp;40%的测试数据1 ≤ n≤ 10；

&emsp;&emsp;30%的测试数据1 ≤ n≤ 20；

&emsp;&emsp;20%的测试数据1 ≤ n≤ 40；

&emsp;&emsp;10%的测试数据1 ≤ n≤ 62；

## 【输出形式】

&emsp;&emsp;对于每组测试数据，输出一行，是一个长度为n的字符串，表示二叉树后序遍历的结果。

## 【样例输入】

    8
    12457836
    42758136
    4
    abcd
    abcd
    4
    abcd
    dcba
    0

## 【样例输出】

    47852631
    dcba
    dcba

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>

using namespace std;

int getIndex(char c, const char *ca, int n) {
    for (int i = 0; i < n; ++i) {
        if (c == ca[i])
            return i;
    }
    return -1;
}

int getLeftSurplus(char c, const char *ca, int limitLeftIndex, int limitRightIndex) {
    int count = 0;
    for (int i = limitLeftIndex; i < limitRightIndex; ++i) {
        if (c == ca[i])
            return count;
        else if (ca[i] != '*')
            count++;
    }
    return 0;
}

int getRightSurplus(char c, const char *ca, int limitLeftIndex, int limitRightIndex) {
    int count = 0;
    for (int i = limitRightIndex - 1; i >= limitLeftIndex; --i) {
        if (c == ca[i])
            return count;
        else if (ca[i] != '*')
            count++;
    }
    return 0;
}

int count = 0;

char getNextChar(char c, char *ca, int n) {
    count++;
    return ca[count];
}

void getBack(char c, char *mid, char *fore, int limitLeftIndex, int limitRightIndex, int n) {
    int left = getLeftSurplus(c, mid, limitLeftIndex, limitRightIndex);
    int right = getRightSurplus(c, mid, limitLeftIndex, limitRightIndex);
    int mIndex;
    char mNextChar;
    if (left > 0) {
        mIndex = getIndex(c, mid, n);
        mNextChar = getNextChar(c, fore, n);
        getBack(mNextChar, mid, fore, limitLeftIndex, mIndex, n);
    }

    if (right > 0) {
        mIndex = getIndex(c, mid, n);
        mNextChar = getNextChar(c, fore, n);
        getBack(mNextChar, mid, fore, mIndex + 1, limitRightIndex, n);
    }
    left = getLeftSurplus(c, mid, limitLeftIndex, limitRightIndex);
    right = getRightSurplus(c, mid, limitLeftIndex, limitRightIndex);
    if (left == 0 &&
        right == 0) {
        cout << c;
        mid[getIndex(c, mid, n)] = '*';
    }
}


int main() {
    int n;
    while (cin >> n && n != 0) {
        char fore[n], mid[n];
        cin.sync();
        for (int i = 0; i < n; ++i) {
            cin >> fore[i];
        }
        for (int i = 0; i < n; ++i) {
            cin >> mid[i];
        }
        count = 0;
        getBack(fore[0], mid, fore, 0, n, n);
        cout << endl;
    }
}
```

# 内存管理

> 类型：字符串，模拟
>
> 难度：3

## 【问题描述】

&emsp;&emsp;离第一个操作系统HNU-OS发布已经没有多少时间了，但它的一些组件还没有完成，内存管理器就是其中之一。根据开发人员的计划，在第一个版本中，内存管理器将非常简单和直观。它将支持三个操作： 

&emsp;&emsp;&emsp;&emsp;● alloc n —— 分配n个字节内存，返回已分配块的正整数标识符x(x初始值为0，每次分配增长1)

&emsp;&emsp;&emsp;&emsp;● erase x —— 删除标识符x所在的块

&emsp;&emsp;&emsp;&emsp;● defragment —— 整理空余内存碎片，将所有块尽量靠近内存的开始位置，并保持各自的顺序

&emsp;&emsp;在此情况下，内存模型非常简单，它是一个m字节的序列，为了方便起见，从第一个字节到第m字节进行编号。

&emsp;&emsp;第一个操作alloc n有一个参数n，表示被分配的内存块大小。在处理此操作时，内存中将分配n个连续字节的空闲块。 如果这些块的数量超过一个，则优先选择最接近内存开始(即第一个字节)的块。 所有这些字节都被标记为非空闲，内存管理器返回一个32位整数数字令牌，代表该块的标识符。 如果不可能分配这样大小的空闲块，则返回NULL。

&emsp;&emsp;第二个操作erase x以x为参数，表示某个块的标识符。此操作释放系统内存，将此块的字节标记为空闲以供进一步使用。 如果此标识符没有指向先前分配的块(该块尚未被释放)，则返回ILLEGAL_ERASE_ARGUMENT。

&emsp;&emsp;最后一个操作defragment没有任何参数，只会使占用的内存部分更接近内存的开始，而不会更改它们各自的顺序。 

&emsp;&emsp;在当前的实现中，将使用从1开始的连续整数作为标识符。每个成功的alloc操作过程都应该返回接下来的编号。不成功的alloc操作不影响计数。 

&emsp;&emsp;编写内存管理器的实现，为每个alloc命令输出返回的值，为所有失败的erase命令输出ILLEGAL_ERASE_ARGUMENT。 

## 【输入形式】

&emsp;&emsp;输入数据的第一行包含两个正整数t和m（1<=t<=500, 1<=m<=105)，其中t表示需要内存管理器来处理的操作个数，m表示有效的内存字节大小。接下来的t行每一行代表一个操作。

## 【输出形式】

&emsp;&emsp;输出有多行，每行或者是alloc操作的结果，或者是失败的erase操作的结果ILLEGAL_ERASE_ARGUMENT。其顺序与输入的操作次序一致。

## 【样例输入】

    6 10
    alloc 5
    alloc 3
    erase 1
    alloc 6
    defragment
    alloc 6

## 【样例输出】

    1
    2
    NULL
    3

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>

using namespace std;

int count = 1;

void doAction(const string &a, int f, int moy[][2], int m, int &cPtr) {
    if (a == "alloc") {
        int tmpCount = 0;
        for (int i = 0; i < m; ++i) {
            cPtr = i;
            if (moy[i][0] == 0) {
                tmpCount++;
            } else if (moy[i][0] != 0) {
                if (tmpCount >= f) {
                    cPtr = cPtr - tmpCount + 1;
                    break;
                }
                tmpCount = 0;
            }
            if (tmpCount >= f) {
                cPtr = cPtr - tmpCount + 1;
                break;
            }
            cPtr = -1;
        }
        if (cPtr == -1) {
            cout << "NULL" << endl;
            return;
        } else {
            int endPos = cPtr + f;
            for (int i = cPtr; i < endPos; ++i) {
                moy[i][0] = 1;
                moy[i][1] = count;
                cPtr = i;
            }
            cPtr += 1;
            cout << count++ << endl;
            return;
        }
    } else if (a == "erase") {
        bool isFound = false;
        for (int i = 0; i < m; ++i) {
            if (moy[i][1] == f) {
                moy[i][0] = 0;
                moy[i][1] = 0;
                isFound = true;
            }
        }
        if (!isFound) {
            cout << "ILLEGAL_ERASE_ARGUMENT" << endl;
            return;
        }
    } else {
        for (int i = 0; i < m - 1; ++i) {
            for (int j = 0; j < m - i - 1; ++j) {
                if (moy[j][0] < moy[j + 1][0]) {
                    int tmp1 = moy[j + 1][0];
                    int tmp2 = moy[j + 1][1];
                    moy[j + 1][0] = moy[j][0];
                    moy[j + 1][1] = moy[j][1];
                    moy[j][0] = tmp1;
                    moy[j][1] = tmp2;
                }
            }
        }
        for (int i = 0; i < m; ++i) {
            if (moy[i][0] != 0)
                cPtr = i;
        }
        cPtr += 1;
    }
}

int main() {
    int t, m;
    cin >> t >> m;
    int memory[m][2];
    for (int i = 0; i < m; ++i) {
        memory[i][0] = 0;
        memory[i][1] = 0;
    }
    int currPtr = 0;
    for (int i = 0; i < t; ++i) {
        string action;
        int flag = -1;
        cin >> action;
        if (action == "alloc" || action == "erase")
            cin >> flag;
//        for (int j = 0; j < m; ++j) {
//            cout << memory[j][0] << " ";
//        }
//        cout << endl;
//        for (int j = 0; j < m; ++j) {
//            cout << memory[j][1] << " ";
//        }
//        cout << endl;
        doAction(action, flag, memory, m, currPtr);
//        for (int j = 0; j < m; ++j) {
//            cout << memory[j][0] << " ";
//        }
//        cout << endl;
//        for (int j = 0; j < m; ++j) {
//            cout << memory[j][1] << " ";
//        }
    }
}
```

# 平均方差

> 类型：数学
>
> 难度：2

## 【问题描述】

&emsp;&emsp;一个数列的平均方差是指数列中的每个元素与数列的平均值的差的平方和的平均值，比如下面数列：

&emsp;&emsp;&emsp;&emsp;1 2 3 4 5 6 7

&emsp;&emsp;其平均值为4，每个元素与平均值的差的平方为

&emsp;&emsp;&emsp;&emsp;9 4 1 0 1 4 9

&emsp;&emsp;其平方和为28，所以该数列的平均方差为4。

&emsp;&emsp;对给定的数列，求出其平均方差。

## 【输入形式】

&emsp;&emsp;有多组测试数据。

&emsp;&emsp;每组测试数据第一行是一个正整数N，表示数列中元素个数，接下来一行N个用空格分隔开的正整数，表示数列的N个元素，每个元素的值都是不大于500的正整数。

&emsp;&emsp;N=0表示输入结束，并且不需要处理。

&emsp;&emsp;40%的数列元素个数N 1 ≤ N≤ 10；

&emsp;&emsp;30%的数列元素个数N 1 ≤ N≤ 100；

&emsp;&emsp;20%的数列元素个数N 1 ≤ N≤ 1000；

&emsp;&emsp;10%的数列元素个数N 1 ≤ N≤ 10000；

## 【输出形式】

&emsp;&emsp;对于每组测试数据，输出一个整数：平均方差。平均方差不是整数的，输出其向下取整的整数。比如平均方差是4.5，输出4。

## 【样例输入】

    7
    1 2 3 4 5 6 7
    4
    1 2 3 4
    0

## 【样例输出】

    4
    1

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <cmath>

using namespace std;

int main() {
    int N;
    while (cin >> N && N != 0) {
        double num[N];
        double sum = 0;
        for (int i = 0; i < N; ++i) {
            cin >> num[i];
            sum += num[i];
        }
        double average = sum / N;
        double variance[N];
        double sumVariance = 0;
        for (int i = 0; i < N; ++i) {
            variance[i] = pow(abs(num[i] - average), 2);
            sumVariance += variance[i];
        }
        cout << (int) sumVariance / N << endl;
    }
}
```

# IP地址

> 类型：字符串
>
> 难度：2

## 【问题描述】

&emsp;&emsp;一个IP地址由32位二进制的数组成，比如：

&emsp;&emsp;11111111111111111111111100000000

&emsp;&emsp;为了便于记忆，我们将8个二进制位用一个十进制数表示，一个IP地址由四个十进制数表示，上述的IP地址表示为：

&emsp;&emsp;255.255.255.0

&emsp;&emsp;现在给你一个上述形式的IP地址，请回答IP地址的32个二进制位中，有多少位是1。

&emsp;&emsp;如IP地址为255.255.255.0，其中24位是1。

## 【输入形式】

&emsp;&emsp;有多组测试数据。

&emsp;&emsp;测试数据第一行是一个正整数T，表示测试数据组数。

&emsp;&emsp;每组测试数据是一个IP地址，形式为：

&emsp;&emsp;IP1.IP2.IP3.IP4

&emsp;&emsp;其中0 ≤IP1,IP2,IP3,IP4≤ 255,用十进制表示。每个IP地址不保证是实用IP地址。

&emsp;&emsp;40%的测试数据组数T  10≤T≤ 102；

&emsp;&emsp;30%的测试数据组数T  102≤T≤ 103；

&emsp;&emsp;20%的测试数据组数T  103≤T≤ 104；

&emsp;&emsp;10%的测试数据组数T  104≤T≤ 105；

## 【输出形式】

&emsp;&emsp;对于每个IP地址，输出一行包含一个非负整数：该IP地址的32个二进制位中，1的位数。

## 【样例输入】

    5
    255.255.255.0
    127.0.0.1
    0.0.0.1
    1.2.3.4
    0.0.0.0

## 【样例输出】

    24
    8
    1
    5
    0

提示：样例中32位的IP地址为：

&emsp;&emsp;11111111111111111111111100000000

&emsp;&emsp;01111111000000000000000000000001

&emsp;&emsp;00000000000000000000000000000001

&emsp;&emsp;00000001000000100000001100000100

&emsp;&emsp;00000000000000000000000000000000

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    int T;
    cin >> T;
    string IP;
    for (int i = 0; i < T; ++i) {
        cin >> IP;
        stringstream sstream;
        stringstream eachIP;
        stringstream binary;
        stringstream endBinary;
        sstream << IP;
        sstream << '.';
        char a;
        int count = 0;
        while (sstream >> a) {
            if (a != '.') {
                eachIP << a;
            } else {
                int intIP;
                eachIP >> intIP;
                eachIP.clear();
                while (intIP != 0) {
                    binary << intIP % 2;
                    intIP /= 2;
                }
                string tmp;
                binary >> tmp;
                endBinary << tmp;
                binary.clear();
            }
        }
        string end;
        endBinary >> end;
        for (int j = 0; j < end.size(); ++j) {
            if (end[j] == '1')
                count++;
        }
        cout << count << endl;
    }
}
```

# 开关与灯

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;给定n个开关和m个灯，第i个开关只能打开部分灯。矩阵a包含n行m列，当aij=1时表示开关i可以打开灯j，否则aij=0。

&emsp;&emsp;开始时所有的m个灯都是关着的。

&emsp;&emsp;开关只能从状态"关"到"开"。这意味着，对于每个可以打开某个灯的开关，无论你按多少次，这个灯都是开的。

&emsp;&emsp;确保当你按下所有开关时，所有的灯都能打开，考虑是否可以忽略其中某个开关也能打开所有的灯。

&emsp;&emsp;你的任务是确定是否存在这样的开关可以忽略，而使用其余的n-1个开关来打开所有m个灯。

## 【输入形式】

&emsp;&emsp;输入第1行包含两个整数n和m(1<=n, m<=2000)，表示开关的数量和灯的数量。

&emsp;&emsp;接下来的n行，每行包含m个字符，字符aij=1时表示开关i可以打开灯j，否则aij=0。

## 【输出形式】

&emsp;&emsp;如果存在这样的可以忽略的开关，而使用其他n-1个开关打开所有的m个灯，输出"YES"，否则输出"NO"。

## 【样例输入】

    4 5
    10101
    01000
    00111
    10000

## 【样例输出】

    YES

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>

using namespace std;

int main() {
    int m, n;
    cin >> n >> m;
    int button[n][m];
    for (int i = 0; i < n; ++i) {
        string tmp;
        cin >> tmp;
        for (int j = 0; j < tmp.size(); ++j) {
            button[i][j] = tmp[j] - 48;
        }
    }
//    for (int i = 0; i < n; ++i) {
//        for (int j = 0; j < m; ++j) {
//            cout << button[i][j] << " ";
//        }
//        cout << endl;
//    }
    int flag = 0;
    int end[m];
    for (int i = 0; i < n; ++i) {
        flag = 0;
        for (int j = 0; j < m; ++j) {
            end[j] = 0;
        }
        for (int j = 0; j < n; ++j) {
            if (j != i) {
                for (int k = 0; k < m; ++k) {
                    if (button[j][k] == 1)
                        end[k] = 1;
                }
            }
        }
        for (int l = 0; l < m; ++l) {
            if (end[l] == 1)
                flag++;
        }
        if (flag == m)
            break;
    }
    if (flag == m) {
        cout << "YES";
    } else {
        cout << "NO";
    }

}
```

# 可删除的点

> 类型：模拟
>
> 难度：1

## 【问题描述】

&emsp;&emsp;平面上有n个不同的点，没有在Y轴的点，检查是否存在这样一个点，将其删除后其余所有的点均位于Y轴的同一边。

## 【输入形式】

&emsp;&emsp;输入第一行包含一个正整数n(2<=n<=105)。

&emsp;&emsp;接下来的n行，包含所有点的坐标，第i行包含两个整数xi和yi(|xi|、|yi|<=109，xi<>0)。

## 【输出形式】

&emsp;&emsp;如果存在这样的点，则输入"Yes"，否则输出"No"。

## 【样例输入】

    3
    1 1
    -1 -1
    2 -1

## 【样例输出】

    Yes

## 【思路】

施工中...

## 【代码（C++）】
```
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    long long int n;
    cin >> n;
    long long int coordinate[n][2];
    for (long long int i = 0; i < n; ++i) {
        cin >> coordinate[i][0] >> coordinate[i][1];
    }
    long long int z = 0, f = 0;
    for (long long int i = 0; i < n; ++i) {
        if (coordinate[i][0] > 0)
            z++;
        else
            f++;
    }
    if (z == 1 || f == 1 || z == 0 || f == 0)
        cout << "Yes";
    else
        cout << "No";
}
```