<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Xayah">
    
    <title>
        
            BlogOS：ARM v8之旅 |
        
        AcmeZone
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/font/css/regular.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/font/css/solid.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/font/css/brands.min.css">
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"acmezone.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"AcmeZone","author":"Xayah","avatar":"/images/Xayah.jpg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","tags":"/tags","links":"/links","unlock-music":"/unlock-music","boot-repacker":"/boot-repacker"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"这世界上有多少人，就有多少道。莫问前程，各行各道。同道为亲，道不同不相为谋。||生如长河，渡船千艘，唯自渡方是真渡。","hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/XayahSuSuSu?tab=repositories","weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null,"telegram":"https://t.me/XayahSuSuSu"}},"scroll":{"progress_bar":true,"percent":true,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2020,"word_count":true,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":true,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","feed":{"type":"atom","path":"atom.xml","limit":20},"mathjax":{"tags":"none","single_dollars":true,"cjk_width":0.9,"normal_width":0.6,"append_css":true,"every_page":false},"source_data":{"links":[{"name":"B1ue1nWh1te","link":"https://www.seaeye.cn/","description":"深海的个人主页","avatar":"https://img.seaeye.cn/img/seaeye/portrait.jpg"},{"name":"贰猹的小窝","link":"https://noionion.top/","description":"用这生命中的每一秒，给自己一个不后悔的未来","avatar":"https://pub-noionion.oss-cn-hangzhou.aliyuncs.com/head.jpg"},{"name":"御网尚书的小宇宙","link":"https://www.siteweb.cn/","description":"愿以赤子之心，共建网络空间安全","avatar":"https://www.hack-gov.com.cn/img/friend_404.gif"}]},"version":"4.1.0"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
    <!-- require APlayer -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
    <!-- require MetingJS -->
    <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="song"
        id="1811118551"
        fixed="true"
        autoplay="false">
    </meting-js>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               AcmeZone
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                
                                标签
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                
                                友链
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/unlock-music"
                            >
                                
                                音乐解锁
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/boot-repacker"
                            >
                                
                                BOOT编辑
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links"
                    >友链</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/unlock-music"
                    >音乐解锁</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/boot-repacker"
                    >BOOT编辑</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        BlogOS：ARM v8之旅
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/Xayah.jpg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Xayah</span>
                                
                                    <span class="author-badge">Lv3</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2022-02-26 15:02:36</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Sat Mar 23 2024 23:29:59 GMT+0800">2024-03-23 23:29:59</span>
            </span>
        

        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/BlogOS/">BlogOS</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E7%A7%BB%E6%A4%8D/">移植</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>16.6k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>78 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>BlogOS</strong>是<strong>Philipp Oppermann</strong>用<strong>Rust语言</strong>编写的<strong>面向x86架构</strong>的<strong>简单操作系统</strong>。</p>
<p><strong>《ARM v8之旅》</strong>将作为 <strong><a class="link"   target="_blank" rel="noopener" href="https://os2022exps-doc.readthedocs.io/zh_CN/latest/index.html" >湖南大学2022年操作系统课程实验<i class="fas fa-external-link-alt"></i></a></strong> 个人参考<strong>笔记</strong>。<br>更<strong>详细的解析</strong>请参考 <strong><a class="link"   target="_blank" rel="noopener" href="https://noionion.top/16433.html" >rust写个操作系统：课程实验blogos移至armV8深度解析<i class="fas fa-external-link-alt"></i></a></strong> 。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/64491112/libncursesw-so-5-is-installed-but-a-program-that-needs-it-says-no-such-file-or" >libncursesw.so.5 is installed but a program that needs it says “No such file or directory”<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20842732/libpython2-7-so-1-0-cannot-open-shared-object-file-no-such-file-or-directory" >libpython2.7.so.1.0: cannot open shared object file: No such file or directory<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceOne.tar.gz" title="下载">下载</a></p>
</blockquote>
<p>本文以<strong>Windows Subsystem for Linux 2</strong>为环境，可参考 <strong><a href="https://acmezone.top/2022/02/12/Windows-Subsystem-for-Linux-2-%E7%9A%84%E8%89%BA%E6%9C%AF/">Windows Subsystem for Linux 2 的艺术</a></strong> 搭建。</p>
<h2 id="1-安装Rust"><a href="#1-安装Rust" class="headerlink" title="1. 安装Rust"></a>1. 安装<a class="link"   target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN" >Rust<i class="fas fa-external-link-alt"></i></a></h2><p>输入以下<strong>命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>
<p>若网络<strong>正常</strong>，则会出现以下<strong>输出</strong>，键入<code>1</code>，执行<strong>默认安装</strong>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%AE%89%E8%A3%85RUST.png"
                        class="" title="安装RUST"
                 >
<p><strong>安装完成</strong>后，<strong>激活Rust环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source $HOME/.cargo/env</span><br></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc -V</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC.png"
                        class="" title="查看版本"
                 >
<p>根据<strong>文档</strong>，实验需要用到<strong>Nightly版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC2.png"
                        class="" title="查看版本2"
                 >
<p>安装<strong>GCC</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>

<p>安装<strong>相关工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-binutils rustfilt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若安装GCC后仍无法正常<code>cargo install cargo-binutils rustfilt</code>，请尝试将<strong>软件源</strong>更换为<strong>阿里源</strong>（参见 <strong><a href="https://acmezone.top/2022/02/12/Windows-Subsystem-for-Linux-2-%E7%9A%84%E8%89%BA%E6%9C%AF/">Windows Subsystem for Linux 2 的艺术</a></strong> ），再重新安装一次<strong>GCC</strong>。</p>
</blockquote>
<h2 id="2-添加ARM-v8支持"><a href="#2-添加ARM-v8支持" class="headerlink" title="2. 添加ARM v8支持"></a>2. 添加ARM v8支持</h2><p>键入以下<strong>命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup target add aarch64-unknown-none-softfloat</span><br></pre></td></tr></table></figure>

<h2 id="3-安装QEMU模拟器"><a href="#3-安装QEMU模拟器" class="headerlink" title="3. 安装QEMU模拟器"></a>3. 安装QEMU模拟器</h2><p>键入以下<strong>命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu qemu-system-arm</span><br></pre></td></tr></table></figure>

<h2 id="4-下载交叉编译工具链-AArch64"><a href="#4-下载交叉编译工具链-AArch64" class="headerlink" title="4. 下载交叉编译工具链 (AArch64)"></a>4. 下载<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads" >交叉编译工具链 (AArch64)<i class="fas fa-external-link-alt"></i></a></h2><p>安装<strong>必要环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncursesw5 libpython2.7 axel</span><br></pre></td></tr></table></figure>
<p>创建<strong>交叉编译工具链</strong>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ToolChain &amp;&amp; cd ToolChain</span><br></pre></td></tr></table></figure>
<p>使用<strong>axel</strong>多线程下载工具链 <strong>AArch64 ELF bare-metal target (aarch64-none-elf)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axel -n 32 -a https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf.tar.xz</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="5-创建裸机-Bare-Metal-程序"><a href="#5-创建裸机-Bare-Metal-程序" class="headerlink" title="5. 创建裸机(Bare Metal)程序"></a>5. 创建裸机(Bare Metal)程序</h2><blockquote>
<p>由于我们的目标是编写一个<strong>操作系统</strong>，所以我们需要创建一个<strong>独立于操作系统</strong>的<strong>可执行程序</strong>，又称<strong>独立式可执行程序</strong>（Freestanding Executable）或<strong>裸机程序</strong>（Bare-metal Executable）。</p>
<p>这意味着所有<strong>依赖于操作系统的库</strong>我们都<strong>不能使用</strong>。比如<code>std</code>中的大部分内容（<code>io</code>, <code>thread</code>, <code>file system</code>, etc…）都需要操作系统的支持，所以这部分内容我们不能使用。</p>
<p>但是，<strong>不依赖于操作系统</strong>的<strong>Rust</strong>的<strong>语言特性</strong>我们还是可以继续使用的，比如：<strong>迭代器</strong>、<strong>模式匹配</strong>、<strong>字符串格式化</strong>、<strong>所有权系统</strong>等。这使得<strong>Rust</strong>依旧可以作为一个<strong>功能强大</strong>的<strong>高级语言</strong>，帮助我们编写<strong>操作系统</strong>。</p>
</blockquote>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>回到<code>Home</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>
<p>新建名为<code>rui_armv8_os</code>的项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new rui_armv8_os --bin --edition 2021</span><br></pre></td></tr></table></figure>
<p>进入<code>rui_armv8_os</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd rui_armv8_os</span><br></pre></td></tr></table></figure>
<p>创建<strong>实验所需文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/panic.rs src/panic.rs src/start.s aarch64-qemu.ld aarch64-unknown-none-softfloat.json</span><br></pre></td></tr></table></figure>
<p>创建<code>.cargo</code>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir .cargo</span><br></pre></td></tr></table></figure>
<p>创建<code>.cargo/config.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .cargo/config.toml</span><br></pre></td></tr></table></figure>
<p>使用<a class="link"   target="_blank" rel="noopener" href="https://code.visualstudio.com/" >VSCode<i class="fas fa-external-link-alt"></i></a>打开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure>
<p><strong>VSCode</strong>安装<strong>Rust</strong>、<strong>Rust-Analyzer</strong>插件</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/VSCode%E6%8F%92%E4%BB%B6.png"
                        class="" title="VSCode插件"
                 >
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/VSCode%E6%8F%92%E4%BB%B62.png"
                        class="" title="VSCode插件2"
                 >

<p>编辑<code>src/main.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#![no_std] // 不使用标准库</span><br><span class="line">#![no_main] // 不使用预定义入口点</span><br><span class="line"></span><br><span class="line">use core::&#123;arch::global_asm, ptr&#125;; // 导入需要的Module</span><br><span class="line"></span><br><span class="line">mod panic;</span><br><span class="line"></span><br><span class="line">global_asm!(include_str!(&quot;start.s&quot;));</span><br><span class="line"></span><br><span class="line">#[no_mangle] // 不修改函数名</span><br><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    const UART0: *mut u8 = 0x0900_0000 as *mut u8;</span><br><span class="line">    let out_str = b&quot;AArch64 Bare Metal&quot;;</span><br><span class="line">    for byte in out_str &#123;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            ptr::write_volatile(UART0, *byte);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/panic.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line">#[panic_handler]</span><br><span class="line">fn on_panic(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    loop &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/start.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">.extern LD_STACK_PTR</span><br><span class="line">.section &quot;.text.boot&quot;</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">        ldr     x30, =LD_STACK_PTR</span><br><span class="line">        mov     sp, x30</span><br><span class="line">        bl      not_main</span><br><span class="line"></span><br><span class="line">.equ PSCI_SYSTEM_OFF, 0x84000002</span><br><span class="line">.globl system_off</span><br><span class="line">system_off:</span><br><span class="line">        ldr     x0, =PSCI_SYSTEM_OFF</span><br><span class="line">        hvc     #0</span><br></pre></td></tr></table></figure>
<p>编辑<code>aarch64-qemu.ld</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x40080000;</span><br><span class="line">    .text.boot : &#123; *(.text.boot) &#125;</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    . = . + 0x4000;</span><br><span class="line">    LD_STACK_PTR = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>aarch64-unknown-none-softfloat.json</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;abi-blacklist&quot;: [</span><br><span class="line">      &quot;stdcall&quot;,</span><br><span class="line">      &quot;fastcall&quot;,</span><br><span class="line">      &quot;vectorcall&quot;,</span><br><span class="line">      &quot;thiscall&quot;,</span><br><span class="line">      &quot;win64&quot;,</span><br><span class="line">      &quot;sysv64&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;arch&quot;: &quot;aarch64&quot;,</span><br><span class="line">    &quot;data-layout&quot;: &quot;e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128&quot;,</span><br><span class="line">    &quot;disable-redzone&quot;: true,</span><br><span class="line">    &quot;env&quot;: &quot;&quot;,</span><br><span class="line">    &quot;executables&quot;: true,</span><br><span class="line">    &quot;features&quot;: &quot;+strict-align,+neon,+fp-armv8&quot;,</span><br><span class="line">    &quot;is-builtin&quot;: false,</span><br><span class="line">    &quot;linker&quot;: &quot;rust-lld&quot;,</span><br><span class="line">    &quot;linker-flavor&quot;: &quot;ld.lld&quot;,</span><br><span class="line">    &quot;linker-is-gnu&quot;: true,</span><br><span class="line">    &quot;pre-link-args&quot;: &#123;</span><br><span class="line">      &quot;ld.lld&quot;: [&quot;-Taarch64-qemu.ld&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;llvm-target&quot;: &quot;aarch64-unknown-none&quot;,</span><br><span class="line">    &quot;max-atomic-width&quot;: 128,</span><br><span class="line">    &quot;os&quot;: &quot;none&quot;,</span><br><span class="line">    &quot;panic-strategy&quot;: &quot;abort&quot;,</span><br><span class="line">    &quot;relocation-model&quot;: &quot;static&quot;,</span><br><span class="line">    &quot;target-c-int-width&quot;: &quot;32&quot;,</span><br><span class="line">    &quot;target-endian&quot;: &quot;little&quot;,</span><br><span class="line">    &quot;target-pointer-width&quot;: &quot;64&quot;,</span><br><span class="line">    &quot;vendor&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>.cargo/config.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[unstable]</span><br><span class="line">build-std = [&quot;core&quot;, &quot;compiler_builtins&quot;] </span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = &quot;aarch64-unknown-none-softfloat.json&quot;</span><br></pre></td></tr></table></figure>
<p>编辑<code>Cargo.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;rui_armv8_os&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line">authors = [&quot;Rui Li &lt;rui@hnu.edu.cn&gt;&quot;]</span><br><span class="line"></span><br><span class="line"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line"></span><br><span class="line"># eh_personality语言项标记的函数，将被用于实现栈展开（stack unwinding）。</span><br><span class="line"># 在使用标准库的情况下，当panic发生时，Rust将使用栈展开，来运行在栈上活跃的</span><br><span class="line"># 所有变量的析构函数（destructor）——这确保了所有使用的内存都被释放。</span><br><span class="line"># 如果不禁用会出现错误：language item required, but not found: `eh_personality`</span><br><span class="line"># 通过下面的配置禁用栈展开</span><br><span class="line"># dev时禁用panic时栈展开</span><br><span class="line">[profile.dev]</span><br><span class="line">panic = &quot;abort&quot;</span><br><span class="line"></span><br><span class="line"># release时禁用panic时栈展开</span><br><span class="line">[profile.release]</span><br><span class="line">panic = &quot;abort&quot;</span><br></pre></td></tr></table></figure>

<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>在项目<strong>根目录</strong>下执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png"
                        class="" title="编译成功"
                 >
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E8%BF%90%E8%A1%8C.png"
                        class="" title="运行"
                 >

<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><blockquote>
<p>QEMU进入调试，启动调试服务器，默认端口1234</p>
</blockquote>
<p><strong>关闭</strong>之前运行的<strong>终端</strong>，打开一个<strong>新的终端</strong>，进入<code>rui_armv8_os</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd rui_armv8_os</span><br></pre></td></tr></table></figure>
<p><strong>启动调试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -S -s</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/GDB%E8%B0%83%E8%AF%95.png"
                        class="" title="GDB调试"
                 >

<p><strong>重新打开</strong>一个<strong>终端</strong>，进入<strong>工具链</strong><code>bin</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/ToolChain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin</span><br></pre></td></tr></table></figure>
<p>导出<strong>工具链路径</strong>临时变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ToolChainPath=`pwd`</span><br></pre></td></tr></table></figure>
<p>进入<code>rui_armv8_os</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rui_armv8_os</span><br></pre></td></tr></table></figure>
<p>配置<strong>临时工具链环境</strong>（这里的<code>$ToolChainPath</code>即是刚刚导出的临时变量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$ToolChainPath:$PATH</span><br></pre></td></tr></table></figure>
<p>启用<strong>GDB调试客户端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-elf-gdb target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<p>设置<strong>调试参数</strong>，开始<strong>调试</strong></p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/GDB%E8%B0%83%E8%AF%952.png"
                        class="" title="GDB调试2"
                 >
<p>连接<strong>调试客户端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>查看<strong>汇编码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble</span><br></pre></td></tr></table></figure>
<p><strong>单步运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/GDB%E8%B0%83%E8%AF%953.png"
                        class="" title="GDB调试3"
                 >

<h1 id="二、Hello-World"><a href="#二、Hello-World" class="headerlink" title="二、Hello World"></a>二、Hello World</h1><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceTwo.tar.gz" title="下载">下载</a></p>
</blockquote>
<blockquote>
<p><code>print</code>函数是学习几乎任何一种软件开发语言时<strong>最先</strong>学习使用的函数，同时该函数也是最基本和原始的<strong>程序调试手段</strong>，但该函数的实现却并<strong>不简单</strong>。本实验的目的在于<strong>理解操作系统与硬件的接口方法</strong>，并实现一个<strong>可打印字符的宏</strong>（<strong>非系统调用</strong>），用于后续的<strong>调试</strong>和<strong>开发</strong>。</p>
</blockquote>
<h2 id="1-了解virt机器"><a href="#1-了解virt机器" class="headerlink" title="1. 了解virt机器"></a>1. 了解virt机器</h2><blockquote>
<p><strong>操作系统</strong>介于<strong>硬件</strong>和<strong>应用程序</strong>之间，<strong>向下管理硬件资源</strong>，<strong>向上提供应用编程接口</strong>。设计并实现<strong>操作系统</strong>需要熟悉<strong>底层硬件</strong>的<strong>组成</strong>及其<strong>操作方法</strong>。</p>
<p>本系列实验都会在<strong>QEMU模拟器</strong>上完成，首先来了解一下模拟的<strong>机器信息</strong>。可以通过下列<strong>两种方法</strong>：</p>
</blockquote>
<h3 id="1-文档或源码方式"><a href="#1-文档或源码方式" class="headerlink" title="1) 文档或源码方式"></a>1) 文档或源码方式</h3><blockquote>
<p>查看<strong>QEMU</strong>关于<strong>virt</strong>的<a class="link"   target="_blank" rel="noopener" href="https://www.qemu.org/docs/master/system/arm/virt.html" >描述<i class="fas fa-external-link-alt"></i></a>， 或者查看<strong>QEMU</strong>的<strong>源码</strong>，如<strong>GitHub</strong>上的<a class="link"   target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/include/hw/arm/virt.h" >virt.h<i class="fas fa-external-link-alt"></i></a>和<a class="link"   target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/arm/virt.c" >virt.c<i class="fas fa-external-link-alt"></i></a>。<code>virt.c</code>中可见如下有关<strong>内存映射</strong>的内容。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Addresses and sizes of our components.</span><br><span class="line"> * 0..128MB is space for a flash device so we can run bootrom code such as UEFI.</span><br><span class="line"> * 128MB..256MB is used for miscellaneous device I/O.</span><br><span class="line"> * 256MB..1GB is reserved for possible future PCI support (ie where the</span><br><span class="line"> * PCI memory window will go if we add a PCI host controller).</span><br><span class="line"> * 1GB and up is RAM (which may happily spill over into the</span><br><span class="line"> * high memory region beyond 4GB).</span><br><span class="line"> * This represents a compromise between how much RAM can be given to</span><br><span class="line"> * a 32 bit VM and leaving space for expansion and in particular for PCI.</span><br><span class="line"> * Note that devices should generally be placed at multiples of 0x10000,</span><br><span class="line"> * to accommodate guests using 64K pages.</span><br><span class="line"> */</span><br><span class="line">static const MemMapEntry base_memmap[] = &#123;</span><br><span class="line">    /* Space up to 0x8000000 is reserved for a boot ROM */</span><br><span class="line">    [VIRT_FLASH] =              &#123;          0, 0x08000000 &#125;,</span><br><span class="line">    [VIRT_CPUPERIPHS] =         &#123; 0x08000000, 0x00020000 &#125;,</span><br><span class="line">    /* GIC distributor and CPU interfaces sit inside the CPU peripheral space */</span><br><span class="line">    [VIRT_GIC_DIST] =           &#123; 0x08000000, 0x00010000 &#125;,</span><br><span class="line">    [VIRT_GIC_CPU] =            &#123; 0x08010000, 0x00010000 &#125;,</span><br><span class="line">    [VIRT_GIC_V2M] =            &#123; 0x08020000, 0x00001000 &#125;,</span><br><span class="line">    [VIRT_GIC_HYP] =            &#123; 0x08030000, 0x00010000 &#125;,</span><br><span class="line">    [VIRT_GIC_VCPU] =           &#123; 0x08040000, 0x00010000 &#125;,</span><br><span class="line">    /* The space in between here is reserved for GICv3 CPU/vCPU/HYP */</span><br><span class="line">    [VIRT_GIC_ITS] =            &#123; 0x08080000, 0x00020000 &#125;,</span><br><span class="line">    /* This redistributor space allows up to 2*64kB*123 CPUs */</span><br><span class="line">    [VIRT_GIC_REDIST] =         &#123; 0x080A0000, 0x00F60000 &#125;,</span><br><span class="line">    [VIRT_UART] =               &#123; 0x09000000, 0x00001000 &#125;,</span><br><span class="line">    [VIRT_RTC] =                &#123; 0x09010000, 0x00001000 &#125;,</span><br><span class="line">    [VIRT_FW_CFG] =             &#123; 0x09020000, 0x00000018 &#125;,</span><br><span class="line">    [VIRT_GPIO] =               &#123; 0x09030000, 0x00001000 &#125;,</span><br><span class="line">    [VIRT_SECURE_UART] =        &#123; 0x09040000, 0x00001000 &#125;,</span><br><span class="line">    [VIRT_SMMU] =               &#123; 0x09050000, 0x00020000 &#125;,</span><br><span class="line">    [VIRT_PCDIMM_ACPI] =        &#123; 0x09070000, MEMORY_HOTPLUG_IO_LEN &#125;,</span><br><span class="line">    [VIRT_ACPI_GED] =           &#123; 0x09080000, ACPI_GED_EVT_SEL_LEN &#125;,</span><br><span class="line">    [VIRT_NVDIMM_ACPI] =        &#123; 0x09090000, NVDIMM_ACPI_IO_LEN&#125;,</span><br><span class="line">    [VIRT_PVTIME] =             &#123; 0x090a0000, 0x00010000 &#125;,</span><br><span class="line">    [VIRT_SECURE_GPIO] =        &#123; 0x090b0000, 0x00001000 &#125;,</span><br><span class="line">    [VIRT_MMIO] =               &#123; 0x0a000000, 0x00000200 &#125;,</span><br><span class="line">    /* ...repeating for a total of NUM_VIRTIO_TRANSPORTS, each of that size */</span><br><span class="line">    [VIRT_PLATFORM_BUS] =       &#123; 0x0c000000, 0x02000000 &#125;,</span><br><span class="line">    [VIRT_SECURE_MEM] =         &#123; 0x0e000000, 0x01000000 &#125;,</span><br><span class="line">    [VIRT_PCIE_MMIO] =          &#123; 0x10000000, 0x2eff0000 &#125;,</span><br><span class="line">    [VIRT_PCIE_PIO] =           &#123; 0x3eff0000, 0x00010000 &#125;,</span><br><span class="line">    [VIRT_PCIE_ECAM] =          &#123; 0x3f000000, 0x01000000 &#125;,</span><br><span class="line">    /* Actual RAM size depends on initial RAM and device memory settings */</span><br><span class="line">    [VIRT_MEM] =                &#123; GiB, LEGACY_RAMLIMIT_BYTES &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-设备树（Device-Tree）方式"><a href="#2-设备树（Device-Tree）方式" class="headerlink" title="2) 设备树（Device Tree）方式"></a>2) 设备树（Device Tree）方式</h3><p>首先安装<strong>DTC</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install device-tree-compiler</span><br></pre></td></tr></table></figure>
<p>新建一个<strong>设备树目录</strong>并<strong>进入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/device &amp;&amp; cd ~/device</span><br></pre></td></tr></table></figure>
<p>导出<strong>DT</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt,dumpdtb=virt.dtb -cpu cortex-a53 -nographic</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-machine virt</code>指明<strong>机器类型</strong>为<strong>virt</strong>，这是<strong>QEMU</strong>仿真的<strong>虚拟机器</strong>。</p>
</blockquote>
<p>用<strong>DTC</strong>将导出的<strong>Device Tree Blob</strong>转换为<strong>Device Tree Source</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtc -I dtb -O dts -o virt.dts virt.dtb</span><br></pre></td></tr></table></figure>
<p>用<strong>文本编辑器</strong>打开<code>virt.dts</code>，可以发现如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pl011@9000000 &#123;</span><br><span class="line">	clock-names = &quot;uartclk\0apb_pclk&quot;;</span><br><span class="line">	clocks = &lt;0x8000 0x8000&gt;;</span><br><span class="line">	interrupts = &lt;0x00 0x01 0x04&gt;;</span><br><span class="line">	reg = &lt;0x00 0x9000000 0x00 0x1000&gt;;</span><br><span class="line">	compatible = &quot;arm,pl011\0arm,primecell&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">/* ······ */</span><br><span class="line">chosen &#123;</span><br><span class="line">	stdout-path = &quot;/pl011@9000000&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由上可以看出，<strong>virt</strong>机器包含有<strong>pl011</strong>的设备，该设备的<strong>寄存器</strong>在<code>0x9000000</code>开始处。<strong>pl011</strong>实际上是一个<strong>UART设备</strong>，即<strong>串口</strong>。可以看到<strong>virt</strong>选择使用<strong>pl011</strong>作为<strong>标准输出</strong>，这是因为<strong>与PC不同</strong>，大部分<strong>嵌入式系统</strong>默认情况下<strong>并不包含VGA设备</strong>。</p>
</blockquote>
<h2 id="2-实现println-宏"><a href="#2-实现println-宏" class="headerlink" title="2. 实现println!宏"></a>2. 实现println!宏</h2><blockquote>
<p>我们参照<a class="link"   target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/" >Writing an OS in Rust - VGA Text Mode<i class="fas fa-external-link-alt"></i></a> （<a class="link"   target="_blank" rel="noopener" href="https://github.com/rustcc/writing-an-os-in-rust/blob/master/03-vga-text-mode.md" >使用Rust编写操作系统（三）：VGA字符模式<i class="fas fa-external-link-alt"></i></a>）来实现<code>println!</code>宏，但与之不同的是，我们使用<strong>串口</strong>来输出，而不是通过操作<strong>VGA</strong>的<strong>Frame Buffer</strong>。</p>
</blockquote>
<h3 id="1-用串口实现println-宏"><a href="#1-用串口实现println-宏" class="headerlink" title="1) 用串口实现println!宏"></a>1) 用串口实现println!宏</h3><p>进入<code>rui_armv8_os</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rui_armv8_os</span><br></pre></td></tr></table></figure>
<p>新建<code>src/uart_console.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/uart_console.rs</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/uart_console.rs</code>，定义一个<strong>Writer结构</strong>，实现<strong>字节写入</strong>和<strong>字符串写入</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构</span><br><span class="line">pub struct Writer;</span><br><span class="line"></span><br><span class="line">//往串口寄存器写入字节和字符串进行输出</span><br><span class="line">impl Writer &#123;</span><br><span class="line">    pub fn write_byte(&amp;mut self, byte: u8) &#123;</span><br><span class="line">        const UART0: *mut u8 = 0x0900_0000 as *mut u8;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            ptr::write_volatile(UART0, byte);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn write_string(&amp;mut self, s: &amp;str) &#123;</span><br><span class="line">        for byte in s.chars() &#123;</span><br><span class="line">            self.write_byte(byte as u8)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何操作硬件通常需要阅读<strong>硬件制造商</strong>提供的<strong>技术手册</strong>。如<strong>pl011</strong>串口设备（PrimeCell UART）是<strong>arm</strong>设计的，其<strong>技术参考手册</strong>可以通过其<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0183/latest/" >官网<i class="fas fa-external-link-alt"></i></a>查看。</p>
<p>依据之前<code>virt.dts</code>中的描述，<strong>pl011</strong>的<strong>寄存器</strong>在<strong>virt</strong>机器中被<strong>映射</strong>到了<code>0x9000000</code>的<strong>内存位置</strong>。通过访问<strong>pl011</strong>的<strong>技术参考手册</strong>中<code>Chapter 3. Programmers Model</code>中的<code>Summary of registers</code>一节可知：<strong>第0号寄存器</strong>是<strong>pl011</strong>串口的<strong>数据寄存器</strong>，用于<strong>数据</strong>的<strong>收发</strong>。其<strong>详细描述</strong>参见 <a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/register-descriptions/data-register--uartdr?lang=en" >这里<i class="fas fa-external-link-alt"></i></a>。</p>
<p>注意到我们只是向<strong>UART0</strong>写入，而没从<strong>UART0</strong>读出（如果读出会读出<strong>其他设备</strong>通过<strong>串口</strong>发送过来的数据，而<strong>不是</strong>刚才<strong>写入</strong>的数据，这与<strong>读写内存</strong>时是不一样的，详情参见<strong>pl011</strong>的<strong>技术手册</strong>），<strong>编译器</strong>在<strong>优化</strong>时可能对这部分代码进行<strong>错误</strong>的<strong>优化</strong>，如<strong>把这些操作都忽略掉</strong>。</p>
<p>使用<code>ptr::write_volatile</code>库的<strong>目的</strong>是告诉<strong>编译器</strong>，这些<strong>写入</strong>有<strong>特定目的</strong>，不应将其<strong>优化</strong>（也就是告诉编译器<strong>不要瞎优化</strong>，这些<strong>写入</strong>和<strong>读出</strong>都有<strong>特定用途</strong>。</p>
<p>比如<strong>连续两次读</strong>，<strong>编译器</strong>可能认为<strong>第二次读</strong>就是<strong>前次的值</strong>，所以<strong>优化</strong>掉<strong>第二次读</strong>，但对<strong>外设寄存器</strong>的<strong>连续读</strong>可能返回<strong>不同的值</strong>。</p>
<p>比如写，<strong>编译器</strong>可能认为<strong>写</strong>后没有<strong>读</strong>所以<strong>写</strong>没有作用，或者<strong>连续的写</strong>会<strong>覆盖</strong>前面的<strong>写</strong>，但对这些<strong>寄存器</strong>的<strong>写入</strong>对<strong>外设</strong>都有<strong>特定作用</strong>）。</p>
</blockquote>
<p>在<code>src/uart_console.rs</code>中为<strong>Write结构</strong>实现<code>core::fmt::Write</code><strong>trait</strong>，该<strong>trait</strong>会自动实现<code>write_fmt</code>方法，支持<strong>格式化</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构</span><br><span class="line">pub struct Writer;</span><br><span class="line"></span><br><span class="line">//往串口寄存器写入字节和字符串进行输出</span><br><span class="line">impl Writer &#123;</span><br><span class="line">    // ······</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl core::fmt::Write for Writer &#123;</span><br><span class="line">    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result &#123;</span><br><span class="line">        self.write_string(s);</span><br><span class="line"></span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于<strong>Rust</strong>的<code>core::fmt</code>实现<strong>格式化控制</strong>，可以使我们方便地<strong>打印不同类型</strong>的<strong>变量</strong>。实现<code>core::fmt::Write</code>后，我们就可以使用<strong>Rust</strong>内置的<strong>格式化</strong>宏<code>write!</code>和<code>writeln!</code>，这使你瞬间具有<strong>其他语言</strong>运行时所提供的<strong>格式化控制能力</strong>。</p>
</blockquote>
<h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2) 测试"></a>2) 测试</h3><p>在<code>main.rs</code>末尾加入以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#![no_std] // 不使用标准库</span><br><span class="line">#![no_main] // 不使用预定义入口点</span><br><span class="line"></span><br><span class="line">// ······</span><br><span class="line"></span><br><span class="line">#[no_mangle] // 不修改函数名</span><br><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    // ······</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">include!(&quot;uart_console.rs&quot;);</span><br><span class="line">use core::fmt;</span><br><span class="line"></span><br><span class="line">pub fn print_something() &#123;</span><br><span class="line">    // 一定要引用core::fmt::Write;否则报错：no method named `write_fmt` found for struct `Writer` in the current scope。</span><br><span class="line">    pub use core::fmt::Write;</span><br><span class="line"></span><br><span class="line">    let mut writer = Writer &#123;&#125;;</span><br><span class="line">    let display: fmt::Arguments = format_args!(&quot;hello arguments!\n&quot;);</span><br><span class="line"></span><br><span class="line">    writer.write_string(&quot;\n-----My writer-----\n&quot;);</span><br><span class="line">    writer.write_byte(b&#x27;H&#x27;);</span><br><span class="line">    writer.write_string(&quot;ello &quot;);</span><br><span class="line">    writer.write_string(&quot;World!\n&quot;);</span><br><span class="line">    writer.write_string(&quot;[0] Hello from Rust!\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 通过实现core::fmt::Write自动实现的方法</span><br><span class="line">    writer.write_fmt(display).unwrap();</span><br><span class="line">    // 使用write!宏</span><br><span class="line">    write!(writer, &quot;The numbers are &#123;&#125; and &#123;&#125; \n&quot;, &quot;42&quot;, &quot;1.0&quot;).unwrap();</span><br><span class="line"></span><br><span class="line">    writer.write_string(&quot;-----My writer-----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>main.rs</code>中<code>not_main</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    // ······</span><br><span class="line">    print_something(); // 调用测试函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译</strong>并<strong>运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/Writer.png"
                        class="" title="Writer"
                 >

<p>按住<code>CTRL + A</code>，然后松手按<code>C</code>，输入<code>quit</code>即可退出<strong>QEMU模拟器</strong>。</p>
<h3 id="3-全局实现"><a href="#3-全局实现" class="headerlink" title="3) 全局实现"></a>3) 全局实现</h3><blockquote>
<p>现在我们已经可以采用<code>print_something</code>函数通过<strong>串口输出</strong>字符了。但若要实现<strong>输出</strong>，我们需要<strong>两个</strong>步骤：<br>（1）创建<strong>Writer类型</strong>的<strong>实例</strong>。<br>（2）调用<strong>实例</strong>的<code>write_byte</code>或<code>write_string</code>等<strong>函数</strong>。</p>
<p>为了方便在<strong>其他模块</strong>中<strong>调用</strong>，我们希望可以<strong>直接执行步骤（2）</strong>而不是<strong>先执行步骤（1）</strong>再<strong>执行步骤（2）</strong>。</p>
<p>一般情况下可以通过将<strong>步骤（1）</strong>中的<strong>实例</strong>定义为<code>static</code>类型来实现，但<strong>Rust</strong>暂不支持<strong>Write</strong>r这样类型的<strong>静态（编译时）初始化</strong>，需要使用<code>lazy_static</code>来解决。此外，为了保证访问<strong>安全</strong>还引入了<strong>自旋锁（spin）</strong>。</p>
</blockquote>
<p>编辑<code>Cargo.toml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ······</span><br><span class="line"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">spin = &quot;0.9.2&quot;</span><br><span class="line"></span><br><span class="line">[dependencies.lazy_static]</span><br><span class="line">version = &quot;1.0&quot;</span><br><span class="line">features = [&quot;spin_no_std&quot;]</span><br><span class="line"></span><br><span class="line"># eh_personality语言项标记的函数，将被用于实现栈展开（stack unwinding）。</span><br><span class="line"># ······</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/uart_console.rs</code>，实现<code>print!</code>和<code>println!</code>宏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">impl core::fmt::Write for Writer &#123;</span><br><span class="line">    // ······</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use core::&#123;fmt, ptr&#125;;</span><br><span class="line"></span><br><span class="line">use lazy_static::lazy_static;</span><br><span class="line">use spin::Mutex;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    /// A global `Writer` instance that can be used for printing to the VGA text buffer.</span><br><span class="line">    ///</span><br><span class="line">    /// Used by the `print!` and `println!` macros.</span><br><span class="line">    pub static ref WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Like the `print!` macro in the standard library, but prints to the VGA text buffer.</span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! print &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::uart_console::_print(format_args!($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Like the `println!` macro in the standard library, but prints to the VGA text buffer.</span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! println &#123;</span><br><span class="line">    () =&gt; ($crate::print!(&quot;\n&quot;));</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::print!(&quot;&#123;&#125;\n&quot;, format_args!($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Prints the given formatted string to the VGA text buffer through the global `WRITER` instance.</span><br><span class="line">#[doc(hidden)]</span><br><span class="line">pub fn _print(args: fmt::Arguments) &#123;</span><br><span class="line">    use core::fmt::Write;</span><br><span class="line"></span><br><span class="line">    WRITER.lock().write_fmt(args).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main.rs</code>中<strong>注释或删除之前的<code>print_something()</code>函数及其调用</strong>，测试<code>println!</code>宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">mod uart_console;</span><br><span class="line">// ······</span><br><span class="line"></span><br><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    // ······</span><br><span class="line">    println!(&quot;\n[0] Hello from Rust!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译</strong>并<strong>运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/println.png"
                        class="" title="println"
                 >

<h1 id="三、设备树（可选）"><a href="#三、设备树（可选）" class="headerlink" title="三、设备树（可选）"></a>三、设备树（可选）</h1><blockquote>
<p>参考<a class="link"   target="_blank" rel="noopener" href="https://os2022exps-doc.readthedocs.io/zh_CN/latest/exp3/index.html" >湖南大学2022年操作系统课程实验 - 实验三 设备树（可选）<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceFour.tar.gz" title="下载">下载</a></p>
<p><strong>中断</strong>、<strong>异常</strong>和<strong>陷阱</strong>指令是<strong>操作系统</strong>的<strong>基石</strong>，现代操作系统就是由<strong>中断驱动</strong>的。本实验的目的在于<strong>深刻理解中断的原理和机制</strong>，<strong>掌握CPU访问设备控制器的方法</strong>，<strong>掌握ARM体系结构的中断机制和规范</strong>，<strong>实现时钟中断服务和部分异常处理</strong>等。</p>
</blockquote>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-陷入操作系统"><a href="#1-陷入操作系统" class="headerlink" title="1) 陷入操作系统"></a>1) 陷入操作系统</h3><blockquote>
<p>如下图所示，<strong>操作系统</strong>是一个<strong>多入口</strong>的<strong>程序</strong>，执行<strong>陷阱（Trap）指令</strong>，出现<strong>异常</strong>、<strong>发生中断</strong>时都会<strong>陷入</strong>到<strong>操作系统</strong>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/enter_into_os.png"
                        class="" title="enter_into_os"
                 >
</blockquote>
<h3 id="2-ARM的中断系统"><a href="#2-ARM的中断系统" class="headerlink" title="2) ARM的中断系统"></a>2) ARM的中断系统</h3><blockquote>
<p><strong>中断</strong>是一种<strong>硬件机制</strong>。借助于<strong>中断</strong>，<strong>CPU</strong>可以不必再采用<strong>轮询</strong>这种<strong>低效</strong>的方式<strong>访问外部设备</strong>。将所有的<strong>外部设备</strong>与<strong>CPU直接相连</strong>是<strong>不现实</strong>的，<strong>外部设备</strong>的<strong>中断请求</strong>一般经由<strong>中断控制器</strong>，由<strong>中断控制器</strong>仲裁后再转发给<strong>CPU</strong>。如下图所示<strong>ARM</strong>的<strong>中断系统</strong>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ARMGIC.png"
                        class="" title="ARMGIC"
                 >

<p>其中<strong>nIRQ</strong>是<strong>普通中断</strong>，<strong>nFIQ</strong>是<strong>快速中断</strong>。<strong>ARM</strong>采用的<strong>中断控制器</strong>叫做<strong>GIC</strong>，即<strong>General Interrupt Controller</strong>。<strong>GIC</strong>包括多个版本，如<strong>GICv1（已弃用）</strong>，<strong>GICv2</strong>，<strong>GICv3</strong>，<strong>GICv4</strong>。简单起见，我们实验将选用<strong>GICv2</strong>版本。</p>
<p>为了配置好<strong>GICv2中断控制器</strong>，与<strong>pl011串口</strong>一样，我们需要阅读其<strong>技术参考手册</strong>。</p>
<p>访问<strong>ARM</strong>官网下载<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/latest" >ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification<i class="fas fa-external-link-alt"></i></a>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/gicv2-logic.png"
                        class="" title="gicv2-logic"
                 >

<p>从上图（来源于<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/latest" >ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification<i class="fas fa-external-link-alt"></i></a>中的<strong>Chapter 2 GIC Partitioning</strong>）可以看出：</p>
<ul>
<li><strong>GICv2</strong>最多支持<strong>8核</strong>的<strong>中断管理</strong>。</li>
<li><strong>GIC</strong>包括<strong>两大主要部分</strong>（由图中<strong>蓝色虚竖线</strong>分隔，<strong>Distributor</strong>和<strong>CPU Interface</strong>由<strong>蓝色虚矩形框</strong>标示），分别是：<ul>
<li><strong>Distributor</strong>，其通过<code>GICD_</code>开头的寄存器进行控制（<strong>蓝色实矩形框</strong>标示）</li>
<li><strong>CPU Interface</strong>，其通过<code>GICC_</code>开头的寄存器进行控制（<strong>蓝色实矩形框</strong>标示）</li>
</ul>
</li>
<li><strong>中断类型</strong>分为以下几类（由图中<strong>红色虚线椭圆</strong>标示）：<ul>
<li><strong>SPI：（Shared Peripheral Interrupt）</strong>，<strong>共享外设中断</strong>。该<strong>中断</strong>来源于<strong>外设</strong>，通过<strong>Distributor</strong>分发给特定的<strong>Core</strong>，其<strong>中断编号</strong>为<strong>32-1019</strong>。从图中可以看到所有核<strong>共享SPI</strong>。</li>
<li><strong>PPI：（Private Peripheral Interrupt）</strong>，<strong>私有外设中断</strong>。该<strong>中断</strong>来源于<strong>外设</strong>，但只对指定的<strong>Core</strong>有效，<strong>中断信号</strong>只会发送给<strong>指定的Core</strong>，其<strong>中断编号</strong>为<strong>16-31</strong>。从图中可以看到每个<strong>Core</strong>都有自己的<strong>PPI</strong>。</li>
<li><strong>SGI：（Software-Generated Interrupt）</strong>，<strong>软中断</strong>。<strong>软件产生</strong>的<strong>中断</strong>，用于给其他的<strong>Core</strong>发送<strong>中断信号</strong>，其<strong>中断编号</strong>为<strong>0-15</strong>。</li>
<li><strong>Virtual Interrupt</strong>，<strong>虚拟中断</strong>，用于支持<strong>虚拟机</strong>。图中也可以看到，因为我们<strong>暂时不关心</strong>，所以没有标注。</li>
<li>此外可以看到<strong>（FIQ，IRQ）</strong>可通过<strong>b</strong>进行<strong>旁路</strong>，我们也不关心。如感兴趣可以查看<strong>技术手册</strong>了解细节。</li>
</ul>
</li>
</ul>
<p>此外，由<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/latest" >ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification<i class="fas fa-external-link-alt"></i></a>(Section 1.4.2)可知，<strong>外设中断</strong>可由<strong>两种方式</strong>触发：</p>
<ul>
<li><strong>Edge-Triggered</strong>：<strong>边沿触发</strong>，当检测到<strong>中断信号上升沿</strong>时<strong>中断有效</strong>。</li>
<li><strong>Level-Sensitive</strong>：<strong>电平触发</strong>，当<strong>中断源</strong>为<strong>指定电平</strong>时<strong>中断有效</strong>。<br>因为<strong>SOC</strong>中<strong>中断</strong>有很多，为了方便对<strong>中断的管理</strong>，对每个<strong>中断</strong>附加了<strong>中断优先级</strong>。在<strong>中断仲裁</strong>时，<strong>高优先级的中断</strong>，会<strong>优于低优先级的中断</strong>，发送给<strong>CPU处理</strong>。当<strong>CPU</strong>在<strong>响应低优先级中断</strong>时，如果此时来了<strong>高优先级中断</strong>，那么<strong>高优先级中断</strong>会<strong>抢占低优先级中断</strong>，而被<strong>处理器响应</strong>。<br>由<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/latest" >ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification<i class="fas fa-external-link-alt"></i></a>(Section 3.3)可知，<strong>GICv2</strong>最多支持<strong>256</strong>个<strong>中断优先级</strong>。<strong>GICv2</strong>中规定，所支持的<strong>中断优先级别数</strong>与<strong>GIC</strong>的具体实现有关，如果支持的<strong>中断优先级数</strong>比<strong>256</strong>少（最少为<strong>16</strong>），则<strong>8位优先级</strong>的<strong>低位</strong>为<strong>0</strong>，且遵循<strong>RAZ/WI（Read-As-Zero, Writes Ignored）</strong>原则。</li>
</ul>
</blockquote>
<h3 id="3-GICv2初始化"><a href="#3-GICv2初始化" class="headerlink" title="3) GICv2初始化"></a>3) GICv2初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* ······ */</span><br><span class="line">intc@8000000 &#123;</span><br><span class="line">    phandle = &lt;0x8001&gt;;</span><br><span class="line">    reg = &lt;0x00 0x8000000 0x00 0x10000 0x00 0x8010000 0x00 0x10000&gt;;</span><br><span class="line">    compatible = &quot;arm,cortex-a15-gic&quot;;</span><br><span class="line">    ranges;</span><br><span class="line">    #size-cells = &lt;0x02&gt;;</span><br><span class="line">    #address-cells = &lt;0x02&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;0x03&gt;;</span><br><span class="line"></span><br><span class="line">    v2m@8020000 &#123;</span><br><span class="line">        phandle = &lt;0x8002&gt;;</span><br><span class="line">        reg = &lt;0x00 0x8020000 0x00 0x1000&gt;;</span><br><span class="line">        msi-controller;</span><br><span class="line">        compatible = &quot;arm,gic-v2m-frame&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">/* ······ */</span><br><span class="line">timer &#123;</span><br><span class="line">    interrupts = &lt;0x01 0x0d 0x104 0x01 0x0e 0x104 0x01 0x0b 0x104 0x01 0x0a 0x104&gt;;</span><br><span class="line">    always-on;</span><br><span class="line">    compatible = &quot;arm,armv8-timer\0arm,armv7-timer&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由<code>virt.dts</code>中<code>intc</code>和<code>timer</code>的部分并结合<strong>kernel.org</strong>中关于<a class="link"   target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/arm%2Cgic.txt" >ARM Generic Interrupt Controller<i class="fas fa-external-link-alt"></i></a>和<a class="link"   target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/devicetree/bindings/arm/arch_timer.txt" >ARM architected timer<i class="fas fa-external-link-alt"></i></a>的<strong>DeviceTree</strong>的说明可知：</p>
<ul>
<li><code>intc</code>中的<code>reg</code>指明<strong>GICD寄存器</strong>映射到内存的位置为<code>0x8000000</code>，长度为<code>0x10000</code>，<strong>GICC寄存器</strong>映射到内存的位置为<code>0x8010000</code>，长度为<code>0x10000</code>。</li>
<li><code>intc</code>中的<code>#interrupt-cells</code>指明<strong>interrupts</strong>包括<strong>3</strong>个<strong>cells</strong>。<a class="link"   target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/arm%2Cgic.txt" >第一个文档<i class="fas fa-external-link-alt"></i></a>指明：第一个<strong>cell</strong>为<strong>中断类型</strong>，<strong>0</strong>表示<strong>SPI</strong>，<strong>1</strong>表示<strong>PPI</strong>；第二个<strong>cell</strong>为<strong>中断号</strong>，<strong>SPI</strong>范围为**[0-987]<strong>，</strong>PPI<strong>为</strong>[0-15]<strong>；第三个</strong>cell<strong>为</strong>flags<strong>，其中</strong>[3:0]<strong>位表示</strong>触发类型<strong>，</strong>[4]<strong>表示</strong>高电平触发<strong>，</strong>[15:8]<strong>为</strong>PPI<strong>的</strong>CPU中断掩码<strong>，每</strong>1<strong>位对应一个</strong>CPU<strong>，为</strong>1<strong>表示该</strong>中断<strong>会连接到对应的</strong>CPU**。</li>
<li>以<code>timer</code>设备为例，其中包括<strong>4</strong>个<strong>中断</strong>。以第<strong>2</strong>个<strong>中断</strong>的参数<code>0x01 0x0e 0x104</code>为例，其指明该<strong>中断</strong>为<strong>PPI</strong>类型的<strong>中断</strong>，<strong>中断号14</strong>， 路由到第一个<strong>CPU</strong>，且<strong>高电平触发</strong>。但注意到<strong>PPI</strong>的<strong>起始中断号</strong>为<strong>16</strong>，所以实际上该<strong>中断</strong>在<strong>GICv2</strong>中的<strong>中断号</strong>应为<strong>16 + 14 = 30</strong>。<br>阅读<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/latest" >ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification<i class="fas fa-external-link-alt"></i></a>，在<strong>Chapter 4 Programmers’ Model</strong>部分有关于<strong>GICD</strong>和<strong>GICC寄存器</strong>的<strong>描述，以及如何使能</strong>Distributor<strong>和</strong>CPU Interfaces**的方法。</li>
</ul>
</blockquote>
<h3 id="4-ARMv8的中断与异常处理"><a href="#4-ARMv8的中断与异常处理" class="headerlink" title="4) ARMv8的中断与异常处理"></a>4) ARMv8的中断与异常处理</h3><blockquote>
<p>访问<strong>ARM官网</strong>下载并阅读<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/Exception-handling-registers" >ARM Cortex-A Series Programmer’s Guide for ARMv8-A<i class="fas fa-external-link-alt"></i></a>和<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/100933/0100/AArch64-exception-vector-table" >AArch64 Exception and Interrupt Handling<i class="fas fa-external-link-alt"></i></a>等<strong>技术参考手册</strong>。<br><strong>ARMv8架构</strong>定义了<strong>两种执行状态(<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/Fundamentals-of-ARMv8/Execution-states" >Execution States<i class="fas fa-external-link-alt"></i></a>)<strong>：</strong>AArch64</strong>和<strong>AArch32</strong>。分别对应使用<strong>64位宽通用寄存器</strong>或<strong>32位宽通用寄存器</strong>的执行。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/aarch64_exception_levels_2.png"
                        class="" title="aarch64_exception_levels_2"
                 >
<p>上图所示为<strong>AArch64</strong>中的<strong>异常级别(Exception levels)<strong>的组织。可见</strong>AArch64</strong>中共有<strong>4</strong>个<strong>异常级别</strong>，分别为<strong>EL0</strong>，<strong>EL1</strong>，<strong>EL2</strong>和<strong>EL3</strong>。在<strong>AArch64</strong>中，<strong>Interrupt</strong>是<strong>Exception</strong>的<strong>子类型</strong>，称为<strong>异常</strong>。<strong>AArch64</strong>中有<strong>四种类型</strong>的<strong>异常</strong>：</p>
<ul>
<li><strong>Sync（Synchronous exceptions，同步异常）</strong>。在<strong>执行时触发</strong>的<strong>异常</strong>，例如在尝试<strong>访问不存在</strong>的<strong>内存地址</strong>时。</li>
<li><strong>IRQ （Interrupt requests，中断请求）</strong>。由<strong>外部设备</strong>产生的<strong>中断</strong>。</li>
<li><strong>FIQ （Fast Interrupt Requests，快速中断请求）</strong>。类似于<strong>IRQ</strong>，但具有<strong>更高</strong>的<strong>优先级</strong>，因此<strong>FIQ</strong>中断服务程序不能被其他<strong>IRQ</strong>或<strong>FIQ</strong>中断。</li>
<li><strong>SError （System Error，系统错误）</strong>。用于<strong>外部数据</strong>中止的<strong>异步中断</strong>。<br>当<strong>异常</strong>发生时，<strong>处理器</strong>将执行与该<strong>异常</strong>对应的<strong>异常处理代码</strong>。在<strong>ARM架构</strong>中，这些<strong>异常处理代码</strong>将会被保存在<strong>内存</strong>的<strong>异常向量表</strong>中。每一个<strong>异常级别（EL0，EL1，EL2和EL3）</strong>都有其对应的<strong>异常向量表</strong>。需要注意的是，与<strong>x86等架构</strong>不同，该表包含的是要执行的<strong>指令</strong>，而不是<strong>函数地址</strong>。</li>
</ul>
<p><strong>异常向量表</strong>的<strong>基地址</strong>由<code>VBAR_ELn</code>给出，然后每个表项都有一个从该<strong>基地址</strong>定义的<strong>偏移量</strong>。 每个表有<strong>16</strong>个表项，每个表项的大小为<strong>128（0x80）</strong>字节（<strong>32</strong>条<strong>指令</strong>）。 该表实际上有<strong>4</strong>组，每组<strong>4</strong>个表项。 分别是：</p>
<ul>
<li>发生于<strong>当前异常级别</strong>的<strong>异常</strong>且<strong>SPSel寄存器</strong>选择<strong>SP0</strong>，<strong>Sync</strong>、<strong>IRQ</strong>、<strong>FIQ</strong>、<strong>SError</strong>对应的<strong>4个异常处理</strong>。</li>
<li>发生于<strong>当前异常级别</strong>的<strong>异常</strong>且<strong>SPSel寄存器</strong>选择<strong>SPx</strong>，<strong>Sync</strong>、<strong>IRQ</strong>、<strong>FIQ</strong>、<strong>SError</strong>对应的<strong>4个异常处理</strong>。</li>
<li>发生于<strong>较低异常级别</strong>的<strong>异常</strong>且<strong>执行状态</strong>为<strong>AArch64</strong>，<strong>Sync</strong>、<strong>IRQ</strong>、<strong>FIQ</strong>、<strong>SError</strong>对应的<strong>4个异常处理</strong>。</li>
<li>发生于<strong>较低异常级别</strong>的<strong>异常</strong>且<strong>执行状态</strong>为<strong>AArch32</strong>，<strong>Sync</strong>、<strong>IRQ</strong>、<strong>FIQ</strong>、<strong>SError</strong>对应的<strong>4个异常处理</strong>。</li>
</ul>
</blockquote>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><h3 id="1-编写代码"><a href="#1-编写代码" class="headerlink" title="1) 编写代码"></a>1) 编写代码</h3><p>新建<code>src/interrupts.rs</code>，<code>src/exceptions.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/interrupts.rs src/exceptions.s</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/interrupts.rs</code>，定义各种<strong>常量</strong>，如<strong>寄存器地址</strong>和<strong>寄存器值</strong>等，然后定义<code>init_gicv2</code>函数对<strong>GICD</strong>和<strong>GICC</strong>进行<strong>初始化</strong>，最后定义若干<strong>辅助函数</strong>用于<strong>中断配置</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">use core::ptr;</span><br><span class="line"></span><br><span class="line">// GICD和GICC寄存器内存映射后的起始地址</span><br><span class="line">const GICD_BASE: u64 = 0x08000000;</span><br><span class="line">const GICC_BASE: u64 = 0x08010000;</span><br><span class="line"></span><br><span class="line">// Distributor</span><br><span class="line">const GICD_CTLR: *mut u32 = (GICD_BASE + 0x0) as *mut u32;</span><br><span class="line">const GICD_ISENABLER: *mut u32 = (GICD_BASE + 0x0100) as *mut u32;</span><br><span class="line">const GICD_ICENABLER: *mut u32 = (GICD_BASE + 0x0180) as *mut u32;</span><br><span class="line">const GICD_ICPENDR: *mut u32 = (GICD_BASE + 0x0280) as *mut u32;</span><br><span class="line">const GICD_IPRIORITYR: *mut u32 = (GICD_BASE + 0x0400) as *mut u32;</span><br><span class="line">const GICD_ICFGR: *mut u32 = (GICD_BASE + 0x0c00) as *mut u32;</span><br><span class="line"></span><br><span class="line">const GICD_CTLR_ENABLE: u32 = 1;  /* Enable GICD */</span><br><span class="line">const GICD_CTLR_DISABLE: u32 = 0;     /* Disable GICD */</span><br><span class="line">const GICD_ISENABLER_SIZE: u32 = 32;</span><br><span class="line">const GICD_ICENABLER_SIZE: u32 = 32;</span><br><span class="line">const GICD_ICPENDR_SIZE: u32 = 32;</span><br><span class="line">const GICD_IPRIORITY_SIZE: u32 = 4;</span><br><span class="line">const GICD_IPRIORITY_BITS: u32 = 8;</span><br><span class="line">const GICD_ICFGR_SIZE: u32 = 16;</span><br><span class="line">const GICD_ICFGR_BITS: u32 = 2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CPU Interface</span><br><span class="line">const GICC_CTLR: *mut u32 = (GICC_BASE + 0x0) as *mut u32;</span><br><span class="line">const GICC_PMR: *mut u32 = (GICC_BASE + 0x0004) as *mut u32;</span><br><span class="line">const GICC_BPR: *mut u32 = (GICC_BASE + 0x0008) as *mut u32;</span><br><span class="line"></span><br><span class="line">const GICC_CTLR_ENABLE: u32 = 1;</span><br><span class="line">const GICC_CTLR_DISABLE: u32 = 0;</span><br><span class="line">// Priority Mask Register. interrupt priority filter, Higher priority corresponds to a lower Priority field value.</span><br><span class="line">const GICC_PMR_PRIO_LOW: u32 = 0xff;</span><br><span class="line">// The register defines the point at which the priority value fields split into two parts,</span><br><span class="line">// the group priority field and the subpriority field. The group priority field is used to</span><br><span class="line">// determine interrupt preemption. NO GROUP.</span><br><span class="line">const GICC_BPR_NO_GROUP: u32 = 0x00;</span><br><span class="line"></span><br><span class="line">pub fn init_gicv2() &#123;</span><br><span class="line">    // 初始化Gicv2的distributor和cpu interface</span><br><span class="line">    // 禁用distributor和cpu interface后进行相应配置</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(GICD_CTLR, GICD_CTLR_DISABLE);</span><br><span class="line">        ptr::write_volatile(GICC_CTLR, GICC_CTLR_DISABLE);</span><br><span class="line">        ptr::write_volatile(GICC_PMR, GICC_PMR_PRIO_LOW);</span><br><span class="line">        ptr::write_volatile(GICC_BPR, GICC_BPR_NO_GROUP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启用distributor和cpu interface</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(GICD_CTLR, GICD_CTLR_ENABLE);</span><br><span class="line">        ptr::write_volatile(GICC_CTLR, GICC_CTLR_ENABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使能中断号为interrupt的中断</span><br><span class="line">pub fn enable(interrupt: u32) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(</span><br><span class="line">            GICD_ISENABLER.add((interrupt / GICD_ISENABLER_SIZE) as usize),</span><br><span class="line">            1 &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 禁用中断号为interrupt的中断</span><br><span class="line">pub fn disable(interrupt: u32) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(</span><br><span class="line">            GICD_ICENABLER.add((interrupt / GICD_ICENABLER_SIZE) as usize),</span><br><span class="line">            1 &lt;&lt; (interrupt % GICD_ICENABLER_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 清除中断号为interrupt的中断</span><br><span class="line">pub fn clear(interrupt: u32) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(</span><br><span class="line">            GICD_ICPENDR.add((interrupt / GICD_ICPENDR_SIZE) as usize),</span><br><span class="line">            1 &lt;&lt; (interrupt % GICD_ICPENDR_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置中断号为interrupt的中断的优先级为priority</span><br><span class="line">pub fn set_priority(interrupt: u32, priority: u32) &#123;</span><br><span class="line">    let shift = (interrupt % GICD_IPRIORITY_SIZE) * GICD_IPRIORITY_BITS;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        let addr: *mut u32 = GICD_IPRIORITYR.add((interrupt / GICD_IPRIORITY_SIZE) as usize);</span><br><span class="line">        let mut value: u32 = ptr::read_volatile(addr);</span><br><span class="line">        value &amp;= !(0xff &lt;&lt; shift);</span><br><span class="line">        value |= priority &lt;&lt; shift;</span><br><span class="line">        ptr::write_volatile(addr, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置中断号为interrupt的中断的属性为config</span><br><span class="line">pub fn set_config(interrupt: u32, config: u32) &#123;</span><br><span class="line">    let shift = (interrupt % GICD_ICFGR_SIZE) * GICD_ICFGR_BITS;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        let addr: *mut u32 = GICD_ICFGR.add((interrupt / GICD_ICFGR_SIZE) as usize);</span><br><span class="line">        let mut value: u32 = ptr::read_volatile(addr);</span><br><span class="line">        value &amp;= !(0x03 &lt;&lt; shift);</span><br><span class="line">        value |= config &lt;&lt; shift;</span><br><span class="line">        ptr::write_volatile(addr, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/exceptions.s</code>，参照<a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/AArch64-exception-table" >AArch64 exception table<i class="fas fa-external-link-alt"></i></a>定义异常向量表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT OR Apache-2.0</span><br><span class="line">//</span><br><span class="line">// Copyright (c) 2018-2021 Andre Richter &lt;andre.o.richter@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">.extern el1_sp0_sync</span><br><span class="line">.extern el1_sp0_irq</span><br><span class="line">.extern el1_sp0_fiq</span><br><span class="line">.extern el1_sp0_error</span><br><span class="line">.extern el1_sync</span><br><span class="line">.extern el1_irq</span><br><span class="line">.extern el1_fiq</span><br><span class="line">.extern el1_error</span><br><span class="line">.extern el0_sync</span><br><span class="line">.extern el0_irq</span><br><span class="line">.extern el0_fiq</span><br><span class="line">.extern el0_error</span><br><span class="line">.extern el0_32_sync</span><br><span class="line">.extern el0_32_irq</span><br><span class="line">.extern el0_32_fiq</span><br><span class="line">.extern el0_32_error</span><br><span class="line"></span><br><span class="line">//--------------------------------------------------------------------------------------------------</span><br><span class="line">// Definitions</span><br><span class="line">//--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">/// Call the function provided by parameter `\handler` after saving the exception context. Provide</span><br><span class="line">/// the context as the first parameter to &#x27;\handler&#x27;.</span><br><span class="line">.equ CONTEXT_SIZE, 264</span><br><span class="line"></span><br><span class="line">.section .text.exceptions</span><br><span class="line"></span><br><span class="line">.macro EXCEPTION_VECTOR handler</span><br><span class="line">    sub sp, sp, #CONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">// store general purpose registers</span><br><span class="line">    stp x0, x1, [sp, #16 * 0]</span><br><span class="line">    stp x2, x3, [sp, #16 * 1]</span><br><span class="line">    stp x4, x5, [sp, #16 * 2]</span><br><span class="line">    stp x6, x7, [sp, #16 * 3]</span><br><span class="line">    stp x8, x9, [sp, #16 * 4]</span><br><span class="line">    stp x10, x11, [sp, #16 * 5]</span><br><span class="line">    stp x12, x13, [sp, #16 * 6]</span><br><span class="line">    stp x14, x15, [sp, #16 * 7]</span><br><span class="line">    stp x16, x17, [sp, #16 * 8]</span><br><span class="line">    stp x18, x19, [sp, #16 * 9]</span><br><span class="line">    stp x20, x21, [sp, #16 * 10]</span><br><span class="line">    stp x22, x23, [sp, #16 * 11]</span><br><span class="line">    stp x24, x25, [sp, #16 * 12]</span><br><span class="line">    stp x26, x27, [sp, #16 * 13]</span><br><span class="line">    stp x28, x29, [sp, #16 * 14]</span><br><span class="line"></span><br><span class="line">// store exception link register and saved processor state register</span><br><span class="line">    mrs x0, elr_el1</span><br><span class="line">    mrs x1, spsr_el1</span><br><span class="line">    stp x0, x1, [sp, #16 * 15]</span><br><span class="line"></span><br><span class="line">// store link register which is x30</span><br><span class="line">    str x30, [sp, #16 * 16]</span><br><span class="line">    mov x0, sp</span><br><span class="line"></span><br><span class="line">// call exception handler</span><br><span class="line">    bl \handler</span><br><span class="line"></span><br><span class="line">// exit exception</span><br><span class="line">    b .exit_exception</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//--------------------------------------------------------------------------------------------------</span><br><span class="line">// Private Code</span><br><span class="line">//--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//------------------------------------------------------------------------------</span><br><span class="line">// The exception vector table.</span><br><span class="line">//------------------------------------------------------------------------------</span><br><span class="line">/** When an exception occurs, the processor must execute handler code that corresponds to the exception.</span><br><span class="line">The location in memory where the handler is stored is called the exception vector. In the ARM architecture,</span><br><span class="line">exception vectors are stored in a table, called the exception vector table.</span><br><span class="line"></span><br><span class="line">Each Exception level has its own vector table, that is, there is one for each of EL3, EL2, and EL1. The table contains</span><br><span class="line">instructions to be executed, rather than a set of addresses. These would normally be branch instructions that direct the</span><br><span class="line">core to the full exception handler.</span><br><span class="line"></span><br><span class="line">The exception vector table for EL1, for example, holds instructions for handling all types of exception that can occur at EL1,</span><br><span class="line">Vectors for individual exceptions are at fixed offsets from the beginning of the table. The virtual address of each table base</span><br><span class="line">is set by the Vector Based Address Registers: VBAR_EL3, VBAR_EL2 and VBAR_EL1.</span><br><span class="line"></span><br><span class="line">Each entry in the vector table is 16 instructions long (in ARMv7-A and AArch32, each entry is only 4 bytes). This means that in</span><br><span class="line">AArch64 the top-level handler can be written directly in the vector table.</span><br><span class="line"></span><br><span class="line">The base address is given by VBAR_ELn and each entry has a defined offset from this base address. Each table has 16 entries,</span><br><span class="line">with each entry being 128 bytes (32 instructions) in size. The table effectively consists of 4 sets of 4 entries. Which entry</span><br><span class="line">is used depends on several factors:</span><br><span class="line"></span><br><span class="line">The type of exception (SError, FIQ, IRQ, or Synchronous)</span><br><span class="line">If the exception is being taken at the same Exception level, the stack pointer to be used (SP0 or SPn)</span><br><span class="line">If the exception is being taken at a lower Exception level, the Execution state of the next lower level (AArch64 or AArch32).</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .text.exceptions_vector_table</span><br><span class="line">// Export a symbol for the Rust code to use.</span><br><span class="line">.globl exception_vector_table</span><br><span class="line">exception_vector_table:</span><br><span class="line"></span><br><span class="line">.org 0x0000</span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_sync</span><br><span class="line"></span><br><span class="line">.org 0x0080</span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_irq</span><br><span class="line"></span><br><span class="line">.org 0x0100</span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_fiq</span><br><span class="line"></span><br><span class="line">.org 0x0180</span><br><span class="line">    EXCEPTION_VECTOR el1_sp0_error</span><br><span class="line"></span><br><span class="line">.org 0x0200</span><br><span class="line">    EXCEPTION_VECTOR el1_sync</span><br><span class="line"></span><br><span class="line">.org 0x0280</span><br><span class="line">    EXCEPTION_VECTOR el1_irq</span><br><span class="line"></span><br><span class="line">.org 0x0300</span><br><span class="line">    EXCEPTION_VECTOR el1_fiq</span><br><span class="line"></span><br><span class="line">.org 0x0380</span><br><span class="line">    EXCEPTION_VECTOR el1_error</span><br><span class="line"></span><br><span class="line">.org 0x0400</span><br><span class="line">    EXCEPTION_VECTOR el0_sync</span><br><span class="line"></span><br><span class="line">.org 0x0480</span><br><span class="line">    EXCEPTION_VECTOR el0_irq</span><br><span class="line"></span><br><span class="line">.org 0x0500</span><br><span class="line">    EXCEPTION_VECTOR el0_fiq</span><br><span class="line"></span><br><span class="line">.org 0x0580</span><br><span class="line">    EXCEPTION_VECTOR el0_error</span><br><span class="line"></span><br><span class="line">.org 0x0600</span><br><span class="line">    EXCEPTION_VECTOR el0_32_sync</span><br><span class="line"></span><br><span class="line">.org 0x0680</span><br><span class="line">    EXCEPTION_VECTOR el0_32_irq</span><br><span class="line"></span><br><span class="line">.org 0x0700</span><br><span class="line">    EXCEPTION_VECTOR el0_32_fiq</span><br><span class="line"></span><br><span class="line">.org 0x0780</span><br><span class="line">    EXCEPTION_VECTOR el0_32_error</span><br><span class="line"></span><br><span class="line">.org 0x0800</span><br><span class="line"></span><br><span class="line">.exit_exception:</span><br><span class="line">// restore link register</span><br><span class="line">    ldr x30, [sp, #16 * 16]</span><br><span class="line"></span><br><span class="line">// restore exception link register and saved processor state register</span><br><span class="line">    ldp x0, x1, [sp, #16 * 15]</span><br><span class="line">    msr elr_el1, x0</span><br><span class="line">    msr spsr_el1, x1</span><br><span class="line"></span><br><span class="line">// restore general purpose registers</span><br><span class="line">    ldp x28, x29, [sp, #16 * 14]</span><br><span class="line">    ldp x26, x27, [sp, #16 * 13]</span><br><span class="line">    ldp x24, x25, [sp, #16 * 12]</span><br><span class="line">    ldp x22, x23, [sp, #16 * 11]</span><br><span class="line">    ldp x20, x21, [sp, #16 * 10]</span><br><span class="line">    ldp x18, x19, [sp, #16 * 9]</span><br><span class="line">    ldp x16, x17, [sp, #16 * 8]</span><br><span class="line">    ldp x14, x15, [sp, #16 * 7]</span><br><span class="line">    ldp x12, x13, [sp, #16 * 6]</span><br><span class="line">    ldp x10, x11, [sp, #16 * 5]</span><br><span class="line">    ldp x8, x9, [sp, #16 * 4]</span><br><span class="line">    ldp x6, x7, [sp, #16 * 3]</span><br><span class="line">    ldp x4, x5, [sp, #16 * 2]</span><br><span class="line">    ldp x2, x3, [sp, #16 * 1]</span><br><span class="line">    ldp x0, x1, [sp, #16 * 0]</span><br><span class="line"></span><br><span class="line">// restore stack pointer</span><br><span class="line">    add sp, sp, #CONTEXT_SIZE</span><br><span class="line">    eret</span><br></pre></td></tr></table></figure>

<p>编辑<code>src/interrupts.rs</code>，文末引入<code>exceptions.s</code>，同时定义结构<code>ExceptionCtx</code>，与<code>src/exceptions.s</code>中<code>EXCEPTION_VECTOR</code>宏保存的<strong>寄存器数据</strong>对应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">// 注意：这里的······代表承接并省略上文代码</span><br><span class="line">use core::arch::global_asm;</span><br><span class="line">global_asm!(include_str!(&quot;exceptions.s&quot;));</span><br><span class="line"></span><br><span class="line">#[repr(C)]</span><br><span class="line">pub struct ExceptionCtx &#123;</span><br><span class="line">    regs: [u64; 30],</span><br><span class="line">    elr_el1: u64,</span><br><span class="line">    spsr_el1: u64,</span><br><span class="line">    lr: u64,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续编辑<code>src/interrupts.rs</code>，在<code>EXCEPTION_VECTOR</code>宏中，每一类<strong>中断</strong>都对应一个<strong>处理函数</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">const EL1_SP0_SYNC: &amp;&#x27;static str = &quot;EL1_SP0_SYNC&quot;;</span><br><span class="line">const EL1_SP0_IRQ: &amp;&#x27;static str = &quot;EL1_SP0_IRQ&quot;;</span><br><span class="line">const EL1_SP0_FIQ: &amp;&#x27;static str = &quot;EL1_SP0_FIQ&quot;;</span><br><span class="line">const EL1_SP0_ERROR: &amp;&#x27;static str = &quot;EL1_SP0_ERROR&quot;;</span><br><span class="line">const EL1_SYNC: &amp;&#x27;static str = &quot;EL1_SYNC&quot;;</span><br><span class="line">const EL1_IRQ: &amp;&#x27;static str = &quot;EL1_IRQ&quot;;</span><br><span class="line">const EL1_FIQ: &amp;&#x27;static str = &quot;EL1_FIQ&quot;;</span><br><span class="line">const EL1_ERROR: &amp;&#x27;static str = &quot;EL1_ERROR&quot;;</span><br><span class="line">const EL0_SYNC: &amp;&#x27;static str = &quot;EL0_SYNC&quot;;</span><br><span class="line">const EL0_IRQ: &amp;&#x27;static str = &quot;EL0_IRQ&quot;;</span><br><span class="line">const EL0_FIQ: &amp;&#x27;static str = &quot;EL0_FIQ&quot;;</span><br><span class="line">const EL0_ERROR: &amp;&#x27;static str = &quot;EL0_ERROR&quot;;</span><br><span class="line">const EL0_32_SYNC: &amp;&#x27;static str = &quot;EL0_32_SYNC&quot;;</span><br><span class="line">const EL0_32_IRQ: &amp;&#x27;static str = &quot;EL0_32_IRQ&quot;;</span><br><span class="line">const EL0_32_FIQ: &amp;&#x27;static str = &quot;EL0_32_FIQ&quot;;</span><br><span class="line">const EL0_32_ERROR: &amp;&#x27;static str = &quot;EL0_32_ERROR&quot;;</span><br><span class="line"></span><br><span class="line">// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息</span><br><span class="line">fn catch(ctx: &amp;mut ExceptionCtx, name: &amp;str) &#123;</span><br><span class="line">    crate::print!(</span><br><span class="line">        &quot;\n  \</span><br><span class="line">        &#123;&#125; @ 0x&#123;:016x&#125;\n\n &quot;,</span><br><span class="line">        name,</span><br><span class="line">        ctx.elr_el1,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_sp0_sync(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_SP0_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_sp0_irq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_SP0_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_sp0_fiq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_SP0_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_sp0_error(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_SP0_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_sync(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_irq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_fiq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_error(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL1_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_sync(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_irq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_fiq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_error(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_32_sync(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_32_SYNC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_32_irq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_32_IRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_32_fiq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_32_FIQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el0_32_error(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    catch(ctx, EL0_32_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑<code>src/start.s</code>，载入<strong>异常向量表</strong><code>exception_vector_table</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">        mov     sp, x30</span><br><span class="line"></span><br><span class="line">        // Initialize exceptions</span><br><span class="line">        ldr     x0, =exception_vector_table</span><br><span class="line">        msr     vbar_el1, x0</span><br><span class="line">        isb</span><br><span class="line"></span><br><span class="line">        bl      not_main</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/start.s.png"
                        class="" title="start.s"
                 >

<p>编辑<code>aarch64-qemu.ld</code>，处理链接脚本，为<code>exceptions.s</code>中定义的<code>exceptions_vector_table</code>选择位置，同时满足<strong>4K对齐</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">    .text.boot : &#123; *(.text.boot) &#125;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        KEEP(*(.text.boot))</span><br><span class="line">        *(.text.exceptions)</span><br><span class="line">        . = ALIGN(4096); /* align for exceptions_vector_table*/</span><br><span class="line">        *(.text.exceptions_vector_table)</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/aarch64-qemu.ld.png"
                        class="" title="aarch64-qemu.ld"
                 >

<p>编辑<code>src/main.rs</code>，引入<code>interrupts.rs</code>模块，并在<code>not_main()</code>函数中注释掉之前的输出代码，调用<code>init_gicv2()</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">mod panic;</span><br><span class="line">mod uart_console;</span><br><span class="line">mod interrupts;</span><br><span class="line"></span><br><span class="line">global_asm!(include_str!(&quot;start.s&quot;));</span><br><span class="line">// ······</span><br><span class="line">#[no_mangle] // 不修改函数名</span><br><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    // const UART0: *mut u8 = 0x0900_0000 as *mut u8;</span><br><span class="line">    // let out_str = b&quot;AArch64 Bare Metal&quot;;</span><br><span class="line">    // for byte in out_str &#123;</span><br><span class="line">    //     unsafe &#123;</span><br><span class="line">    //         ptr::write_volatile(UART0, *byte);</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // // print_something(); // 调用测试函数</span><br><span class="line">    // println!(&quot;\n[0] Hello from Rust!&quot;);</span><br><span class="line">    interrupts::init_gicv2();</span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/main.rs.png"
                        class="" title="main.rs"
                 >
<p>至此，我们已经在<strong>EL1级别</strong>定义了完整的<strong>中断处理框架</strong>，可以开始处理实际的<strong>中断</strong>了。</p>
<h3 id="2-使能时钟中断"><a href="#2-使能时钟中断" class="headerlink" title="2) 使能时钟中断"></a>2) 使能时钟中断</h3><p>编辑<code>src/interrupts.rs</code>，在<code>init_gicv2</code>函数中添加<strong>使能时钟中断</strong>，同时配置<strong>时钟</strong>每秒产生一次<strong>中断</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">use core::arch::asm;</span><br><span class="line">pub fn init_gicv2() &#123;</span><br><span class="line">    // ······</span><br><span class="line">    // 启用distributor和cpu interface</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(GICD_CTLR, GICD_CTLR_ENABLE);</span><br><span class="line">        ptr::write_volatile(GICC_CTLR, GICC_CTLR_ENABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 电平触发</span><br><span class="line">    const ICFGR_LEVEL: u32 = 0;</span><br><span class="line">    // 时钟中断号30</span><br><span class="line">    const TIMER_IRQ: u32 = 30;</span><br><span class="line">    set_config(TIMER_IRQ, ICFGR_LEVEL); // 电平触发</span><br><span class="line">    set_priority(TIMER_IRQ, 0); // 优先级设定</span><br><span class="line">    clear(TIMER_IRQ); // 清除中断请求</span><br><span class="line">    enable(TIMER_IRQ); // 使能中断</span><br><span class="line">    </span><br><span class="line">    //配置timer</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        asm!(&quot;mrs x1, CNTFRQ_EL0&quot;); // 读取系统频率</span><br><span class="line">        asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);  // 设置定时寄存器</span><br><span class="line">        asm!(&quot;mov x0, 1&quot;);</span><br><span class="line">        asm!(&quot;msr CNTP_CTL_EL0, x0&quot;); // enable=1, imask=0, istatus= 0,</span><br><span class="line">        asm!(&quot;msr daifclr, #2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/interrupts.rs.png"
                        class="" title="interrupts.rs"
                 >

<h3 id="3-调试"><a href="#3-调试" class="headerlink" title="3) 调试"></a>3) 调试</h3><p><strong>编译</strong>并以<strong>调试模式</strong>运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -S -s</span><br></pre></td></tr></table></figure>
<p><strong>保持</strong>此<strong>终端会话</strong>，<strong>新开一个终端</strong>，配置<strong>GDB环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/ToolChain/gcc-arm-10.3-2021.07-x86_64-aarch64-none-elf/bin</span><br><span class="line">export ToolChainPath=`pwd`</span><br><span class="line">cd ~/rui_armv8_os</span><br><span class="line">export PATH=$ToolChainPath:$PATH</span><br></pre></td></tr></table></figure>
<p>启动<strong>GDB调试客户端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-elf-gdb target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<p>连接<strong>远程客户端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>在<code>not_main()</code>函数处<strong>设置断点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b not_main</span><br></pre></td></tr></table></figure>
<p>运行到<code>interrupts::init_gicv2();</code>语句之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/init_gicv2().png"
                        class="" title="init_gicv2()"
                 >
<p>我们之前在<code>init_gicv2()</code>函数中加入了以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 电平触发</span><br><span class="line">const ICFGR_LEVEL: u32 = 0;</span><br><span class="line">// 时钟中断号30</span><br><span class="line">const TIMER_IRQ: u32 = 30;</span><br><span class="line">set_config(TIMER_IRQ, ICFGR_LEVEL); //电平触发</span><br><span class="line">set_priority(TIMER_IRQ, 0); //优先级设定</span><br><span class="line">clear(TIMER_IRQ); //清除中断请求</span><br><span class="line">enable(TIMER_IRQ); //使能中断</span><br></pre></td></tr></table></figure>
<p>因此，当我们运行<code>init_gicv2()</code>函数后，其中的<code>enable(TIMER_IRQ);</code>会产生<strong>使能中断</strong>。我们查看<code>enable()</code>函数的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使能中断号为interrupt的中断</span><br><span class="line">pub fn enable(interrupt: u32) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        ptr::write_volatile(</span><br><span class="line">            GICD_ISENABLER.add((interrupt / GICD_ISENABLER_SIZE) as usize),</span><br><span class="line">            1 &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，该函数对<code>GICD_ISENABLER + interrupt / GICD_ISENABLER_SIZE</code>对应的地址<strong>易失性</strong>写入<code>1 &lt;&lt; (interrupt % GICD_ISENABLER_SIZE)</code>。</p>
<p>我们之前在<code>src/interrupts.rs</code>中定义<code>GICD</code>寄存器内存映射<code>GICD_BASE</code>的起始地址为<code>0x08000000</code>，而<code>GICD_ISENABLER</code>的地址为<code>GICD_BASE + 0x0100 = 0x08000100</code>，<code>GICD_ISENABLER_SIZE</code>为<code>32</code>，<code>TIMER_IRQ</code>为<code>30</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const GICD_BASE: u64 = 0x08000000;</span><br><span class="line">const GICD_ISENABLER: *mut u32 = (GICD_BASE + 0x0100) as *mut u32;</span><br><span class="line">const GICD_ISENABLER_SIZE: u32 = 32;</span><br><span class="line">const TIMER_IRQ: u32 = 30;</span><br></pre></td></tr></table></figure>

<p>因此，对于<code>enable(TIMER_IRQ);</code>，我们可以理解为在<code>0x08000100</code>中<strong>易失性</strong>写入<strong>1左移30位</strong>后的<strong>二进制数</strong>。</p>
<p>查看<code>0x08000100</code>地址中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/t 0x08000100</span><br></pre></td></tr></table></figure>
<p>我们得到了<code>0000000000000000111111111111111</code>，继续运行，执行<code>interrupts::init_gicv2();</code>，再次查看<code>0x08000100</code>地址中的值，此时变为了<code>0100000000000000111111111111111</code></p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/init_gicv2()2.png"
                        class="" title="init_gicv2()2"
                 >
<p><del>由此证明<strong>中断</strong>产生了。</del><br>实际上这里<strong>并没有产生中断</strong>！我们只是<strong>初始化</strong>了<strong>GICV2</strong>并且写入<strong>TIMER_IRQ中断号</strong>，如果<strong>时钟中断</strong>生效了，那么理论上来说<strong>每隔一秒</strong>都会<strong>调用一次</strong><code>el1_irq()</code>回调函数并且<strong>打印相应的中断信息</strong>，<strong>哪里出问题了呢？</strong></p>
<h1 id="四-、实现真正的时钟中断"><a href="#四-、实现真正的时钟中断" class="headerlink" title="四*、实现真正的时钟中断"></a>四*、实现真正的时钟中断</h1><h2 id="1-整理代码"><a href="#1-整理代码" class="headerlink" title="1. 整理代码"></a>1. 整理代码</h2><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceFourClean.tar.gz" title="下载">下载</a></p>
</blockquote>
<p>在实现真正的<strong>时钟中断</strong>之前，我们的<strong>代码</strong>已经有<strong>亿</strong>点乱了，并且还会有很多<strong>恼人</strong>的<strong>unused warnings</strong>，因此我们先<strong>整理</strong>一下<strong>代码</strong>。<br>首先打开<code>src/main.rs</code>：</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.1.1.png"
                        class="" title="4.1.1"
                 >
<p>注意到这里的<code>core::ptr</code>并没有被使用。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.1.2.png"
                        class="" title="4.1.2"
                 >
<p>因此我们将其<strong>移除</strong>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.1.3.png"
                        class="" title="4.1.3"
                 >
<p><code>not_main()</code>函数中<strong>移除不需要的代码</strong></p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.1.4.png"
                        class="" title="4.1.4"
                 >
<p>只保留一个<code>println!宏</code>以及<strong>中断初始化函数</strong><code>init_gicv2()</code>即可。<br><code>print_something()</code>函数我们亦不再用到，<strong>移除其相关代码</strong>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.1.5.png"
                        class="" title="4.1.5"
                 >
<p>现在看起来就<strong>清爽</strong>多了~<br>接下来在<code>src/interrupts.rs</code>中有很多<strong>没有用到的常量和函数</strong>，通常称为<code>dead_code</code>，但是为了<strong>保证完整性</strong>我们<strong>不选择删除它们</strong>，而是<strong>忽略</strong>掉。<br>在<code>src/main.rs</code>中加入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#![allow(dead_code)] // 忽略dead_code</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.2.1.png"
                        class="" title="4.2.1"
                 >
<p>最后一个<strong>warning</strong>在<code>aarch64-unknown-none-softfloat.json</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;abi-blacklist&quot;: [</span><br><span class="line">      &quot;stdcall&quot;,</span><br><span class="line">      &quot;fastcall&quot;,</span><br><span class="line">      &quot;vectorcall&quot;,</span><br><span class="line">      &quot;thiscall&quot;,</span><br><span class="line">      &quot;win64&quot;,</span><br><span class="line">      &quot;sysv64&quot;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
<p>这个<code>abi-blacklist</code>推测是<strong>屏蔽一些接口</strong>，我们<strong>并没有调用这些接口</strong>，所以<strong>直接移除</strong>。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.3.1.png"
                        class="" title="4.3.1"
                 >
<p>至此我们的<strong>warnings</strong>已经 <strong>全部处理(忽略)</strong> 完了。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/4.3.2.png"
                        class="" title="4.3.2"
                 >



<h2 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2. 实现"></a>2. 实现</h2><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceFourPlus.tar.gz" title="下载">下载</a></p>
</blockquote>
<p>在<strong>查阅大量的资料</strong>后，我找到了本次实验的<strong>原型(?)</strong><a class="link"   target="_blank" rel="noopener" href="https://github.com/lowenware/leos-kernel" >LeOS<i class="fas fa-external-link-alt"></i></a>以及其对应的<strong>时钟中断</strong>部分的<a class="link"   target="_blank" rel="noopener" href="https://lowenware.com/blog/osdev/aarch64-gic-and-timer-interrupt/" >博客<i class="fas fa-external-link-alt"></i></a>。仔细阅读可以发现他实现<strong>时钟中断</strong>的<a class="link"   target="_blank" rel="noopener" href="https://github.com/lowenware/leos-kernel/commit/7e89a52f91a98bdcbc1357091159e9391aff2d8d#diff-b02a7b840232145efa38636f47d5c4e8e2ea0cd3d98b449ffd3908e38d2dadc1L1" >Commit<i class="fas fa-external-link-alt"></i></a>。<br>在与<a class="link"   target="_blank" rel="noopener" href="https://noionion.top/" >noionion<i class="fas fa-external-link-alt"></i></a>的<strong>合作</strong>及其<strong>帮助</strong>下，我们发现了<strong>LeOS</strong>关于<strong>时钟中断</strong>的实现与<a class="link"   target="_blank" rel="noopener" href="https://os2022exps-doc.readthedocs.io/zh_CN/latest/exp4/index.html" >实验四 中断<i class="fas fa-external-link-alt"></i></a>中有一些<strong>不一样</strong>的地方：</p>
<p>在<strong>初始化中断</strong>时，<strong>LeOS</strong>还多了以下<strong>代码</strong>:</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/Loop.png"
                        class="" title="Loop"
                 >
<p>因此我们在<code>src/interrupts.rs</code>下的<code>init_gicv2()</code>函数<strong>尾部</strong>添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loop &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        asm!(&quot;mrs x0, CNTPCT_EL0&quot;); // 系统计数器</span><br><span class="line">        asm!(&quot;mrs x0, CNTP_CTL_EL0&quot;); // 控制计数器</span><br><span class="line">        asm!(&quot;mrs x0, CNTP_TVAL_EL0&quot;); // 定时计数器</span><br><span class="line">        asm!(&quot;mrs x0, CNTP_CVAL_EL0&quot;); // 比较计数器</span><br><span class="line">        asm!(&quot;wfi&quot;); // Wait for Interrupt 等待中断，下一次中断发生前都停止在此处</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的五句 <strong>asm!</strong> 其实<strong>前四句</strong>是<strong>无效操作</strong>，可以<strong>仅执行最后一句</strong>。<br>另外更严谨地说，该 <strong>loop {}</strong> 亦可放在 <strong>not_main()</strong> 函数中，调用 <strong>init_gicv2()</strong> 初始化后。</p>
</blockquote>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%BC%80%E5%90%AF%E4%B8%AD%E6%96%AD%E5%9B%9E%E8%B0%83.png"
                        class="" title="开启中断回调"
                 >
<p><strong>编译</strong>并<strong>运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A7%A6%E5%8F%91.png"
                        class="" title="第一次触发"
                 >
<p>在<strong>运行</strong>后，首先会<strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0] Hello from Rust!</span><br></pre></td></tr></table></figure>
<p>大约<strong>1s</strong>后会<strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EL1_IRQ @ 0x</span><br></pre></td></tr></table></figure>
<p>说明这次我们<strong>成功</strong>调用了<code>el1_irq()</code><strong>回调函数</strong>！<br>但<strong>问题</strong>是，<strong>时钟中断</strong>的<strong>理想状态</strong>应是每隔<strong>1s</strong>就会调用一次<code>el1_irq()</code><strong>回调函数</strong>，这里调用一次后却<strong>不再变化</strong>了。<br>这里其实是因为<code>catch()</code>函数在调用第一个参数<code>ctx</code>时会<strong>发生阻塞</strong>，<del><strong>具体原因不详</strong>。</del></p>
<blockquote>
<p>若想<strong>修复</strong>这个<strong>问题</strong>，可以编辑<code>.cargo/config.toml</code>，<strong>清空</strong>然后改为<strong>以下内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[unstable]</span><br><span class="line">build-std = [&quot;core&quot;, &quot;compiler_builtins&quot;] </span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = &quot;aarch64-unknown-none-softfloat&quot;</span><br><span class="line">rustflags = [&quot;-C&quot;,&quot;link-arg=-Taarch64-qemu.ld&quot;, &quot;-C&quot;, &quot;target-cpu=cortex-a53&quot;, &quot;-D&quot;, &quot;warnings&quot;]</span><br></pre></td></tr></table></figure>

</blockquote>
<p>因此我们<strong>修改该函数</strong>，编辑<code>interrupts.rs</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">// 调用我们的print!宏打印异常信息，你也可以选择打印异常发生时所有寄存器的信息</span><br><span class="line">fn catch(ctx: &amp;mut ExceptionCtx, name: &amp;str) &#123;</span><br><span class="line">    crate::print!(&quot;&#123;&#125;\n&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9catch.png"
                        class="" title="修改catch"
                 >
<p>然后<strong>编译运行</strong></p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%B8%8D%E5%81%9C%E8%BE%93%E5%87%BA.png"
                        class="" title="不停输出"
                 >
<p>可以发现现在确实能够<strong>一直触发中断</strong>并且<strong>输出回调函数名</strong>了。但这每次<strong>输出间隔</strong>的<strong>时间太短</strong>了吧！<br>这里我们需要了解一些<strong>概念</strong>：</p>
<ul>
<li>在<strong>ARM体系结构</strong>中，<strong>处理器内部</strong>有<strong>通用计时器</strong>，<strong>通用计时器</strong>包含一组<strong>比较器</strong>，用来与<strong>系统计数器(CNTPCT_EL0)<strong>进行比较，一旦</strong>通用计时器</strong>的值<strong>小于等于系统计数器</strong>时便会产生<strong>时钟中断</strong>。</li>
<li><strong>比较寄存器(CNTP_CVAL_EL0)</strong> 有64位，如果<strong>设置</strong>了之后，当<strong>系统计数器达到或超过</strong>了这个<strong>值</strong>之后，就会<strong>触发定时器中断</strong>。</li>
<li><strong>定时寄存器(CNTP_TVAL_EL0)</strong> 有32位，如果<strong>设置</strong>了之后，会将<strong>比较寄存器</strong>设置成当前<strong>系统计数器</strong>加上设置的<strong>定时寄存器</strong>的值。<blockquote>
<blockquote>
<p>详见<a class="link"   target="_blank" rel="noopener" href="https://github.com/2X-ercha/blogOS-armV8/blob/44d7bf5b7296be0e01398459456b265fa68e4e6d/src/main.rs#L64" >此处<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</blockquote>
</li>
</ul>
<p>因此我们若想要有<strong>延时效果</strong>，需要在调用<code>el1_irq()</code><strong>回调函数</strong>时<strong>再次写入定时寄存器</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asm!(&quot;mrs x1, CNTFRQ_EL0&quot;);</span><br><span class="line">asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%86%99%E5%85%A5%E5%AE%9A%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8.png"
                        class="" title="写入定时寄存器"
                 >
<p>此时再<strong>编译运行</strong>，我们就已经<strong>成功</strong>做到<strong>每1s</strong>处理一次<strong>时钟中断</strong>了！</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%AF%8F%E4%B8%80%E7%A7%92%E8%A7%A6%E5%8F%91%E4%B8%80%E6%AC%A1.png"
                        class="" title="每一秒触发一次"
                 >

<h1 id="五、输入"><a href="#五、输入" class="headerlink" title="五、输入"></a>五、输入</h1><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceFive.tar.gz" title="下载">下载</a></p>
<p><strong>QEMU</strong>的<strong>virt机器</strong>默认没有<strong>键盘</strong>作为<strong>输入设备</strong>，但当我们执行<strong>QEMU</strong>使用<code>-nographic</code>参数（Disable graphical output and redirect serial I/Os to console）时<strong>QEMU</strong>会将<strong>串口重定向</strong>到<strong>控制台</strong>，因此我们可以使用<strong>UART</strong>作为<strong>输入设备</strong>。</p>
</blockquote>
<h2 id="1-安装tock-registers库"><a href="#1-安装tock-registers库" class="headerlink" title="1. 安装tock-registers库"></a>1. 安装tock-registers库</h2><blockquote>
<p>在<strong>实验四</strong>中，针对<strong>GICD</strong>，<strong>GICC</strong>，<strong>TIMER</strong>等<strong>硬件</strong>我们定义了<strong>大量</strong>的<strong>常量</strong>和<strong>寄存器值</strong>，这在使用时过于<strong>繁琐</strong>也<strong>容易出错</strong>。因此我们决定采用<strong>tock-registers</strong>库。</p>
</blockquote>
<p>在<code>Cargo.toml</code>中的<code>[dependencies]</code>处中加入<strong>依赖</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tock-registers = &quot;0.7.0&quot;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%B7%BB%E5%8A%A0tr%E4%BE%9D%E8%B5%96.png"
                        class="" title="添加tr依赖"
                 >

<h2 id="2-重构"><a href="#2-重构" class="headerlink" title="2. 重构"></a>2. 重构</h2><blockquote>
<p>为了不至于使<code>src/uart_console.rs</code>文件过长，我们选择<strong>重构</strong><code>uart_console.rs</code>。</p>
</blockquote>
<p>首先进入项目<strong>根目录</strong>，创建<code>src/uart_console</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir src/uart_console</span><br></pre></td></tr></table></figure>
<p>将原<code>uart_console.rs</code><strong>更名</strong>为<code>mod.rs</code>，且置于<code>src/uart_console</code>目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv src/uart_console.rs src/uart_console/mod.rs</span><br></pre></td></tr></table></figure>
<p>最后<strong>新建</strong><code>src/uart_console/pl011.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/uart_console/pl011.rs</span><br></pre></td></tr></table></figure>
<p>依据<strong>tock_registers</strong>库的要求对<code>pl011</code>所涉及到的<strong>寄存器</strong>进行描述。<br>编辑<code>src/uart_console/pl011.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line">pub const PL011REGS: *mut PL011Regs = (0x0900_0000) as *mut PL011Regs;</span><br><span class="line"></span><br><span class="line">register_bitfields![</span><br><span class="line">    u32,</span><br><span class="line"></span><br><span class="line">    pub UARTDR [</span><br><span class="line">        DATA OFFSET(0) NUMBITS(8) []</span><br><span class="line">    ],</span><br><span class="line">    /// Flag Register</span><br><span class="line">    pub UARTFR [</span><br><span class="line">        /// Transmit FIFO full. The meaning of this bit depends on the</span><br><span class="line">        /// state of the FEN bit in the UARTLCR_ LCRH Register. If the</span><br><span class="line">        /// FIFO is disabled, this bit is set when the transmit</span><br><span class="line">        /// holding register is full. If the FIFO is enabled, the TXFF</span><br><span class="line">        /// bit is set when the transmit FIFO is full.</span><br><span class="line">        TXFF OFFSET(6) NUMBITS(1) [],</span><br><span class="line"></span><br><span class="line">        /// Receive FIFO empty. The meaning of this bit depends on the</span><br><span class="line">        /// state of the FEN bit in the UARTLCR_H Register. If the</span><br><span class="line">        /// FIFO is disabled, this bit is set when the receive holding</span><br><span class="line">        /// register is empty. If the FIFO is enabled, the RXFE bit is</span><br><span class="line">        /// set when the receive FIFO is empty.</span><br><span class="line">        RXFE OFFSET(4) NUMBITS(1) []</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    /// Integer Baud rate divisor</span><br><span class="line">    pub UARTIBRD [</span><br><span class="line">        /// Integer Baud rate divisor</span><br><span class="line">        IBRD OFFSET(0) NUMBITS(16) []</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    /// Fractional Baud rate divisor</span><br><span class="line">    pub UARTFBRD [</span><br><span class="line">        /// Fractional Baud rate divisor</span><br><span class="line">        FBRD OFFSET(0) NUMBITS(6) []</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    /// Line Control register</span><br><span class="line">    pub UARTLCR_H [</span><br><span class="line">        /// Parity enable. If this bit is set to 1, parity checking and generation</span><br><span class="line">        /// is enabled, else parity is disabled and no parity bit added to the data frame.</span><br><span class="line">        PEN OFFSET(1) NUMBITS(1) [</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ],</span><br><span class="line">        /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted</span><br><span class="line">        /// at the end of the frame.</span><br><span class="line">        STP2 OFFSET(3) NUMBITS(1) [</span><br><span class="line">            Stop1 = 0,</span><br><span class="line">            Stop2 = 1</span><br><span class="line">        ],</span><br><span class="line">        /// Enable FIFOs.</span><br><span class="line">        FEN OFFSET(4) NUMBITS(1) [</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        /// Word length. These bits indicate the number of data bits</span><br><span class="line">        /// transmitted or received in a frame.</span><br><span class="line">        WLEN OFFSET(5) NUMBITS(2) [</span><br><span class="line">            FiveBit = 0b00,</span><br><span class="line">            SixBit = 0b01,</span><br><span class="line">            SevenBit = 0b10,</span><br><span class="line">            EightBit = 0b11</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    /// Control Register</span><br><span class="line">    pub UARTCR [</span><br><span class="line">        /// Receive enable. If this bit is set to 1, the receive</span><br><span class="line">        /// section of the UART is enabled. Data reception occurs for</span><br><span class="line">        /// UART signals. When the UART is disabled in the middle of</span><br><span class="line">        /// reception, it completes the current character before</span><br><span class="line">        /// stopping.</span><br><span class="line">        RXE    OFFSET(9) NUMBITS(1) [</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        /// Transmit enable. If this bit is set to 1, the transmit</span><br><span class="line">        /// section of the UART is enabled. Data transmission occurs</span><br><span class="line">        /// for UART signals. When the UART is disabled in the middle</span><br><span class="line">        /// of transmission, it completes the current character before</span><br><span class="line">        /// stopping.</span><br><span class="line">        TXE    OFFSET(8) NUMBITS(1) [</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        /// UART enable</span><br><span class="line">        UARTEN OFFSET(0) NUMBITS(1) [</span><br><span class="line">            /// If the UART is disabled in the middle of transmission</span><br><span class="line">            /// or reception, it completes the current character</span><br><span class="line">            /// before stopping.</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    pub UARTIMSC [</span><br><span class="line">        RXIM OFFSET(4) NUMBITS(1) [</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    /// Interupt Clear Register</span><br><span class="line">    pub UARTICR [</span><br><span class="line">        /// Meta field for all pending interrupts</span><br><span class="line">        ALL OFFSET(0) NUMBITS(11) [</span><br><span class="line">            Clear = 0x7ff</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">register_structs! &#123;</span><br><span class="line">    pub PL011Regs &#123;</span><br><span class="line">        (0x00 =&gt; pub dr: ReadWrite&lt;u32, UARTDR::Register&gt;),                   // 0x00</span><br><span class="line">        (0x04 =&gt; __reserved_0),               // 0x04</span><br><span class="line">        (0x18 =&gt; pub fr: ReadOnly&lt;u32, UARTFR::Register&gt;),      // 0x18</span><br><span class="line">        (0x1c =&gt; __reserved_1),               // 0x1c</span><br><span class="line">        (0x24 =&gt; pub ibrd: WriteOnly&lt;u32, UARTIBRD::Register&gt;), // 0x24</span><br><span class="line">        (0x28 =&gt; pub fbrd: WriteOnly&lt;u32, UARTFBRD::Register&gt;), // 0x28</span><br><span class="line">        (0x2C =&gt; pub lcr_h: WriteOnly&lt;u32, UARTLCR_H::Register&gt;), // 0x2C</span><br><span class="line">        (0x30 =&gt; pub cr: WriteOnly&lt;u32, UARTCR::Register&gt;),     // 0x30</span><br><span class="line">        (0x34 =&gt; __reserved_2),               // 0x34</span><br><span class="line">        (0x38 =&gt; pub imsc: ReadWrite&lt;u32, UARTIMSC::Register&gt;), // 0x38</span><br><span class="line">        (0x44 =&gt; pub icr: WriteOnly&lt;u32, UARTICR::Register&gt;),   // 0x44</span><br><span class="line">        (0x48 =&gt; @END),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>register_bitfields!宏</strong>按照<strong>寄存器</strong>的<strong>位结构</strong>进行<strong>描述</strong>，注意最后要加<strong>分号”;”<strong>，只要</strong>注册</strong>自己想<strong>处理</strong>的<strong>位</strong>即可。</p>
<p><strong>register_structs!宏</strong>最后需加上 <strong>(0x** =&gt; @END)</strong> ，表示结束。</p>
</blockquote>
<h2 id="3-数据接收中断"><a href="#3-数据接收中断" class="headerlink" title="3. 数据接收中断"></a>3. 数据接收中断</h2><p>编辑<code>src/uart_console/mod.rs</code>，修改<strong>Writer</strong>的<strong>初始化方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">use core::&#123;fmt, ptr&#125;;</span><br><span class="line"></span><br><span class="line">use lazy_static::lazy_static;</span><br><span class="line">use spin::Mutex;</span><br><span class="line"></span><br><span class="line">use tock_registers::interfaces::Writeable;</span><br><span class="line"></span><br><span class="line">pub mod pl011;</span><br><span class="line">use pl011::*;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    /// A global `Writer` instance that can be used for printing to the VGA text buffer.</span><br><span class="line">    ///</span><br><span class="line">    /// Used by the `print!` and `println!` macros.</span><br><span class="line">    pub static ref WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer::new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Like the `print!` macro in the standard library, but prints to the VGA text buffer.</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9%E5%88%9D%E5%A7%8B%E5%8C%96.png"
                        class="" title="修改初始化"
                 >

<p>编辑<code>src/uart_console/mod.rs</code>，为<strong>Writer</strong>结构实现<strong>构造函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构</span><br><span class="line">pub struct Writer;</span><br><span class="line"></span><br><span class="line">//往串口寄存器写入字节和字符串进行输出</span><br><span class="line">impl Writer &#123;</span><br><span class="line">    pub fn write_byte(&amp;mut self, byte: u8) &#123;</span><br><span class="line">        // ······</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn write_string(&amp;mut self, s: &amp;str) &#123;</span><br><span class="line">        // ······</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn new() -&gt; Writer&#123;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            // pl011 device registers</span><br><span class="line">            let pl011r: &amp;PL011Regs = &amp;*PL011REGS;</span><br><span class="line">    </span><br><span class="line">            // 禁用pl011</span><br><span class="line">            pl011r.cr.write(UARTCR::TXE::Disabled + UARTCR::RXE::Disabled + UARTCR::UARTEN::Disabled);</span><br><span class="line">            // 清空中断状态</span><br><span class="line">            pl011r.icr.write(UARTICR::ALL::Clear);</span><br><span class="line">            // 设定中断mask，需要使能的中断</span><br><span class="line">            pl011r.imsc.write(UARTIMSC::RXIM::Enabled);</span><br><span class="line">            // IBRD = UART_CLK / (16 * BAUD_RATE)</span><br><span class="line">            // FBRD = ROUND((64 * MOD(UART_CLK,(16 * BAUD_RATE))) / (16 * BAUD_RATE))</span><br><span class="line">            // UART_CLK = 24M</span><br><span class="line">            // BAUD_RATE = 115200</span><br><span class="line">            pl011r.ibrd.write(UARTIBRD::IBRD.val(13));</span><br><span class="line">            pl011r.fbrd.write(UARTFBRD::FBRD.val(1));</span><br><span class="line">            // 8N1 FIFO enable</span><br><span class="line">            pl011r.lcr_h.write(UARTLCR_H::WLEN::EightBit + UARTLCR_H::PEN::Disabled + UARTLCR_H::STP2::Stop1</span><br><span class="line">                + UARTLCR_H::FEN::Enabled);</span><br><span class="line">            // enable pl011</span><br><span class="line">            pl011r.cr.write(UARTCR::UARTEN::Enabled + UARTCR::RXE::Enabled + UARTCR::TXE::Enabled);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Writer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl core::fmt::Write for Writer &#123;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png"
                        class="" title="构造函数"
                 >

<p>继续编辑<code>src/uart_console/mod.rs</code>，修改<code>write_byte()</code>函数，使用我们通过<strong>宏</strong>描述的<strong>寄存器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//嵌入式系统使用串口，而不是vga，直接输出，没有颜色控制，不记录列号，也没有frame buffer，所以采用空结构</span><br><span class="line">pub struct Writer;</span><br><span class="line"></span><br><span class="line">//往串口寄存器写入字节和字符串进行输出</span><br><span class="line">impl Writer &#123;</span><br><span class="line">    pub fn write_byte(&amp;mut self, byte: u8) &#123;</span><br><span class="line">        // const UART0: *mut u8 = 0x0900_0000 as *mut u8;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            // pl011 device registers</span><br><span class="line">            let pl011r: &amp;PL011Regs = &amp;*PL011REGS;</span><br><span class="line">    </span><br><span class="line">            // ptr::write_volatile(UART0, byte);</span><br><span class="line">            pl011r.dr.write(UARTDR::DATA.val(byte as u32));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn write_string(&amp;mut self, s: &amp;str) &#123;</span><br><span class="line">    // ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9wb%E5%87%BD%E6%95%B0.png"
                        class="" title="修改wb函数"
                 >

<p>编辑<code>src/interrupts.rs</code>，修改<code>init_gicv2()</code>函数，对<strong>UART</strong>的<strong>数据接收中断</strong>进行<strong>初始化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">    //配置timer</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        // ······</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化UART0 中断</span><br><span class="line">    // interrupts = &lt;0x00 0x01 0x04&gt;; SPI, 0x01, level</span><br><span class="line">    set_config(UART0_IRQ, ICFGR_LEVEL); //电平触发</span><br><span class="line">    set_priority(UART0_IRQ, 0); //优先级设定</span><br><span class="line">    // set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核</span><br><span class="line">    clear(UART0_IRQ); //清除中断请求</span><br><span class="line">    enable(UART0_IRQ); //使能中断</span><br><span class="line"></span><br><span class="line">    loop &#123;</span><br><span class="line">        // ······</span><br><span class="line">    &#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E5%A4%87%E4%B8%AD%E6%96%AD.png"
                        class="" title="初始化设备中断"
                 >
<p>编辑<code>src/interrupts.rs</code>，接下来我们定义<code>UART0_IRQ</code><strong>全局常量</strong>，同时把<code>TIMER_IRQ</code>也修改为<strong>全局常量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 时钟中断号</span><br><span class="line">const TIMER_IRQ: u32 = 30;</span><br><span class="line">// 设备中断号</span><br><span class="line">const UART0_IRQ: u32 = 33;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F.png"
                        class="" title="全局常量"
                 >

<p>继续编辑<code>src/interrupts.rs</code>，对<strong>UART</strong>的<strong>数据接收中断</strong>进行<strong>处理</strong>，并修改<strong>timer中断</strong>的<strong>处理方法</strong>，使之<strong>每隔2秒输出一个点</strong>。<br>在<strong>文末</strong>添加以下<strong>三个函数</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::interfaces::Readable;</span><br><span class="line">fn handle_irq_lines(ctx: &amp;mut ExceptionCtx, _core_num: u32, irq_num: u32) &#123;</span><br><span class="line">    if irq_num == TIMER_IRQ &#123;</span><br><span class="line">        handle_timer_irq(ctx);</span><br><span class="line">    &#125;else if irq_num == UART0_IRQ &#123;</span><br><span class="line">        handle_uart0_rx_irq(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        catch(ctx, EL1_IRQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn handle_timer_irq(_ctx: &amp;mut ExceptionCtx)&#123;</span><br><span class="line"></span><br><span class="line">    crate::print!(&quot;.&quot;);</span><br><span class="line"></span><br><span class="line">    // 每2秒产生一次中断</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        asm!(&quot;mrs x1, CNTFRQ_EL0&quot;);</span><br><span class="line">        asm!(&quot;add x1, x1, x1&quot;);</span><br><span class="line">        asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn handle_uart0_rx_irq(_ctx: &amp;mut ExceptionCtx)&#123;</span><br><span class="line">    use crate::uart_console::pl011::*;</span><br><span class="line"></span><br><span class="line">    crate::print!(&quot;\nInput interrupt: &quot;);</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        // pl011 device registers</span><br><span class="line">        let pl011r: &amp;PL011Regs = &amp;*PL011REGS;</span><br><span class="line"></span><br><span class="line">        let mut flag = pl011r.fr.read(UARTFR::RXFE);</span><br><span class="line">        while flag != 1 &#123;</span><br><span class="line">            let value = pl011r.dr.read(UARTDR::DATA);</span><br><span class="line"></span><br><span class="line">            crate::print!(&quot;&#123;&#125;&quot;, value as u8 as char);</span><br><span class="line">            flag = pl011r.fr.read(UARTFR::RXFE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续编辑<code>src/interrupts.rs</code>，修改<code>el1_irq()</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#[no_mangle]</span><br><span class="line">unsafe extern &quot;C&quot; fn el1_irq(ctx: &amp;mut ExceptionCtx) &#123;</span><br><span class="line">    // reads this register to obtain the interrupt ID of the signaled interrupt.</span><br><span class="line">    // This read acts as an acknowledge for the interrupt.</span><br><span class="line">    // 中断确认</span><br><span class="line">    const GICC_IAR: *mut u32 = (GICC_BASE + 0x0c) as *mut u32;</span><br><span class="line">    const GICC_EOIR: *mut u32 = (GICC_BASE + 0x10) as *mut u32;</span><br><span class="line">    let value: u32 = ptr::read_volatile(GICC_IAR);</span><br><span class="line">    let irq_num: u32 = value &amp; 0x1ff;</span><br><span class="line">    let core_num: u32 = value &amp; 0xe00;</span><br><span class="line"></span><br><span class="line">    // 实际处理中断</span><br><span class="line">    handle_irq_lines(ctx, core_num, irq_num);</span><br><span class="line">    // catch(ctx, EL1_IRQ);</span><br><span class="line"></span><br><span class="line">    // A processor writes to this register to inform the CPU interface either:</span><br><span class="line">    // • that it has completed the processing of the specified interrupt</span><br><span class="line">    // • in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set to 1, to indicate that the interface should perform priority drop for the specified interrupt.</span><br><span class="line">    // 标记中断完成，清除相应中断位</span><br><span class="line">    ptr::write_volatile(GICC_EOIR, core_num | irq_num);</span><br><span class="line">    clear(irq_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9irq%E5%87%BD%E6%95%B0.png"
                        class="" title="修改irq函数"
                 >

<p>之前我们修改了<code>catch()</code>函数，没有调用<code>ctx</code>参数，所以会有一个<strong>warning</strong>，这里我们选择再次将其<strong>忽略</strong><br>编辑<code>src/main.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#![allow(dead_code, unused_variables)] // 忽略dead_code</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F.png"
                        class="" title="忽略未使用变量"
                 >

<p>并且在<code>src/uart_console/mod.rs</code>中，有一个未使用的<code>core::ptr</code>引用，将其移除</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%A7%BB%E9%99%A4ptr.png"
                        class="" title="移除ptr"
                 >

<p>接下来<strong>编译</strong>并<strong>运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%AF%8F%E4%B8%A4%E7%A7%92%E8%BE%93%E5%87%BA%E4%B8%80%E6%AC%A1.png"
                        class="" title="每两秒输出一次"
                 >
<p>可以看到每过<strong>2s</strong>就会<strong>打一个点</strong>。<br>如果我们按<strong>顺序</strong>输入<strong>a</strong>、<strong>b</strong>、<strong>c</strong>，则会<strong>触发输入中断</strong></p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%AD.png"
                        class="" title="输入中断"
                 >

<h1 id="六、GPIO关机"><a href="#六、GPIO关机" class="headerlink" title="六、GPIO关机"></a>六、GPIO关机</h1><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceSix.tar.gz" title="下载">下载</a></p>
</blockquote>
<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><p>查看<code>virt.dts</code>，可以<strong>发现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">	#address-cells = &lt;0x01&gt;;</span><br><span class="line">	#size-cells = &lt;0x00&gt;;</span><br><span class="line">	compatible = &quot;gpio-keys&quot;;</span><br><span class="line"></span><br><span class="line">	poweroff &#123;</span><br><span class="line">		gpios = &lt;0x8003 0x03 0x00&gt;;</span><br><span class="line">		linux,code = &lt;0x74&gt;;</span><br><span class="line">		label = &quot;GPIO Key Poweroff&quot;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pl061@9030000 &#123;</span><br><span class="line">	phandle = &lt;0x8003&gt;;</span><br><span class="line">	clock-names = &quot;apb_pclk&quot;;</span><br><span class="line">	clocks = &lt;0x8000&gt;;</span><br><span class="line">	interrupts = &lt;0x00 0x07 0x04&gt;;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	#gpio-cells = &lt;0x02&gt;;</span><br><span class="line">	compatible = &quot;arm,pl061\0arm,primecell&quot;;</span><br><span class="line">	reg = &lt;0x00 0x9030000 0x00 0x1000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中<strong>gpio-keys</strong>中定义了一个<strong>poweroff</strong>键， <strong>gpios = &lt;0x8003 0x03 0x00&gt;</strong> 中的第一项<strong>0x8003</strong>表示它的<strong>phandle</strong>是<strong>0x8003</strong>， 即<strong>pl061@9030000</strong>，也即<strong>gpio-keys</strong>是设备<strong>pl061</strong>的组成部分，第二项<strong>0x03</strong>表示该键是<strong>pl061</strong>的<strong>第三根GPIO线</strong>，第三项是<strong>flag</strong>，且<strong>pl061</strong>的寄存器映射到了内存<strong>0x9030000</strong>开始的位置。如下图所示。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/gpio-poweroff.png"
                        class="" title="gpio-poweroff"
                 >
</blockquote>
<h2 id="2-实现-2"><a href="#2-实现-2" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>新建<code>src/pl061.rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/pl061.rs</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/pl061.rs</code>，通过<strong>tock-registers</strong>描述<strong>寄存器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line">pub const PL061REGS: *mut PL061Regs = (0x0903_0000) as *mut PL061Regs;</span><br><span class="line"></span><br><span class="line">register_bitfields![</span><br><span class="line">    u32,</span><br><span class="line">    pub GPIOIE [</span><br><span class="line">        IO3 OFFSET(3) NUMBITS(1) [</span><br><span class="line">            Disabled = 0,</span><br><span class="line">            Enabled = 1</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">register_structs! &#123;</span><br><span class="line">    pub PL061Regs &#123;</span><br><span class="line">        (0x000 =&gt; __reserved_0),                                               // 0x000</span><br><span class="line">        (0x410 =&gt; pub ie: ReadWrite&lt;u32, GPIOIE::Register&gt;),                   // 0x410</span><br><span class="line">        (0x414 =&gt; __reserved_1),                                               // 0x414</span><br><span class="line">        (0x41C =&gt; pub ic: WriteOnly&lt;u32&gt;),                                     // 0x41C</span><br><span class="line">        (0x420 =&gt; @END),                                                       // 0x420</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑<code>src/main.rs</code>，引入<strong>pl061</strong>模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">use core::arch::global_asm; // 导入需要的Module</span><br><span class="line"></span><br><span class="line">mod panic;</span><br><span class="line">mod uart_console;</span><br><span class="line">mod interrupts;</span><br><span class="line">mod pl061;</span><br><span class="line"></span><br><span class="line">global_asm!(include_str!(&quot;start.s&quot;));</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/mod_pl061.png"
                        class="" title="mod_pl061"
                 >
<p>编辑<code>src/interrupts.rs</code>，在<code>init_gicv2</code>函数中<strong>初始化pl061的GPIO中断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">// 时钟中断号</span><br><span class="line">const TIMER_IRQ: u32 = 30;</span><br><span class="line">// 设备中断号</span><br><span class="line">const UART0_IRQ: u32 = 33;</span><br><span class="line"></span><br><span class="line">const GPIO_IRQ: u32 = 39; // virt.dts interrupts = &lt;0x00 0x07 0x04&gt;; 32 + 0x07 = 39</span><br><span class="line"></span><br><span class="line">pub fn init_gicv2() &#123;</span><br><span class="line">    // 初始化Gicv2的distributor和cpu interface</span><br><span class="line">    // 禁用distributor和cpu interface后进行相应配置</span><br><span class="line">    // ······</span><br><span class="line"></span><br><span class="line">    // 初始化GPIO中断</span><br><span class="line">    set_config(GPIO_IRQ, ICFGR_LEVEL); //电平触发</span><br><span class="line">    set_priority(GPIO_IRQ, 0); //优先级设定</span><br><span class="line">    // set_core(TIMER_IRQ, 0x1); // 单核实现无需设置中断目标核</span><br><span class="line">    clear(GPIO_IRQ); //清除中断请求</span><br><span class="line">    enable(GPIO_IRQ); //使能中断</span><br><span class="line"></span><br><span class="line">    // 使能GPIO的poweroff key中断</span><br><span class="line">    use crate::pl061::*;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        let pl061r: &amp;PL061Regs = &amp;*PL061REGS;</span><br><span class="line"></span><br><span class="line">        // 启用pl061 gpio中的3号线中断</span><br><span class="line">        pl061r.ie.write(GPIOIE::IO3::Enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop &#123;</span><br><span class="line">        // ······</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B3%E6%9C%BA%E4%B8%AD%E6%96%AD.png"
                        class="" title="初始化关机中断"
                 >
<p>编辑<code>src/interrupts.rs</code>，引入<code>tock_registers::interfaces::Writeable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">use tock_registers::interfaces::Readable;</span><br><span class="line">use tock_registers::interfaces::Writeable;</span><br><span class="line">fn handle_irq_lines(ctx: &amp;mut ExceptionCtx, _core_num: u32, irq_num: u32) &#123;</span><br><span class="line">    // ······</span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%BC%95%E5%85%A5Writeable.png"
                        class="" title="引入Writeable"
                 >
<p>编辑<code>src/interrupts.rs</code>，处理<code>pl061</code><strong>3号GPIO线</strong>引发的<strong>中断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">fn handle_irq_lines(ctx: &amp;mut ExceptionCtx, _core_num: u32, irq_num: u32) &#123;</span><br><span class="line">    if irq_num == TIMER_IRQ &#123;</span><br><span class="line">        handle_timer_irq(ctx);</span><br><span class="line">    &#125;else if irq_num == UART0_IRQ &#123;</span><br><span class="line">        handle_uart0_rx_irq(ctx);</span><br><span class="line">    &#125;else if irq_num == GPIO_IRQ &#123;</span><br><span class="line">        handle_gpio_irq(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        catch(ctx, EL1_IRQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn handle_timer_irq(_ctx: &amp;mut ExceptionCtx)&#123;</span><br><span class="line">    // ······</span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br><span class="line">fn handle_gpio_irq(_ctx: &amp;mut ExceptionCtx)&#123;</span><br><span class="line">    use crate::pl061::*;</span><br><span class="line">    crate::println!(&quot;Power off!\n&quot;);</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        let pl061r: &amp;PL061Regs = &amp;*PL061REGS;</span><br><span class="line"></span><br><span class="line">        // 清除中断信号</span><br><span class="line">        pl061r.ic.set(pl061r.ie.get());</span><br><span class="line">        // 关机</span><br><span class="line">        asm!(&quot;mov w0, #0x18&quot;);</span><br><span class="line">        asm!(&quot;hlt #0xF000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%85%B3%E6%9C%BA%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%861.png"
                        class="" title="关机中断处理1"
                 >
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%85%B3%E6%9C%BA%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%862.png"
                        class="" title="关机中断处理2"
                 >
<blockquote>
<p>在 <strong>handle_gpio_irq()</strong> 函数里通过<strong>内联汇编</strong>执行了指令<strong>hlt #0xF000</strong>，这里用到了<strong>ARM</strong>的<strong>Semihosting</strong>功能。</p>
<ul>
<li><strong>Semihosting</strong>的作用：能够让<strong>bare-metal</strong>的<strong>ARM</strong>设备通过<strong>拦截指定的SVC指令</strong>，在连<strong>操作系统</strong>都没有的环境中实现<strong>POSIX</strong>中的许多<strong>标准函数</strong>，比如<strong>printf</strong>、<strong>scanf</strong>、<strong>open</strong>、<strong>read</strong>、<strong>write</strong>等等。这些<strong>IO</strong>操作将被<strong>Semihosting</strong>协议转发到<strong>Host主机</strong>上，然后由<strong>主机代为执行</strong>。</li>
</ul>
</blockquote>
<p>编辑<code>src/interrupts.rs</code>，停止打点，方便后续测试观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">fn handle_timer_irq(_ctx: &amp;mut ExceptionCtx)&#123;</span><br><span class="line"></span><br><span class="line">    // crate::print!(&quot;.&quot;);</span><br><span class="line"></span><br><span class="line">    // 每2秒产生一次中断</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        asm!(&quot;mrs x1, CNTFRQ_EL0&quot;);</span><br><span class="line">        asm!(&quot;add x1, x1, x1&quot;);</span><br><span class="line">        asm!(&quot;msr CNTP_TVAL_EL0, x1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%81%9C%E6%AD%A2%E6%89%93%E7%82%B9.png"
                        class="" title="停止打点"
                 >

<h2 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h2><blockquote>
<p>为了启用<strong>Semihosting</strong>功能，在<strong>QEMU</strong>执行时需要加入 <strong>-semihosting</strong> 参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>
<p>先按<code>Ctrl + A</code>，松手再按<code>C</code>，然后输入<code>system_powerdown</code>执行关机。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%89%A7%E8%A1%8C%E5%85%B3%E6%9C%BA.png"
                        class="" title="执行关机"
                 >

<h1 id="七、死锁与简单处理"><a href="#七、死锁与简单处理" class="headerlink" title="七、死锁与简单处理"></a>七、死锁与简单处理</h1><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceSeven.tar.gz" title="下载">下载</a></p>
<p>当<strong>多个任务</strong>访问<strong>同一个资源（数据）</strong>时就会引发<strong>竞争条件问题</strong>，这不仅在<strong>进程间</strong>会出现，在<strong>操作系统</strong>和<strong>进程间</strong>也会出现。由<strong>竞争条件</strong>引发的问题很难<strong>复现</strong>和<strong>调试</strong>，这也是其<strong>最困难</strong>的地方。本<strong>实验</strong>的目的在于<strong>了解竞争条件</strong>和<strong>死锁现象</strong>，并<strong>掌握</strong>处理这些问题的<strong>初步方法</strong>等。</p>
</blockquote>
<h2 id="勘误"><a href="#勘误" class="headerlink" title="勘误"></a>勘误</h2><blockquote>
<p>在<strong>src/interrupts.rs</strong>的<strong>init_gicv2()<strong>函数中，我们之前使用了一个</strong>循环</strong>并使用<strong>内联汇编asm!(“wfi”)<strong>来</strong>等待中断</strong>，实际上在之前的实验中，这里所有的<strong>内联汇编</strong>都是没有必要的。当去掉这个<strong>循环</strong>，我们的<strong>OS</strong>会<strong>串行执行完成</strong>然后<strong>自动关机</strong>，从而导致后续的测试<strong>无效</strong>。因此我们<strong>需要且仅需要</strong>一个<strong>空循环</strong>来<strong>使OS持续运行</strong>，以便后续的<strong>中断测试</strong>。</p>
</blockquote>
<p>编辑<code>src/interrupts.rs</code>，在<code>init_gicv2()</code>函数中移除<code>loop&#123;&#125;</code>循环。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%8E%BB%E9%99%A4%E6%97%A0%E6%95%88%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.png"
                        class="" title="去除无效内联汇编"
                 >

<p>编辑<code>src/main.rs</code>，在<code>not_main()</code>函数尾部添加<code>loop&#123;&#125;</code>空循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">#[no_mangle] // 不修改函数名</span><br><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    println!(&quot;\n[0] Hello from Rust!\n&quot;);</span><br><span class="line">    interrupts::init_gicv2();</span><br><span class="line">    loop &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%B7%BB%E5%8A%A0%E7%A9%BA%E5%BE%AA%E7%8E%AF.png"
                        class="" title="添加空循环"
                 >

<h2 id="死锁的复现"><a href="#死锁的复现" class="headerlink" title="死锁的复现"></a>死锁的复现</h2><p>首先编辑<code>src/main.rs</code>，在<code>not_main()</code>函数的空循环中调用<code>print!</code>宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">global_asm!(include_str!(&quot;start.s&quot;));</span><br><span class="line"></span><br><span class="line">#[no_mangle] // 不修改函数名</span><br><span class="line">pub extern &quot;C&quot; fn not_main() &#123;</span><br><span class="line">    println!(&quot;\n[0] Hello from Rust!\n&quot;);</span><br><span class="line">    interrupts::init_gicv2();</span><br><span class="line">    loop &#123;</span><br><span class="line">        print!(&quot;-&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/loop1.png"
                        class="" title="loop1"
                 >

<p>这里有两种方式复现死锁现象。</p>
<h3 id="1-loop-中print-宏与handle-uart0-rx-irq-中print-宏竞争"><a href="#1-loop-中print-宏与handle-uart0-rx-irq-中print-宏竞争" class="headerlink" title="1. loop{}中print!宏与handle_uart0_rx_irq()中print!宏竞争"></a>1. loop{}中<code>print!</code>宏与<code>handle_uart0_rx_irq()</code>中<code>print!</code>宏竞争</h3><p>检查<code>src/interrupts.rs</code>中的<code>handle_uart0_rx_irq()</code>函数，可以看到我们之前写了一个输入中断回调函数，在函数中调用了<code>print!</code>宏输出信息。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0.png"
                        class="" title="输入中断函数"
                 >

<p>直接编译并运行，预期在输入时触发死锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>

<p>不停地乱序敲击键盘，此时有概率出现卡死，按键无法再次输入内容，即触发死锁现象。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%AD%BB%E9%94%81.png"
                        class="" title="死锁"
                 >

<h3 id="2-loop-中print-宏与handle-timer-irq-中print-宏竞争"><a href="#2-loop-中print-宏与handle-timer-irq-中print-宏竞争" class="headerlink" title="2. loop{}中print!宏与handle_timer_irq()中print!宏竞争"></a>2. loop{}中<code>print!</code>宏与<code>handle_timer_irq()</code>中<code>print!</code>宏竞争</h3><p>检查<code>src/interrupts.rs</code>中的<code>handle_timer_irq()</code>函数，可以看到我们之前写了一个时间中断回调函数，在函数中调用了<code>print!</code>宏打点。</p>
<p>但它之前被我们注释掉了，因此我们取消注释</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E9%87%8D%E6%96%B0%E6%89%93%E7%82%B9.png"
                        class="" title="重新打点"
                 >

<p>然后我们编译并运行，预期在打第一个点时会触发死锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>

<p>实验按预期触发了死锁。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%89%93%E7%82%B9%E6%AD%BB%E9%94%81.png"
                        class="" title="打点死锁"
                 >
<p>有时会在打第二个点时触发死锁。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%89%93%E7%82%B9%E6%AD%BB%E9%94%812.png"
                        class="" title="打点死锁2"
                 >

<h2 id="死锁的简单处理"><a href="#死锁的简单处理" class="headerlink" title="死锁的简单处理"></a>死锁的简单处理</h2><p>编辑<code>src/uart_console/mod.rs</code>，引入<code>asm!</code>宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">impl core::fmt::Write for Writer &#123;</span><br><span class="line">    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result &#123;</span><br><span class="line">        // ······</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use core::&#123;fmt, arch::asm&#125;;</span><br><span class="line"></span><br><span class="line">use lazy_static::lazy_static;</span><br><span class="line">use spin::Mutex;</span><br><span class="line"></span><br><span class="line">use tock_registers::interfaces::Writeable;</span><br><span class="line"></span><br><span class="line">pub mod pl011;</span><br><span class="line">use pl011::*;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E5%BC%95%E5%85%A5asm.png"
                        class="" title="引入asm"
                 >

<p>编辑<code>src/uart_console/mod.rs</code>中的<code>_print()</code>函数，在处理输入时先关闭中断，再打开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">/// Prints the given formatted string to the VGA text buffer through the global `WRITER` instance.</span><br><span class="line">#[doc(hidden)]</span><br><span class="line">pub fn _print(args: fmt::Arguments) &#123;</span><br><span class="line">    use core::fmt::Write;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        // 关闭d a i f类型的中断</span><br><span class="line">        asm!(&quot;msr daifset, #0xf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WRITER.lock().write_fmt(args).unwrap();</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">        // 仅打开i类型的中断，不支持嵌套，嵌套应该保存状态，然后再恢复之前的状态</span><br><span class="line">        asm!(&quot;msr daifclr, #2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E5%A4%8D%E6%AD%BB%E9%94%81.png"
                        class="" title="修复死锁"
                 >

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>此时再用上述两种方式测试死锁，发现死锁现象消失了~</p>
<h1 id="八、内存管理"><a href="#八、内存管理" class="headerlink" title="八、内存管理"></a>八、内存管理</h1><blockquote>
<p><strong>分页内存管理</strong>是<strong>内存管理</strong>的<strong>基本方法之一</strong>。本实验的目的在于<strong>全面理解分页式内存管理</strong>的<strong>基本方法</strong>以及<strong>访问页表</strong>，<strong>完成地址转换</strong>等的方法。</p>
</blockquote>
<h2 id="ARM-v8的地址转换"><a href="#ARM-v8的地址转换" class="headerlink" title="ARM v8的地址转换"></a>ARM v8的地址转换</h2><blockquote>
<p><strong><a class="link"   target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit/Context-switching" >ARM Cortex-A Series Programmer’s Guide for ARMv8-A<i class="fas fa-external-link-alt"></i></a></strong> 中提到：</p>
<p>For <strong>EL0</strong> and <strong>EL1</strong>, there are <strong>two translation tables</strong>. <strong>TTBR0_EL1</strong> provides translations for <strong>the bottom of Virtual Address space</strong>, which is <strong>typically application space</strong> and <strong>TTBR1_EL1</strong> covers <strong>the top of Virtual Address space</strong>, <strong>typically kernel space</strong>. This split means that the OS mappings do not have to be replicated in the translation tables of each task.</p>
<p>即<strong>TTBR0</strong>指向<strong>虚拟空间下半部分</strong>通常用于<strong>应用程序</strong>的空间，<strong>TTBR1</strong>指向<strong>虚拟空间上半部分</strong>通常用于<strong>内核</strong>的空间。其中<strong>TTBR0</strong>除了在<strong>EL1</strong>中存在外，也在<strong>EL2</strong>和<strong>EL3</strong>中存在，但<strong>TTBR1</strong>只在<strong>EL1</strong>中存在。</p>
<p><strong>TTBR0_ELn</strong>和<strong>TTBR1_ELn</strong>是页表<strong>基地址寄存器</strong>，<strong>地址转换</strong>的过程如下所示 </p>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/v2p-translate.svg"
                        class="" title="v2p-translate"
                 >
</blockquote>
<h2 id="一、使用Identity-Mapping映射"><a href="#一、使用Identity-Mapping映射" class="headerlink" title="一、使用Identity Mapping映射"></a>一、使用Identity Mapping映射</h2><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceEight1.tar.gz" title="下载">下载</a></p>
<p><strong>虚拟地址转换</strong>很<strong>容易出错</strong>也<strong>很难调试</strong>，所以我们从<strong>最简单的方式</strong>开始，即采用<strong>Identity Mapping</strong>，将<strong>虚拟地址</strong>映射到<strong>相同</strong>的<strong>物理地址</strong>。</p>
</blockquote>
<p>编辑<code>src/start.s</code>，初始化<strong>MMU</strong>、<strong>页表</strong>以及<strong>启用页表</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">.extern LD_STACK_PTR</span><br><span class="line">.section &quot;.text.boot&quot;</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">        ldr     x30, =LD_STACK_PTR</span><br><span class="line">        mov     sp, x30</span><br><span class="line"></span><br><span class="line">        // Initialize exceptions</span><br><span class="line">        ldr     x0, =exception_vector_table</span><br><span class="line">        msr     vbar_el1, x0</span><br><span class="line">        isb</span><br><span class="line"></span><br><span class="line">_setup_mmu:</span><br><span class="line">        // 初始化TCR控制寄存器</span><br><span class="line">        ldr     x0, =TCR_EL1_VALUE</span><br><span class="line">        msr     tcr_el1, x0</span><br><span class="line">        ldr     x0, =MAIR_EL1_VALUE</span><br><span class="line">        msr     mair_el1, x0            // 内存属性间接寄存器，作用是预先定义好属性，然后通过索引来访问这些预定义的属性</span><br><span class="line"></span><br><span class="line">_setup_pagetable:</span><br><span class="line">        // 因为采用的36位地址空间，所以是一级页表</span><br><span class="line">        ldr     x1, =LD_TTBR0_BASE</span><br><span class="line">        msr     ttbr0_el1, x1           //页表基地址TTBR0</span><br><span class="line">        ldr     x2, =LD_TTBR1_BASE</span><br><span class="line">        msr     ttbr1_el1, x2           //页表基地址TTBR1</span><br><span class="line"></span><br><span class="line">        // 一级页表部分</span><br><span class="line">        // 虚拟地址空间的下半部分采用Identity Mapping</span><br><span class="line">        // 第一项 虚拟地址0 - 1G，根据virt的定义为flash和外设，参见virt.c</span><br><span class="line">        ldr     x3, =0x0</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =PERIPHERALS_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line">        // 第二项 虚拟地址1G - 2G，_start部分</span><br><span class="line">        ldr     x3, =_start</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =IDENTITY_MAP_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line"></span><br><span class="line">_enable_mmu:</span><br><span class="line">        // 启用MMU.</span><br><span class="line">        mrs     x0, sctlr_el1</span><br><span class="line">        orr     x0, x0, #0x1</span><br><span class="line">        msr     sctlr_el1, x0</span><br><span class="line">        dsb     sy                      // Programmer’s Guide for ARMv8-A chapter13.2 Barriers</span><br><span class="line">        isb</span><br><span class="line"></span><br><span class="line">_start_main:</span><br><span class="line">        bl      not_main</span><br><span class="line"></span><br><span class="line">.equ PSCI_SYSTEM_OFF, 0x84000002</span><br><span class="line">.globl system_off</span><br><span class="line">system_off:</span><br><span class="line">        ldr     x0, =PSCI_SYSTEM_OFF</span><br><span class="line">        hvc     #0</span><br><span class="line"></span><br><span class="line">.equ TCR_EL1_VALUE, 0x1B55C351C</span><br><span class="line">// ---------------------------------------------</span><br><span class="line">// IPS   | b001    &lt;&lt; 32 | 36bits address space - 64GB</span><br><span class="line">// TG1   | b10     &lt;&lt; 30 | 4KB granule size for TTBR1_EL1</span><br><span class="line">// SH1   | b11     &lt;&lt; 28 | 页表所在memory: Inner shareable</span><br><span class="line">// ORGN1 | b01     &lt;&lt; 26 | 页表所在memory: Normal, Outer Wr.Back Rd.alloc Wr.alloc Cacheble</span><br><span class="line">// IRGN1 | b01     &lt;&lt; 24 | 页表所在memory: Normal, Inner Wr.Back Rd.alloc Wr.alloc Cacheble</span><br><span class="line">// EPD   | b0      &lt;&lt; 23 | Perform translation table walk using TTBR1_EL1</span><br><span class="line">// A1    | b1      &lt;&lt; 22 | TTBR1_EL1.ASID defined the ASID</span><br><span class="line">// T1SZ  | b011100 &lt;&lt; 16 | Memory region 2^(64-28) -&gt; 0xffffffexxxxxxxxx</span><br><span class="line">// TG0   | b00     &lt;&lt; 14 | 4KB granule size</span><br><span class="line">// SH0   | b11     &lt;&lt; 12 | 页表所在memory: Inner Sharebale</span><br><span class="line">// ORGN0 | b01     &lt;&lt; 10 | 页表所在memory: Normal, Outer Wr.Back Rd.alloc Wr.alloc Cacheble</span><br><span class="line">// IRGN0 | b01     &lt;&lt; 8  | 页表所在memory: Normal, Inner Wr.Back Rd.alloc Wr.alloc Cacheble</span><br><span class="line">// EPD0  | b0      &lt;&lt; 7  | Perform translation table walk using TTBR0_EL1</span><br><span class="line">// 0     | b0      &lt;&lt; 6  | Zero field (reserve)</span><br><span class="line">// T0SZ  | b011100 &lt;&lt; 0  | Memory region 2^(64-28)</span><br><span class="line"></span><br><span class="line">.equ MAIR_EL1_VALUE, 0xFF440C0400</span><br><span class="line">// ---------------------------------------------</span><br><span class="line">//                   INDX         MAIR</span><br><span class="line">// DEVICE_nGnRnE    b000(0)     b00000000</span><br><span class="line">// DEVICE_nGnRE         b001(1)         b00000100</span><br><span class="line">// DEVICE_GRE               b010(2)     b00001100</span><br><span class="line">// NORMAL_NC                b011(3)     b01000100</span><br><span class="line">// NORMAL               b100(4)         b11111111</span><br><span class="line"></span><br><span class="line">.equ PERIPHERALS_ATTR, 0x60000000000601</span><br><span class="line">// -------------------------------------</span><br><span class="line">// UXN   | b1      &lt;&lt; 54 | Unprivileged eXecute Never</span><br><span class="line">// PXN   | b1      &lt;&lt; 53 | Privileged eXecute Never</span><br><span class="line">// AF    | b1      &lt;&lt; 10 | Access Flag</span><br><span class="line">// SH    | b10     &lt;&lt; 8  | Outer shareable</span><br><span class="line">// AP    | b01     &lt;&lt; 6  | R/W, EL0 access denied</span><br><span class="line">// NS    | b0      &lt;&lt; 5  | Security bit (EL3 and Secure EL1 only)</span><br><span class="line">// INDX  | b000    &lt;&lt; 2  | Attribute index in MAIR_ELn，参见MAIR_EL1_VALUE</span><br><span class="line">// ENTRY | b01     &lt;&lt; 0  | Block entry</span><br><span class="line"></span><br><span class="line">.equ IDENTITY_MAP_ATTR, 0x40000000000711</span><br><span class="line">// ------------------------------------</span><br><span class="line">// UXN   | b1      &lt;&lt; 54 | Unprivileged eXecute Never</span><br><span class="line">// PXN   | b0      &lt;&lt; 53 | Privileged eXecute Never</span><br><span class="line">// AF    | b1      &lt;&lt; 10 | Access Flag</span><br><span class="line">// SH    | b11     &lt;&lt; 8  | Inner shareable</span><br><span class="line">// AP    | b00     &lt;&lt; 6  | R/W, EL0 access denied</span><br><span class="line">// NS    | b0      &lt;&lt; 5  | Security bit (EL3 and Secure EL1 only)</span><br><span class="line">// INDX  | b100    &lt;&lt; 2  | Attribute index in MAIR_ELn，参见MAIR_EL1_VALUE</span><br><span class="line">// ENTRY | b01     &lt;&lt; 0  | Block entry</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%BC%96%E8%BE%91start.png"
                        class="" title="编辑start"
                 >
<p>(如果<strong>预览不清晰</strong>，可以在<strong>新标签页</strong>中<strong>打开图片</strong>，或者<strong>下载图片</strong>，然后<strong>放大</strong>)</p>
<p>编辑<code>aarch64-qemu.ld</code>，定义前文中用到的<code>LD_TTBR0_BASE</code>和<code>LD_TTBR1_BASE</code>符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x40080000;</span><br><span class="line">    .text.boot : &#123; *(.text.boot) &#125;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        KEEP(*(.text.boot))</span><br><span class="line">        *(.text.exceptions)</span><br><span class="line">        . = ALIGN(4096); /* align for exceptions_vector_table*/</span><br><span class="line">        *(.text.exceptions_vector_table)</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    . = . + 0x4000;</span><br><span class="line">    LD_STACK_PTR = .;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4096);</span><br><span class="line">    /*页表基地址TTBR0*/</span><br><span class="line">    LD_TTBR0_BASE = .;</span><br><span class="line">    . = . + 0x1000;</span><br><span class="line"></span><br><span class="line">    /*页表基地址TTBR1*/</span><br><span class="line">    LD_TTBR1_BASE = .;</span><br><span class="line">    . = . + 0x1000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%BC%96%E8%BE%91ld.png"
                        class="" title="编辑ld"
                 >

<p><strong>编译</strong>并<strong>运行</strong>，<strong>测试</strong>能否<strong>正常工作</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95.png"
                        class="" title="第一次测试"
                 >
<p><strong>正常运行！</strong></p>
<h2 id="二、使用Identity-Mapping映射-偏移映射与页面共享"><a href="#二、使用Identity-Mapping映射-偏移映射与页面共享" class="headerlink" title="二、使用Identity Mapping映射 - 偏移映射与页面共享"></a>二、使用Identity Mapping映射 - 偏移映射与页面共享</h2><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceEight2.tar.gz" title="下载">下载</a></p>
<p>修改代码，将<strong>虚拟地址</strong>2G - 3G处映射到<strong>物理地址</strong>0 - 1G，从而对<strong>0x89000000</strong>地址的写入将通过<strong>pl011</strong>串口输出，因为此时<strong>0x89000000</strong>映射到了<strong>物理地址pl011@9000000</strong>。</p>
</blockquote>
<p>编辑<code>src/start.s</code>，空白映射<strong>虚拟地址</strong>0 - 1G，将<strong>虚拟地址</strong>2G - 3G处映射到<strong>物理地址</strong>0 - 1G。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">_setup_pagetable:</span><br><span class="line">        // 因为采用的36位地址空间，所以是一级页表</span><br><span class="line">        ldr     x1, =LD_TTBR0_BASE</span><br><span class="line">        msr     ttbr0_el1, x1           //页表基地址TTBR0</span><br><span class="line">        ldr     x2, =LD_TTBR1_BASE</span><br><span class="line">        msr     ttbr1_el1, x2           //页表基地址TTBR1</span><br><span class="line"></span><br><span class="line">        // 一级页表部分</span><br><span class="line">        // 虚拟地址空间的下半部分采用Identity Mapping</span><br><span class="line">        // 第一项 虚拟地址0 - 1G</span><br><span class="line">        ldr     x5, =0x0</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line">        // 第二项 虚拟地址1G - 2G，_start部分</span><br><span class="line">        ldr     x3, =_start</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =IDENTITY_MAP_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line">        // 第三项 虚拟地址2 - 3G，根据virt的定义为flash和外设，参见virt.c</span><br><span class="line">        ldr     x3, =0x0</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =PERIPHERALS_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%98%A0%E5%B0%8423G.png"
                        class="" title="映射23G"
                 >

<p>编辑<code>src/interrupts.rs</code>，修改其<strong>基址（2G+原基址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use core::ptr;</span><br><span class="line"></span><br><span class="line">// GICD和GICC寄存器内存映射后的起始地址</span><br><span class="line">const GICD_BASE: u64 = 0x8000_0000 + 0x08000000;</span><br><span class="line">const GICC_BASE: u64 = 0x8000_0000 + 0x08010000;</span><br><span class="line"></span><br><span class="line">// Distributor</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9%E4%B8%AD%E6%96%AD.png"
                        class="" title="修改中断"
                 >

<p>编辑<code>src/pl061.rs</code>，修改其<strong>基址（2G+原基址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line">pub const PL061REGS: *mut PL061Regs = (0x8000_0000u32 + 0x0903_0000) as *mut PL061Regs;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9pl061.png"
                        class="" title="修改pl061"
                 >

<p>编辑<code>src/uart_console/pl011.rs</code>，修改其<strong>基址（2G+原基址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line">pub const PL011REGS: *mut PL011Regs = (0x8000_0000u32 +0x0900_0000) as *mut PL011Regs;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9pl011.png"
                        class="" title="修改pl011"
                 >

<p><strong>编译</strong>并<strong>运行</strong>，<strong>测试</strong>能否<strong>正常工作</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%B5%8B%E8%AF%95.png"
                        class="" title="第二次测试"
                 >
<p><strong>正常运行！</strong></p>
<h2 id="三、使用非Identity-Mapping映射-块级映射"><a href="#三、使用非Identity-Mapping映射-块级映射" class="headerlink" title="三、使用非Identity Mapping映射 - 块级映射"></a>三、使用非Identity Mapping映射 - 块级映射</h2><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceEight3.tar.gz" title="下载">下载</a></p>
</blockquote>
<p>编辑<code>src/start.s</code>，处理<strong>虚拟地址空间</strong>的<strong>上半部分</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">_setup_pagetable:</span><br><span class="line">        // 因为采用的36位地址空间，所以是一级页表</span><br><span class="line">        ldr     x1, =LD_TTBR0_BASE</span><br><span class="line">        msr     ttbr0_el1, x1           //页表基地址TTBR0</span><br><span class="line">        ldr     x2, =LD_TTBR1_BASE</span><br><span class="line">        msr     ttbr1_el1, x2           //页表基地址TTBR1</span><br><span class="line"></span><br><span class="line">        // 一级页表部分</span><br><span class="line">        // 虚拟地址空间的下半部分采用Identity Mapping</span><br><span class="line">        // 第一项 虚拟地址0 - 1G</span><br><span class="line">        ldr     x5, =0x0</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line">        // 第二项 虚拟地址1G - 2G，_start部分</span><br><span class="line">        ldr     x3, =0x40010000</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =IDENTITY_MAP_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line"></span><br><span class="line">        // 虚拟地址空间的上半部分采用非Identity Mapping</span><br><span class="line">        // 第一项 虚拟地址0 - 1G，根据virt的定义为flash和外设，参见virt.c</span><br><span class="line">        ldr     x3, =0x0 //</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =PERIPHERALS_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x2], #8</span><br><span class="line"></span><br><span class="line">        // 第二项， 映射到内存（块级映射）</span><br><span class="line">        ldr     x3, =0x40010000</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =KERNEL_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x2], #8</span><br><span class="line"></span><br><span class="line">_enable_mmu:</span><br><span class="line">// ······</span><br><span class="line"></span><br><span class="line">.equ KERNEL_ATTR, 0x40000000000711</span><br><span class="line">// -------------------------------------</span><br><span class="line">// UXN   | b1      &lt;&lt; 54 | Unprivileged eXecute Never</span><br><span class="line">// PXN   | b0      &lt;&lt; 53 | Privileged eXecute Never</span><br><span class="line">// AF    | b1      &lt;&lt; 10 | Access Flag</span><br><span class="line">// SH    | b11     &lt;&lt; 8  | Inner shareable</span><br><span class="line">// AP    | b00     &lt;&lt; 6  | R/W, EL0 access denied</span><br><span class="line">// NS    | b0      &lt;&lt; 5  | Security bit (EL3 and Secure EL1 only)</span><br><span class="line">// INDX  | b100    &lt;&lt; 2  | Attribute index in MAIR_ELn，参见MAIR_EL1_VALUE</span><br><span class="line">// ENTRY | b01     &lt;&lt; 0  | Block entry</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/start1.png"
                        class="" title="start1"
                 >

<p><strong>重构</strong><code>aarch64-qemu.ld</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">__KERN_VMA_BASE = 0xfffffff000000000;</span><br><span class="line">__PHY_DRAM_START_ADDR = 0x40000000;</span><br><span class="line">__PHY_START_LOAD_ADDR = 0x40010000;</span><br><span class="line"></span><br><span class="line">ENTRY(__PHY_START_LOAD_ADDR)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = __KERN_VMA_BASE + __PHY_START_LOAD_ADDR;</span><br><span class="line">    .text.boot : AT(__PHY_START_LOAD_ADDR) &#123; KEEP(*(.text.boot)) &#125;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.text*)</span><br><span class="line">    &#125;</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line"></span><br><span class="line">    LD_DATA_BASE = .;</span><br><span class="line">    .data : &#123; *(.data*) &#125;</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line"></span><br><span class="line">    LD_RODATA_BASE = .;</span><br><span class="line">    .rodata : &#123; *(.rodata*) &#125;</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line"></span><br><span class="line">    LD_BSS_BASE = .;</span><br><span class="line">    .bss :</span><br><span class="line">    &#123; </span><br><span class="line">        *(.bss*)</span><br><span class="line">        . = ALIGN(4096);</span><br><span class="line">        . += (4096 * 100); /* 栈的大小 */</span><br><span class="line">        stack_top = .;</span><br><span class="line">        LD_STACK_PTR = .;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 页表 */</span><br><span class="line">    .pt :</span><br><span class="line">        &#123;</span><br><span class="line">        . = ALIGN(4096);</span><br><span class="line"></span><br><span class="line">        /* 页表基地址TTBR0 */</span><br><span class="line">        LD_TTBR0_BASE = . - __KERN_VMA_BASE;</span><br><span class="line">        . = . + 0x1000;</span><br><span class="line"></span><br><span class="line">        /* 页表基地址TTBR1 */</span><br><span class="line">        LD_TTBR1_BASE = . - __KERN_VMA_BASE;</span><br><span class="line">        . = . + 0x1000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    . = . + 0x1000;</span><br><span class="line">    LD_KERNEL_END = . - __KERN_VMA_BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑<code>src/interrupts.rs</code>，修改其<strong>基址（0xfffffff000000000+原基址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use core::ptr;</span><br><span class="line"></span><br><span class="line">// GICD和GICC寄存器内存映射后的起始地址</span><br><span class="line">const GICD_BASE: u64 = 0xfffffff000000000 + 0x08000000;</span><br><span class="line">const GICC_BASE: u64 = 0xfffffff000000000 + 0x08010000;</span><br><span class="line"></span><br><span class="line">// Distributor</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9%E4%B8%AD%E6%96%AD3.png"
                        class="" title="修改中断3"
                 >

<p>编辑<code>src/pl061.rs</code>，修改其<strong>基址（0xfffffff000000000+原基址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::&#123;registers::&#123;ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line">pub const PL061REGS: *mut PL061Regs = (0xfffffff000000000u64 + 0x0903_0000) as *mut PL061Regs;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9pl0613.png"
                        class="" title="修改pl0613"
                 >

<p>编辑<code>src/uart_console/pl011.rs</code>，修改其<strong>基址（0xfffffff000000000+原基址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use tock_registers::&#123;registers::&#123;ReadOnly, ReadWrite, WriteOnly&#125;, register_bitfields, register_structs&#125;;</span><br><span class="line"></span><br><span class="line">pub const PL011REGS: *mut PL011Regs = (0xfffffff000000000u64 + 0x0900_0000) as *mut PL011Regs;</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E6%94%B9pl0113.png"
                        class="" title="修改pl0113"
                 >

<p><strong>编译</strong>并<strong>运行</strong>，<strong>测试</strong>能否<strong>正常工作</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95.png"
                        class="" title="第三次测试"
                 >
<p><strong><del>正常运行！</del></strong></p>
<h3 id="修复异常现象"><a href="#修复异常现象" class="headerlink" title="修复异常现象"></a>修复异常现象</h3><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceEight3Fix.tar.gz" title="下载">下载</a></p>
</blockquote>
<p>乍一看能<strong>正常运行</strong>，但是运行一段时间后居然<strong>卡死</strong>了！这是<strong>为什么</strong>呢？</p>
<p><strong>第一时间</strong>想到的是<strong>互斥锁</strong>可能出问题了，但是仔细看<strong>互斥锁</strong>的<strong>代码</strong>发现和<strong>内存映射</strong>关系应该不大。</p>
<p>仔细观察<strong>输出</strong>发现<strong>打点</strong>是<strong>正常</strong>的，而且在<strong>没有卡死之前</strong>如果触发<strong>输入中断</strong>则会<strong>立刻卡死</strong>，因此判断是<strong>输入中断</strong>出了问题， <strong><a class="link"   target="_blank" rel="noopener" href="https://noionion.top/" >noionion<i class="fas fa-external-link-alt"></i></a></strong> 认为是<strong>链接脚本</strong>的问题，而<strong>事实</strong>也如他所说。</p>
<p>编辑<code>aarch64-qemu.ld</code>，修改<code>.text : &#123;&#125;</code>部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* ······ */</span><br><span class="line">.text.boot : AT(__PHY_START_LOAD_ADDR) &#123; KEEP(*(.text.boot)) &#125;</span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">    KEEP(*(.text.boot))</span><br><span class="line">    *(.text.exceptions)</span><br><span class="line">    . = ALIGN(4096); /* align for exceptions_vector_table*/</span><br><span class="line">    *(.text.exceptions_vector_table)</span><br><span class="line">    *(.text)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(0x1000);</span><br><span class="line">/* ······ */</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BF%AE%E5%A4%8Dld.png"
                        class="" title="修复ld"
                 >

<p><strong>编译</strong>并<strong>运行</strong>，<strong>测试</strong>能否<strong>正常工作</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%AC%AC%E4%B8%89%E7%82%B9%E4%BA%94%E6%AC%A1%E6%B5%8B%E8%AF%95.png"
                        class="" title="第三点五次测试"
                 >
<p><strong>正常运行！</strong></p>
<h2 id="四、使用非Identity-Mapping映射-页表映射"><a href="#四、使用非Identity-Mapping映射-页表映射" class="headerlink" title="四、使用非Identity Mapping映射 - 页表映射"></a>四、使用非Identity Mapping映射 - 页表映射</h2><blockquote>
<p>参考代码：<a href="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/ScienceEight4.tar.gz" title="下载">下载</a></p>
</blockquote>
<p>在<strong>成功实现块级映射</strong>后，我们就可以尝试<strong>实现二级页表映射</strong>了。<br>编辑<code>src/start.s</code>，修改<strong>块级映射</strong>为<strong>二级页表映射</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// ······</span><br><span class="line">_setup_pagetable:</span><br><span class="line">        // 因为采用的36位地址空间，所以是一级页表</span><br><span class="line">        ldr     x1, =LD_TTBR0_BASE</span><br><span class="line">        msr     ttbr0_el1, x1           //页表基地址TTBR0</span><br><span class="line">        ldr     x2, =LD_TTBR1_BASE</span><br><span class="line">        msr     ttbr1_el1, x2           //页表基地址TTBR1</span><br><span class="line"></span><br><span class="line">        // 一级页表部分</span><br><span class="line">        // 虚拟地址空间的下半部分采用Identity Mapping</span><br><span class="line">        // 第一项 虚拟地址0 - 1G</span><br><span class="line">        ldr     x5, =0x0</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line">        // 第二项 虚拟地址1G - 2G，_start部分</span><br><span class="line">        ldr     x3, =LD_TTBR1_L2TBL</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =IDENTITY_MAP_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x1], #8</span><br><span class="line"></span><br><span class="line">        // 虚拟地址空间的上半部分采用非Identity Mapping</span><br><span class="line">        // 第一项 虚拟地址0 - 1G，根据virt的定义为flash和外设，参见virt.c</span><br><span class="line">        ldr     x3, =0x0</span><br><span class="line">        lsr     x4, x3, #30             // 除以1G</span><br><span class="line">        lsl     x5, x4, #30             // 乘以1G，并且将表索引保存在x0</span><br><span class="line">        ldr     x6, =PERIPHERALS_ATTR</span><br><span class="line">        orr     x5, x5, x6              // 添加符号</span><br><span class="line">        str     x5, [x2], #8</span><br><span class="line"></span><br><span class="line">        // 第二项，映射到页表</span><br><span class="line">        ldr     x3, =LD_TTBR1_L2TBL</span><br><span class="line">        ldr     x4, =0xFFFFF000</span><br><span class="line">        and     x5, x3, x4             // NSTable=0 APTable=0 XNTable=0 PXNTable=0.</span><br><span class="line">        orr     x5, x5, 0x3            // Valid page table entry</span><br><span class="line">        str     x5, [x2], #8           //TTBR1</span><br><span class="line"></span><br><span class="line">        // 二级页表，内核总共16M，参见aarch64-qemu.ld文件</span><br><span class="line">        ldr     x3, =LD_TTBR1_L2TBL</span><br><span class="line">        mov     x4, #8                  // 8个二级页表项</span><br><span class="line">        ldr     x5, =KERNEL_ATTR        // 内核属性，可读写，可执行</span><br><span class="line">        ldr     x7, =0x1</span><br><span class="line">        add     x5, x5, x7, lsl #30     // 物理地址在1G开始的位置</span><br><span class="line">        ldr     x6, =0x00200000         // 每次增加2M</span><br><span class="line"></span><br><span class="line">_build_2nd_pgtbl:</span><br><span class="line">        str     x5, [x3], #8            // 填入内容到页表项</span><br><span class="line">        add     x5, x5, x6              // 下一项的地址增加2M</span><br><span class="line">        subs    x4, x4, #1              // 项数减少1</span><br><span class="line">        bne     _build_2nd_pgtbl</span><br><span class="line"></span><br><span class="line">_enable_mmu:</span><br><span class="line">// ······</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84.png"
                        class="" title="二级页表映射"
                 >

<p>编辑<code>aarch64-qemu.ld</code>，定义<code>LD_TTBR0_L2TBL</code>以及<code>LD_TTBR1_L2TBL</code>符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* ······ */</span><br><span class="line">/* 页表 */</span><br><span class="line">.pt :</span><br><span class="line">    &#123;</span><br><span class="line">    . = ALIGN(4096);</span><br><span class="line"></span><br><span class="line">    /* 页表基地址TTBR0 */</span><br><span class="line">    LD_TTBR0_BASE = . - __KERN_VMA_BASE;</span><br><span class="line">    . = . + 0x1000;</span><br><span class="line"></span><br><span class="line">    /* 页表基地址TTBR1 */</span><br><span class="line">    LD_TTBR1_BASE = . - __KERN_VMA_BASE;</span><br><span class="line">    . = . + 0x1000;</span><br><span class="line"></span><br><span class="line">    /*二级页表*/</span><br><span class="line">    LD_TTBR0_L2TBL = . - __KERN_VMA_BASE;</span><br><span class="line">    . = . + 0x1000;</span><br><span class="line"></span><br><span class="line">    LD_TTBR1_L2TBL = . - __KERN_VMA_BASE;</span><br><span class="line">    . = . + 0x1000;</span><br><span class="line">    &#125;</span><br><span class="line">/* ······ */</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E6%9C%80%E5%90%8E%E7%9A%84ld%E6%94%B9%E5%8A%A8.png"
                        class="" title="最后的ld改动"
                 >

<p><strong>编译</strong>并<strong>运行</strong>，<strong>测试</strong>能否<strong>正常工作</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo clean &amp;&amp; cargo build &amp;&amp; qemu-system-aarch64 -machine virt,gic-version=2 -cpu cortex-a57 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/rui_armv8_os -semihosting</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/26/BlogOS%EF%BC%9AARM-v8%E4%B9%8B%E6%97%85/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%B5%8B%E8%AF%95.png"
                        class="" title="第四次测试"
                 >
<p><strong>正常运行！</strong></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>前前后后花了<strong>三个月时间</strong>完成了这篇<strong>1.6W</strong>字的笔记，<strong>最大</strong>的<strong>感悟</strong>却是：<strong>自己的挖的坑只能含泪填完</strong>。</p>

                </div>
                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                BlogOS：ARM v8之旅
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2022/02/26/BlogOS：ARM-v8之旅/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">Xayah</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2022-02-26 15:02</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/BlogOS/">BlogOS</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E7%A7%BB%E6%A4%8D/">移植</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2022/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9AOpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                                   title="计算机视觉：OpenCV学习笔记"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">计算机视觉：OpenCV学习笔记</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2022/02/25/%E6%88%90%E4%B8%BAWheel-Maker%EF%BC%9A%E5%8F%91%E5%B8%83Android%E5%BA%93%E5%88%B0MavenCentral/"
                                   title="成为Wheel Maker：发布Android库到MavenCentral"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">成为Wheel Maker：发布Android库到MavenCentral</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-text">参考文章</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">一、环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85Rust"><span class="nav-text">1. 安装Rust</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0ARM-v8%E6%94%AF%E6%8C%81"><span class="nav-text">2. 添加ARM v8支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%89%E8%A3%85QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="nav-text">3. 安装QEMU模拟器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%8B%E8%BD%BD%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-AArch64"><span class="nav-text">4. 下载交叉编译工具链 (AArch64)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%9C%BA-Bare-Metal-%E7%A8%8B%E5%BA%8F"><span class="nav-text">5. 创建裸机(Bare Metal)程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-text">新建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="nav-text">编译与运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Hello-World"><span class="nav-text">二、Hello World</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%86%E8%A7%A3virt%E6%9C%BA%E5%99%A8"><span class="nav-text">1. 了解virt机器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%87%E6%A1%A3%E6%88%96%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-text">1) 文档或源码方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88Device-Tree%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="nav-text">2) 设备树（Device Tree）方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0println-%E5%AE%8F"><span class="nav-text">2. 实现println!宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%AE%9E%E7%8E%B0println-%E5%AE%8F"><span class="nav-text">1) 用串口实现println!宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95"><span class="nav-text">2) 测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%A8%E5%B1%80%E5%AE%9E%E7%8E%B0"><span class="nav-text">3) 全局实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="nav-text">三、设备树（可选）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E6%96%AD"><span class="nav-text">四、中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%99%B7%E5%85%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">1) 陷入操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ARM%E7%9A%84%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="nav-text">2) ARM的中断系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-GICv2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3) GICv2初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ARMv8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">4) ARMv8的中断与异常处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><span class="nav-text">1) 编写代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E8%83%BD%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-text">2) 使能时钟中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%B0%83%E8%AF%95"><span class="nav-text">3) 调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E3%80%81%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-text">四*、实现真正的时钟中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B4%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-text">1. 整理代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">2. 实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%BE%93%E5%85%A5"><span class="nav-text">五、输入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85tock-registers%E5%BA%93"><span class="nav-text">1. 安装tock-registers库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%87%8D%E6%9E%84"><span class="nav-text">2. 重构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E4%B8%AD%E6%96%AD"><span class="nav-text">3. 数据接收中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81GPIO%E5%85%B3%E6%9C%BA"><span class="nav-text">六、GPIO关机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8E%9F%E7%90%86"><span class="nav-text">1. 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">2. 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%89%A7%E8%A1%8C"><span class="nav-text">3. 执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%AD%BB%E9%94%81%E4%B8%8E%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-text">七、死锁与简单处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8B%98%E8%AF%AF"><span class="nav-text">勘误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%8D%E7%8E%B0"><span class="nav-text">死锁的复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-loop-%E4%B8%ADprint-%E5%AE%8F%E4%B8%8Ehandle-uart0-rx-irq-%E4%B8%ADprint-%E5%AE%8F%E7%AB%9E%E4%BA%89"><span class="nav-text">1. loop{}中print!宏与handle_uart0_rx_irq()中print!宏竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-loop-%E4%B8%ADprint-%E5%AE%8F%E4%B8%8Ehandle-timer-irq-%E4%B8%ADprint-%E5%AE%8F%E7%AB%9E%E4%BA%89"><span class="nav-text">2. loop{}中print!宏与handle_timer_irq()中print!宏竞争</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-text">死锁的简单处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-text">验证</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">八、内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-v8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">ARM v8的地址转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8Identity-Mapping%E6%98%A0%E5%B0%84"><span class="nav-text">一、使用Identity Mapping映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8Identity-Mapping%E6%98%A0%E5%B0%84-%E5%81%8F%E7%A7%BB%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A1%B5%E9%9D%A2%E5%85%B1%E4%BA%AB"><span class="nav-text">二、使用Identity Mapping映射 - 偏移映射与页面共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E9%9D%9EIdentity-Mapping%E6%98%A0%E5%B0%84-%E5%9D%97%E7%BA%A7%E6%98%A0%E5%B0%84"><span class="nav-text">三、使用非Identity Mapping映射 - 块级映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%BC%82%E5%B8%B8%E7%8E%B0%E8%B1%A1"><span class="nav-text">修复异常现象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E9%9D%9EIdentity-Mapping%E6%98%A0%E5%B0%84-%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84"><span class="nav-text">四、使用非Identity Mapping映射 - 页表映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-text">后记</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Xayah</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
                
                <div class="deploy-info info-item default">
                    
                        本站由 <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/deploy-provider/github.png"></span> 提供部署服务
                    
                </div>
            
        

        <div class="count-item info-item default">
            
                <span class="count-box border-box word">
                    <span class="item-type border-box">总字数</span>
                    <span class="item-value border-box word">42.1k</span>
                </span>
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-text">参考文章</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">一、环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85Rust"><span class="nav-text">1. 安装Rust</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0ARM-v8%E6%94%AF%E6%8C%81"><span class="nav-text">2. 添加ARM v8支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%89%E8%A3%85QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="nav-text">3. 安装QEMU模拟器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%8B%E8%BD%BD%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-AArch64"><span class="nav-text">4. 下载交叉编译工具链 (AArch64)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%9C%BA-Bare-Metal-%E7%A8%8B%E5%BA%8F"><span class="nav-text">5. 创建裸机(Bare Metal)程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-text">新建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="nav-text">编译与运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-text">调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Hello-World"><span class="nav-text">二、Hello World</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%86%E8%A7%A3virt%E6%9C%BA%E5%99%A8"><span class="nav-text">1. 了解virt机器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%87%E6%A1%A3%E6%88%96%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-text">1) 文档或源码方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88Device-Tree%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="nav-text">2) 设备树（Device Tree）方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0println-%E5%AE%8F"><span class="nav-text">2. 实现println!宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%AE%9E%E7%8E%B0println-%E5%AE%8F"><span class="nav-text">1) 用串口实现println!宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95"><span class="nav-text">2) 测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%A8%E5%B1%80%E5%AE%9E%E7%8E%B0"><span class="nav-text">3) 全局实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="nav-text">三、设备树（可选）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E6%96%AD"><span class="nav-text">四、中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%99%B7%E5%85%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">1) 陷入操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ARM%E7%9A%84%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="nav-text">2) ARM的中断系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-GICv2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3) GICv2初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ARMv8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">4) ARMv8的中断与异常处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><span class="nav-text">1) 编写代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E8%83%BD%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-text">2) 使能时钟中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%B0%83%E8%AF%95"><span class="nav-text">3) 调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E3%80%81%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-text">四*、实现真正的时钟中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B4%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-text">1. 整理代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">2. 实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%BE%93%E5%85%A5"><span class="nav-text">五、输入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85tock-registers%E5%BA%93"><span class="nav-text">1. 安装tock-registers库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%87%8D%E6%9E%84"><span class="nav-text">2. 重构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E4%B8%AD%E6%96%AD"><span class="nav-text">3. 数据接收中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81GPIO%E5%85%B3%E6%9C%BA"><span class="nav-text">六、GPIO关机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8E%9F%E7%90%86"><span class="nav-text">1. 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">2. 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%89%A7%E8%A1%8C"><span class="nav-text">3. 执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%AD%BB%E9%94%81%E4%B8%8E%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-text">七、死锁与简单处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8B%98%E8%AF%AF"><span class="nav-text">勘误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%8D%E7%8E%B0"><span class="nav-text">死锁的复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-loop-%E4%B8%ADprint-%E5%AE%8F%E4%B8%8Ehandle-uart0-rx-irq-%E4%B8%ADprint-%E5%AE%8F%E7%AB%9E%E4%BA%89"><span class="nav-text">1. loop{}中print!宏与handle_uart0_rx_irq()中print!宏竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-loop-%E4%B8%ADprint-%E5%AE%8F%E4%B8%8Ehandle-timer-irq-%E4%B8%ADprint-%E5%AE%8F%E7%AB%9E%E4%BA%89"><span class="nav-text">2. loop{}中print!宏与handle_timer_irq()中print!宏竞争</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-text">死锁的简单处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-text">验证</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">八、内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-v8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">ARM v8的地址转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8Identity-Mapping%E6%98%A0%E5%B0%84"><span class="nav-text">一、使用Identity Mapping映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8Identity-Mapping%E6%98%A0%E5%B0%84-%E5%81%8F%E7%A7%BB%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A1%B5%E9%9D%A2%E5%85%B1%E4%BA%AB"><span class="nav-text">二、使用Identity Mapping映射 - 偏移映射与页面共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E9%9D%9EIdentity-Mapping%E6%98%A0%E5%B0%84-%E5%9D%97%E7%BA%A7%E6%98%A0%E5%B0%84"><span class="nav-text">三、使用非Identity Mapping映射 - 块级映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%BC%82%E5%B8%B8%E7%8E%B0%E8%B1%A1"><span class="nav-text">修复异常现象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E9%9D%9EIdentity-Mapping%E6%98%A0%E5%B0%84-%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84"><span class="nav-text">四、使用非Identity Mapping映射 - 页表映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-text">后记</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/libs/anime.min.js"></script>

<!-- local-search -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/local-search.min.js"></script>


<!-- lazyload -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/lazyload.min.js"></script>


<div class="pjax">
    
        <!-- post-helper -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/post/post-helper.min.js"></script>

        <!-- toc -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/post/toc.min.js"></script>
        

        <!-- copyright-info -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/post/copyright-info.min.js"></script>
        

        <!-- share -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/post/share.min.js"></script>
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.0/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1}});</script></body>
</html>
